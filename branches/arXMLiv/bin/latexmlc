#!/usr/bin/perl -w

#######################
# A Client for LaTeXML
#######################
use strict;
use warnings;

use Pod::Usage;
use Carp;
use Cwd qw(cwd abs_path);
use IO::Socket;

my $RealBin_safe;
use FindBin;
BEGIN {
  $FindBin::RealBin =~ /^([^\0]+)\z/; # Valid Unix path TODO: Windows, revisit regexp
  $RealBin_safe = $1;
  die 'Fatal:IO:tainted RealBin was tainted! Failing...' unless ($RealBin_safe && (-e $RealBin_safe.'/latexmlc'));
}
# TODO: We probably want file cat for things like /../lib instead of spelling out a Unix path
use lib $RealBin_safe."/../lib";
#TODO: Do we ever care about ENV PATH that much? Do we miss on some feature like that?
#$ENV{PATH} = "$RealBin_safe:/usr/bin:/usr/local/bin:";

use LaTeXML::Daemon;
use LaTeXML::Version;
use LaTeXML::Util::Pathname;
use LaTeXML::Util::Config;
use Storable qw(freeze thaw);

binmode(STDERR,":encoding(UTF-8)");
binmode(STDOUT,":encoding(UTF-8)");

# Some defaults:
my $opts=LaTeXML::Util::Config->new(
	  identity => "latexmlc (LaTeXML version $LaTeXML::Version::VERSION, rev $LaTeXML::Version::REVISION)",
	  profile => 'custom',
	  'input_limit' => 100,
	  timeout => -1, # Don't start a server as default
	  port => 3354,
    verbosity=>0
	 );

# Parse and load command-line options
$opts->read(\@ARGV);

my %portlist = ( math=>3334, fragment=>3344, standard=>3354);
$opts->set('port', $portlist{$opts->get('profile')}) unless $opts->get('port');
$opts->set('port', 3334) unless $opts->get('port'); #Fall back to 3334 if all fails...

# Local if no timeout wanted (classic latexml invocation):
$opts->set('local', 1) if (($opts->get('timeout') == -1) && (!defined $opts->get('local')));
# TODO: Rethink this carefully, where does the "local" security get inspected?
# Unset destinations unless local conversion has been requested:
if (!$opts->get('local') && ($opts->get('destination') || $opts->get('log') || $opts->get('postdest') || $opts->get('postlog'))) 
  {carp "I/O from filesystem not allowed without --local!\n".
     " Will revert to sockets!\n";
   $opts->set('destination',undef);
   $opts->set('log',undef);
   $opts->set('postdest',undef);
   $opts->set('postlog',undef);}
#***************************************************************************
#Add some base, so that relative paths work
my $cdir = abs_path(cwd());
$cdir =~ s/ /\\ /g;
$opts->set('base',$cdir) unless $opts->get('base');

# Record if destination exists, for summary
$opts->set('destination', pathname_canonical($opts->get('destination'))) if $opts->get('destination');
my $deststat;
$deststat = (stat($opts->get('destination')))[9] if $opts->get('destination');
$deststat = 0 unless defined $deststat;

# Revert to sockets if no --local
if (!$opts->get('local') && ($opts->get('destination') || $opts->get('log')))
  {carp "I/O from filesystem not allowed without --local!\n".
     " Will revert to sockets!\n";
   $opts->set('destination',undef);
   $opts->set('log',undef); }

push @{$opts->get('paths')}, $cdir; #add current path, to ensure never empty

#***************************************************************************
# Prepare output variables:
my  ($result, $status, $log);

# TODO: Maybe allow remote hosts?
#       Coming to think of it, maybe allow latexmlc to talk to ltxmojo via http?
#       e.g. latexmlc --remote=latexml.mathweb.org/convert --mode=math '1+2=3'
#Setup client and communicate
my $sock = IO::Socket::INET->new
  ( PeerAddr => '127.0.0.1',
    PeerPort => $opts->get('port'),
    Proto => 'tcp',
  ); #Attempt connecting to a service
if ((!$sock) && ($opts->get('timeout') == -1)) {
  # Don't boot a server, single job requested:
  # NOTE: Log will differ, single run gets initialization log at STDERR
  #       while server communication suppresses that part of the log otherwise
  #   (except when errors occur)
  my $source = $opts->get('source');
  $opts->delete('source');

  my $daemon = LaTeXML::Daemon->get_converter($opts);
  $daemon->prepare_session($opts);
  my $response = $daemon->convert($source);

  ($result, $status, $log) = map { $response->{$_} } qw(result status log) if defined $response;

} else {
  #Startup daemon and feed in args, if needed
  my $destopt = (($opts->get('local')) && ($opts->get('destination'))
     && ('--destination='.$opts->get('destination'))) || '';
  my $formatopt = (($opts->get('format')) && ('--format='.$opts->get('format'))) || '';
  system("$RealBin_safe/latexmls",'--port='.$opts->get('port'),
    '--timeout='.$opts->get('timeout'),'--autoflush='.$opts->get('input_limit'),
     $destopt, $formatopt) unless $sock;

  #Daemon is running, reconnect and feed in request
  $sock = IO::Socket::INET->new 
    ( PeerAddr => '127.0.0.1',
      PeerPort => $opts->get('port'),
      Proto => 'tcp',
    );
  croak "Fatal:perl:socket-create Could not create socket: $!\n" unless $sock; 
  my ($response,$batch);
  $sock->send(freeze($opts->options)."\nEND REQUEST\n");
  do {
    $sock->recv($batch,1024);
    $response.=$batch;
  } while ($batch);
  close($sock);

  $response = thaw($response);
  ($result, $status, $log) = map { $response->{$_} } qw(result status log) if defined $response;
}

#***************************************************************************
### Common treatment of output:

# Special features for latexmls:
if ($log) {
  if ($opts->get('log') && $opts->get('local')) {
    my $clog = $opts->get('log');
    my $log_handle;
    open($log_handle,">",$clog) or
       croak "Fatal:IO:forbidden Couldn't open log file $clog : $!\n";
    print $log_handle $log;
    close $log_handle;
  } else {print STDERR $log,"\n";}#STDERR log otherwise
}

if ($result) {
  if ($opts->get('destination') && $opts->get('local')) {
    my $output_handle;
    open($output_handle,">",$opts->get('destination')) or croak "Fatal:IO:forbidden Couldn't open output file ".$opts->get('destination').": $!";
    print $output_handle $result;
    close $output_handle;
  } else { print STDOUT $result,"\n"; } #Output to STDOUT
}

# Print summary, if requested, to STDERR
if ($opts->get('destination')) {
  print STDERR $status;
  print STDERR summary($opts->get('destination'),$deststat);
}

# == Helpers ==
sub summary {
  my ($destination,$prior_stat) = @_;
  my $new_stat = (stat($destination))[9] || 0;
  return ($new_stat && ($prior_stat != $new_stat)) ? "\nWrote $destination\n" :
  "\nError! Did not write file $destination\n";
}

#**********************************************************************
__END__

=head1 NAME

C<latexmlc> - A client for L<latexml>, L<latexmlpost> and L<latexmlmath>.

=head1 SYNOPSYS

See the OPTIONS section in L<LaTeXML::Util::Config> for usage information.
Also consult latexmlc --help

=head1 DESCRIPTION

L<latexmlc> provides a client which automatically sets up a LaTeXML local server if necessary
(via L<latexmls>).

If such server already exists, the client proceeds to communicate normally.

=head1 SEE ALSO

L<latexmls>, L<ltxmojo>, L<LaTeXML::Util::Config>

=cut
#**********************************************************************

