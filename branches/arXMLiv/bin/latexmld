#!/usr/bin/perl -w
use strict;
use FindBin;
use lib "$FindBin::RealBin/../lib";
use Getopt::Long qw(:config no_ignore_case);
use Pod::Usage;
use LaTeXML;
use LaTeXML::Util::Pathname;
use LaTeXML;
use LaTeXML::Post;
use LaTeXML::Post::Writer;
use LaTeXML::Post::Scan;
use LaTeXML::Util::Pathname;
use LaTeXML::Util::ObjectDB;

#**********************************************************************
# Parse command line
my $identity = "latexml (LaTeXML version $LaTeXML::VERSION)";
my($verbosity,$strict,$comments,$noparse,$includestyles,
   $errlog,$post,$parallelmath)=(0,0,1,0,0,0,0,0);
my ($format,$mode,$destination,$log,$procs_post,$help,$showversion,$stylesheet)=('xml','fragment','','',{});
my ($documentid);
my $inputencoding;
my $type = 'auto';
my @paths = ('.');
my (@preload,@debugs);
GetOptions("destination=s" => \$destination,
	   "output=s"  => \$destination,
	   "preload=s" => \@preload,
	   "path=s"    => \@paths,
	   "quiet"     => sub { $verbosity--; },
	   "verbose"   => sub { $verbosity++; },
	   "strict"    => \$strict,
	   "xml"       => sub { $format = 'xml'; },
	   "tex"       => sub { $format = 'tex'; },
	   "box"       => sub { $format = 'box'; },
	   "bibtex"    => sub { $type='bibtex'; },
	   "noparse"   => \$noparse,
	   "mode=s"  => \$mode,
	   "log=s"       => \$log,
	   "includestyles"=> \$includestyles,
	   "inputencoding=s"=>\$inputencoding,
	   "post"      => \$post,
	   "pmml"      => sub {$$procs_post{'pmml'}=1;},
	   "cmml"      => sub {$$procs_post{'cmml'}=1;},
	   "om"        => sub {$$procs_post{'om'}=1;},
	   "keepTeX"   => sub {$$procs_post{'keepTeX'}=1;},
	   "keepXMath" => sub {$$procs_post{'keepXMath'}=1;},
	   "parallelmath" => \$parallelmath,
	   "stylesheet=s"=>\$stylesheet,
	   "comments!" => \$comments,
	   "VERSION"   => \$showversion,
	   "debug=s"   => sub { eval "\$LaTeXML::$_[1]::DEBUG=1; "; },
	   "documentid=s" => \$documentid,
	   "help"      => \$help,
	  ) or pod2usage(-message => $identity, -exitval=>1, -verbose=>0, -output=>\*STDERR);
pod2usage(-message=>$identity, -exitval=>1, -verbose=>2, -output=>\*STDOUT) if $help;
if($showversion){ print STDERR "$identity\n"; exit(1); }

#This is obsolete in daemon mode:
#pod2usage(-message=>"$identity\nMissing input TeX file", 
#	  -exitval=>1, -verbose=>0,-output=>\*STDERR) unless @ARGV;

#**********************************************************************
# Set up the processing.
print STDERR "$identity\n" unless $verbosity < 0;

$mode = lc($mode);
$$procs_post{'pmml'}=1 unless (scalar(keys %$procs_post));
if ($mode eq "math") {
    #Preload math packages:
    my  @mathpreload = ("LaTeX.pool", "amsmath.sty", "amsthm.sty", "amstext.sty", "amssymb.sty", "eucal.sty");
    @preload=(@preload,@mathpreload);
}
@paths = map(pathname_canonical($_),@paths);
my $latexml= LaTeXML->new(preload=>[@preload], searchpaths=>[@paths],
			  verbosity=>$verbosity, strict=>$strict,
			  includeComments=>$comments,inputencoding=>$inputencoding,
			  includeStyles=>$includestyles,
			  documentid=>$documentid,
			  nomathparse=>$noparse);

if(my @baddirs = grep(! -d $_, @paths)){
    warn "$identity: these path directories do not exist: ".join(', ',@baddirs)."\n"; }
binmode(STDERR,":utf8");

#Initialize state:
$latexml->withState(sub {
  my($state)=@_;
  $latexml->initializeState('TeX.pool', @{$$latexml{preload} || []});
});

print STDERR "\n"; #Sanitize log.
#**********************************************************************
# Daemon has been set up, now process files on demand:
while(1) {
    my $source = <STDIN>;
    chomp $source;
    $source =~ s/^\s+//; #Cleanup space
    $source =~ s/\s+$//; #Cleanup space
    last if (!$source || ($source eq "")); #empty marks we're done
    if ($mode eq "math") {
	#Special handling for math --mode
	my $texdoc = mathdoc($source);
	my $dom;
	eval {
	    my $digested = $latexml->digestStringDaemonized($texdoc);
	    $dom = $latexml->convertDocument($digested);
	};
	doPost(log=>$log,dest=>$destination,stylesheet=>$stylesheet,dom=>$dom,
	       mode=>"math",parallel=>$parallelmath,procs=>$procs_post);
	undef $texdoc;
	next;
    }
    if($source eq '-'){
	print STDERR "Invalid source file:\n"
	." latexmldaemon requires a filepath per line as arguments\n";
	next;
    }
    $source = pathname_find($source,types=>['tex','']);
    $source = pathname_canonical($source);
    $type = 'bibtex' if ($type eq 'auto') && ($source =~ /\.bib$/);
    # ========================================
    # First read and digest whatever we're given.
    my $digested;
    my ($dir,$name,$ext) = pathname_split($source);
    #Redirect to logfile, if requested:
    my $clog;
    if ($log) {
	$clog = $log;
	$clog=~s/#name/$name/eg;
	$clog=~s/#dir/$dir/eg;
	$clog=~s/#ext/$ext/eg;
	open(LOG,">$clog");
	*ERRORIG=*STDERR;
	*STDERR = *LOG;
    }
    my $cdest;
    if ($destination) {
	$cdest = $destination;
	$cdest =~ s/#name/$name/eg;
	$cdest =~ s/#dir/$dir/eg;
	$cdest =~ s/#ext/$ext/eg;
    } else {
	$cdest = $source.".$format";
    }
    if ($mode eq "standard") {
	#In the classic case, we need to reinitialize latexml
	# on every input
	undef $latexml;
	$latexml= LaTeXML->new(preload=>[@preload], searchpaths=>[@paths],
			  verbosity=>$verbosity, strict=>$strict,
			  includeComments=>$comments,inputencoding=>$inputencoding,
			  includeStyles=>$includestyles,
			  documentid=>$documentid,
			  nomathparse=>$noparse);
	$latexml->withState(sub {
	       my($state)=@_;
	       $latexml->initializeState('TeX.pool', @{$$latexml{preload} || []});
	   });
	print STDERR "\n"; #Again, flush log
    }
    #Continue with processing in standard and fragment cases:
    $latexml->withState(sub {
	   my($state)=@_;#Sandbox state
	   $state->pushFrame; });
    my $serialized;
    my $dom;
    eval {
	if ($type eq 'bibtex'){
	    $digested = $latexml->digestBibTeXFileDaemonized($source); }
	else {
	    $digested = $latexml->digestFileDaemonized($source); 
	}
	# ========================================
	# Now, convert to DOM and output, if desired.
	#use Encode;
	if($digested){
	    local $LaTeXML::Global::STATE = $$latexml{state};
	    if($format eq 'tex'){
		$serialized = LaTeXML::Global::UnTeX($digested); }
	    elsif($format eq 'box'){
		$serialized = $digested->toString; }
	    else {
		$dom = $latexml->convertDocument($digested); 
		$serialized = $dom->toString(1);
	    }
	}
    };
    if ($@) { #Fatal occured!
	print STDERR "$@\n";
	print STDERR "\nConversion complete: ".$latexml->getStatusMessage.".\n";
	#Need to reset latexml in these cases
	if ($log) { close(LOG); *STDERR = *ERRORIG;} #Close log file
	undef $latexml;
	$latexml= LaTeXML->new(preload=>[@preload], searchpaths=>[@paths],
			  verbosity=>$verbosity, strict=>$strict,
			  includeComments=>$comments,inputencoding=>$inputencoding,
			  includeStyles=>$includestyles,
			  documentid=>$documentid,
			  nomathparse=>$noparse);
	$latexml->withState(sub {
	       my($state)=@_;
	       $latexml->initializeState('TeX.pool', @{$$latexml{preload} || []});
	   });
	print STDERR "\n"; #Again, flush log
	next; #Move on, no body to be produced.
    }
    print STDERR "\nConversion complete: ".$latexml->getStatusMessage.".\n";
    $latexml->withState(sub {
          my($state)=@_;#Remove current state frame
	  $state->popFrame;
	  $state->setStatus("warning",0);
	  $state->setStatus("error",0);
	  $state->setStatus("fatal",0);
	  $state->setStatus("undefined",0);
	  $state->setStatus("missing",0);
      });
    if($cdest){
	open(OUT,">",$cdest) or die "Couldn't open output file $cdest: $!"; }
    else {
	#  binmode(STDOUT,":utf8");
	*OUT = *STDOUT; }
    print OUT $serialized if $serialized;
    if($cdest){ 
	close(OUT); }
    if ($log) { close(LOG); *STDERR = *ERRORIG;} #Close log file
    if ($post && $dom && $cdest && (!$noparse)) {
	#Postprocess
	my $postlog = $clog;
	if ($postlog) {
	    #Add .post. to log name
	    $postlog=~s/\.(\w+)$/".post.".$1/e;
	    open(PLOG,">$postlog");
	    *ERRORIG = *STDERR;
	    *STDERR = *PLOG;
	}
	my $postdest = $cdest;
	$postdest.=".xhtml" unless
	($postdest=~s/\.tex\.xml$/.xhtml/ || $postdest=~s/\.xml$/.xhtml/);
	doPost(log=>$postlog,dest=>$postdest,stylesheet=>$stylesheet,dom=>$dom,mode=>$mode,
	      parallel=>$parallelmath,procs=>$procs_post);
    }
}

#======================================================================
# Helpers
#======================================================================
our %PostOPS = (verbosity=>$verbosity||0);
sub doPost {
    my (%options)=@_;
    my ($postlog,$postdest,$stylesheet,$dom,$extract,$parallelmath,$proctypes)= 
       map ($options{$_},qw(log dest stylesheet dom mode parallel procs));
    #Postprocess
    #TODO: Make this scalable, currently the arXMLiv default is hardcoded
    $stylesheet = "LaTeXML-xhtml.xsl" unless $stylesheet;
    my @css = ("core.css");
    $parallelmath = $parallelmath||0;
    my $doc = LaTeXML::Post::Document->new($dom,
					   destination=>$postdest,nocache=>1);
    require 'LaTeXML/Post/MathML.pm';
    require 'LaTeXML/Post/PurgeXMath.pm';
    my @mprocs;
    push @mprocs, LaTeXML::Post::MathML::Presentation->new(%PostOPS) if $$proctypes{'pmml'};
    push @mprocs, LaTeXML::Post::MathML::Content->new(%PostOPS) if $$proctypes{'cmml'};
    my $main = shift(@mprocs);
    $main->setParallel(@mprocs) if $parallelmath;
    my @procs;
    push(@procs,$main); #If not parallel, only the first one goes through.
    push(@procs, LaTeXML::Post::PurgeXMath->new(%PostOPS)) unless $$proctypes{'keepXMath'};
    require 'LaTeXML/Post/XSLT.pm';
    my @csspaths=();
    foreach my $css (@css){
	$css .= '.css' unless $css =~ /\.css$/;
	# Dance, if dest is current dir, we'll find the old css before the new one!
	my @csssources = map(pathname_canonical($_),
			     pathname_findall($css,types=>['css'],
					      (),
					      installation_subdir=>'style'));
	my $csspath = pathname_absolute($css,pathname_directory($postdest));
	while(@csssources && ($csssources[0] eq $csspath)){ shift(@csssources); }
	my $csssource = shift(@csssources);
	pathname_copy($csssource,$csspath)  if $csssource && -f $csssource;
	push(@csspaths,$csspath); }
    push(@procs,LaTeXML::Post::XSLT->new(stylesheet=>$stylesheet,
					 css=>[@csspaths],
					 parameters=>{number_sections
						      =>("true()")
						     },
					 %PostOPS))
    unless ($extract eq "math" || !$postdest);
    push(@procs,LaTeXML::Post::Writer->new(format=>"xhtml",omit_doctype=>0,%PostOPS))
     unless ($extract eq "math");
    my $postdoc;
    eval { ($postdoc) = LaTeXML::Post::ProcessChain($doc,@procs); };
    if ($@) { #Fatal occured!
	#Since this is postprocessing, we don't need to do anything
	#   just avoid crashing...
	print STDERR "$@\n";
    }
    elsif ($extract eq "math") {
	outputXML($postdoc->findnode('//m:math'),$postdest||"-");
    }
}

sub outputXML {
  my($xml,$destination)=@_;
  # Need to move the node to a new document to set up namespaces
  my $newdoc = XML::LibXML::Document->new("1.0","UTF-8");
  $newdoc->setDocumentElement($xml);
  my $serialized = $newdoc->toString(1);
  undef $newdoc;
  if ($destination eq '-') {
      print $serialized; 
  }
  else {
      open(OUT,">$destination");
      print OUT $serialized;
      close OUT;
  }
}

sub mathdoc {
#======================================================================
# TeX Source
#======================================================================
# First read and digest whatever we're given.
    my ($tex) = @_;
# We need to determine whether the TeX we're given needs to be wrapped in \[...\]
# Does it have $'s around it? Does it have a display math environment?
# The most elegant way would be to notice as soon as we start adding to the doc
# and switch to math mode if necessary, but that's tricky.
# Let's just try a manual hack, looking for known switches...
our $MATHENVS = 'math|displaymath|equation*?|eqnarray*?'
  .'|multline*?|align*?|falign*?|alignat*?|xalignat*?|xxalignat*?|gather*?';

if(($tex =~ /^\$/) && ($tex =~ /\$$/)){} # Wrapped in $'s
elsif(($tex =~ /^\\\(/) && ($tex =~ /\\\)$/)){} # Wrapped in \(...\)
elsif(($tex =~ /^\\\[/) && ($tex =~ /\\\]$/)){} # Wrapped in \[...\]
elsif(($tex =~ /^\\begin\{($MATHENVS)\}/) && ($tex =~ /\\end\{$1\}$/)){}
else {
  $tex = '\[ '.$tex.' \]'; }

my $texdoc = <<EODoc;
\\begin{document}
\\newcounter{equation}
\\newcounter{Unequation}
$tex
\\end{document}
EODoc
$texdoc;
}

#**********************************************************************
__END__

=head1 NAME

C<latexml> - transforms a TeX/LaTeX file into XML.

=head1 SYNOPSIS

latexml [options] I<texfile>

 Options:
 --destination=file specifies destination file (fault stdout).
 --output=file      [obsolete synonym for --destination]
 --preload=module   requests loading of an optional module;
                    can be repeated
 --includestyles    allows latexml to load raw *.sty file;
                    by default it avoids this.
 --path=dir         adds dir to the paths searched for files,
                    modules, etc; 
 --log=file         specifies log file (default: STDERR)
 --documentid=id    assign an id to the document root.
 --quiet            suppress messages (can repeat)
 --verbose          more informative output (can repeat)
 --strict           makes latexml less forgiving of errors
 --bibtex           processes the file as a BibTeX bibliography.
 --xml              requests xml output (default).
 --tex              requests TeX output after expansion.
 --box              requests box output after expansion
                    and digestion.
 --noparse          suppresses parsing math (default: off)
 --mode             standard|math|fragment parsing mode
                    default: fragment
 --post             requests a followup postprocessing
 --stylesheet       specifies a stylesheet,
                    to be used by the postprocessor.
 --nocomments       omit comments from the output
 --inputencoding=enc specify the input encoding.
 --VERSION          show version number.
 --debug=package    enables debugging output for the named
                    package
 --help             shows this help message.

If I<texfile> is '-', latexml reads the TeX source from standard input.
If I<texfile> has an explicit extention of C<.bib>, it is processed
as a BibTeX bibliography.

=head1 OPTIONS AND ARGUMENTS

=over 4

=item C<--destination>=I<file>

Specifies the destination file; by default the XML is written to stdout.
The Daemon allows using the #name, #dir and #ext patterns as variables for
the base of the source filename, the source directory and the source file extension.
An example would be: --destination=#dir/#name.xml

=item C<--preload>=I<module>

Requests the loading of an optional module or package.  This may be useful if the TeX code
does not specificly require the module (eg. through input or usepackage).
For example, use C<--preload=LaTeX.pool> to force LaTeX mode.

=item C<--includestyles>

This optional allows processing of style files (files with extensions C<sty>,
C<cls>, C<clo>, C<cnf>).  By default, these files are ignored  unless a latexml
implementation of them is found (with an extension of C<ltxml>).

These style files generally fall into two classes:  Those
that merely affect document style are ignorable in the XML.
Others define new markup and document structure, often using
deeper LaTeX macros to achieve their ends.  Although the omission
will lead to other errors (missing macro definitions), it is
unlikely that processing the TeX code in the style file will
lead to a correct document.

=item C<--path>=I<dir>

Add I<dir> to the search paths used when searching for files, modules, style files, etc;
somewhat like TEXINPUTS.  This option can be repeated.

=item C<--log>=I<file>

Specifies the log file; be default any conversion messages are printed to stderr.
The Daemon allows using the #name, #dir and #ext patterns as variables for
the base of the source filename, the source directory and the source file extension.
An example would be: --log=#dir/#name.log

=item C<--documentid>=I<id>

Assigns an ID to the root element of the XML document.  This ID is generally
inherited as the prefix of ID's on all other elements within the document.
This is useful when constructing a site of multiple documents so that
all nodes have unique IDs.

=item C<--quiet>

Reduces the verbosity of output during processing, used twice is pretty silent.

=item C<--verbose>

Increases the verbosity of output during processing, used twice is pretty chatty.
Can be useful for getting more details when errors occur.

=item C<--strict>

Specifies a strict processing mode. By default, undefined control sequences and
invalid document constructs (that violate the DTD) give warning messages, but attempt
to continue processing.  Using --strict makes them generate fatal errors.

=item C<--bibtex>

Forces latexml to treat the file as a BibTeX bibliography.
Note that the timing is slightly different than the usual
case with BibTeX and LaTeX.  In the latter case, BibTeX simply
selects and formats a subset of the bibliographic entries; the
actual TeX expansion is carried out when the result is included
in a LaTeX document.  In contrast, latexml processes and expands
the entire bibliography; the selection of entries is done
during postprocessing.  This also means that any packages
that define macros used in the bibliography must be
specified using the C<--preload> option.

=item C<--xml>

Requests XML output; this is the default.

=item C<--tex>

Requests TeX output for debugging purposes;  processing is only carried out through expansion and digestion.
This may not be quite valid TeX, since Unicode may be introduced.

=item C<--box>

Requests Box output for debugging purposes;  processing is carried out through expansion and digestions,
and the result is printed.

=item C<--mode>

fragment: Default, parses \begin{document}...\end{document} fragments.
          Assumes frontmatter is fixed, which achieves a big speedup since
          no state reinitialization is necessary.
standard: Turns on the classic, unoptimized processing of documents as performed by latexml.
          This is suitable for processing sets of heterogeneous documents, but is slower in general.
math:     Like latexmlmath, parses a single TeX formula per line.

=item C<--post>

Request postprocessing of converted XML to XHTML. Currently we force parallel presentation and
content MathML and no further customization is allowed. Future versions will be more flexible.
However, the user can still specify a custom stylesheet via --stylesheet

=item C<--stylesheet>=I<file>

Sets a stylesheet of choice to be used by the postprocessor.

=item C<--nocomments>

Normally latexml preserves comments from the source file, and adds a comment every 25 lines as
an aid in tracking the source.  The option --nocomments discards such comments.

=item C<--inputencoding=>I<encoding>

Specify the input encoding, eg. C<--inputencoding=iso-8859-1>.
The encoding must be one known to Perl's Encode package.
Note that this only enables the translation of the input bytes to
UTF-8 used internally by LaTeXML, but does not affect catcodes.
In such cases, you should be using the inputenc package.
Note also that this does not affect the output encoding, which is
always UTF-8.

=item C<--VERSION>

Shows the version number of the LaTeXML package..

=item C<--debug>=I<package>

Enables debugging output for the named package. The package is given without the leading LaTeXML::.

=item C<--help>

Shows this help message.

=back

=head1 SEE ALSO

L<latexml>, L<latexmlpost>, L<latexmlmath>, L<LaTeXML>

=cut
#**********************************************************************

