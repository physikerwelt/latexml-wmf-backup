#!/usr/bin/perl -w

#######################
# A Server for LaTeXML
#######################

eval 'exec /usr/bin/perl -w -S $0 ${1+"$@"}'
    if 0; # not running under some shell

# General packages
use strict;
use warnings;
use Pod::Usage;
# LaTeXML
use FindBin;
my $RealBin_safe;
BEGIN {
  $FindBin::RealBin =~ /^([^\0]+)\z/; # Valid Unix path TODO: Windows, revisit regexp
  $RealBin_safe = $1;
  die 'Fatal:IO:tainted RealBin was tainted! Failing...' unless ($RealBin_safe && (-e $RealBin_safe.'/latexmlc'));
}
# TODO: We probably want file cat for things like /../lib instead of spelling out a Unix path
use lib $RealBin_safe."/../lib";
use JSON::XS qw(encode_json decode_json);
use LaTeXML;
use LaTeXML::Version;
use LaTeXML::Converter;
use LaTeXML::Util::Config;
# Server-specific
use POSIX qw( setsid );
use IO::Socket;

#**********************************************************************

# Bookkeeping
my $ARGV_SAVED = [@ARGV], #Save, so that we reinvoke when flushed

# Global Options, with defaults
my $g_opts = LaTeXML::Util::Config->new(
 profile => 'standard',
 input_limit => 100,
 input_counter => 0,
 timeout => 60,
 port => 3354
);

my $opts=LaTeXML::Util::Config->new();

# Read default options
$g_opts->read(\@ARGV);

# Daemonize
daemonize();
#**********************************************************************
# Set up the server
my $server = setup_server($g_opts->get('port'));

#**********************************************************************
# Set up the processing.

# Install signal-handlers
local $SIG{'ALRM'} = 'timeout_handler';
local $SIG{'TERM'} = 'term_handler';
local $SIG{'INT'} = 'term_handler';

binmode(STDERR,":encoding(UTF-8)");

alarm($g_opts->get('timeout'));              #Timeout if inactive for too long...

#**********************************************************************
# Process files on demand:
while ( my $client = $server->accept() ) {
  my $request = q{};
  my $sockstart=1;
  # TODO: Enforce some maximum size to prevent DDoS via huge messages.
  #       Alternatively, leave open only to localhost.
  while (my $line = <$client>) {
      last if ($line =~ /^(\s*)END REQUEST(\s*)$/);
      chomp $line;
      $request .= $line."\n";
  }
  next unless ((defined $request) && (length( $request ) > 0));
  
  # Bookkeeping...
  alarm(0);                    # We are processing, ignore timeout here

  # Thaw request into options:
  $opts = LaTeXML::Util::Config->new(%{decode_json($request)});
  # Local if peerhost is localhost:
  $opts->{local} = ($client->peerhost eq '127.0.0.1');
  $opts->set('source',$opts->get('tex')) if (!($opts->get('source')) && $opts->get('tex'));
  $opts->delete('tex');
  # Prepare TeX source
  my $source = $opts->get('source');
  $opts->delete('source');

  if ($opts->get('base') && $opts->get('base')!~/(\w+):\/\//)
  { chdir $opts->get('base')
     or croak("Fatal:server:chdir Can't chdir to ".$opts->get('base').": $!"); }

  # We now have a LaTeXML options object - $opts.
  # Make sure the g_opts are included as defaults
  foreach ($g_opts->keys) {
    $opts->set($_, $g_opts->get($_)) unless $opts->exists($_); 
  }
  # Print to regular STDERR if debugging is requested
  *STDERR = *STDERR_SAVED if ($LaTeXML::Converter::DEBUG);

  # Boot/find a daemon:
  my $converter = LaTeXML::Converter->get_converter($opts);
  #Override/extend with session-specific options in $opt:
  $converter->prepare_session($opts);
  
  #Send a request:
  $g_opts->set('input_counter',$g_opts->get('input_counter')+1);
  my $response = $converter->convert($source);
  my ($result, $status, $log);
  if (defined $response) {
    ($result, $status, $log) = map { $response->{$_} } qw(result status log);
  }

  # Delete daemon if Fatal occurred
  undef $converter unless defined $result;

  # Send back the serialized XML, log and status:
  print $client encode_json($response);

  #Flush daemon, every $input_limit files:
  if ($g_opts->get('input_limit') && 
      (($g_opts->get('input_counter')||0) >= $g_opts->get('input_limit'))) {
    exec("$RealBin_safe/latexmls",@$ARGV_SAVED)
      or croak("Fatal:server:restart Daemon autoflush Failed!");
  }
  timeout_handler() if ($opts->get('timeout') == -1); # Terminate immediately if desired
  alarm($opts->get('timeout'));              #Timeout if inactive for too long...
}

sub timeout_handler {
  print STDERR "Daemon timed out after inactivity.\n";
  print STDERR "Self destructing...\n";
  kill 'TERM', $$;
  return;
}

sub term_handler {
  print STDERR "Exiting...\n";
  exit;
}

# TODO: Think about if the croaks can't be done better, so that the client
#       receives the error/log message? or is that overkill?
sub daemonize {
  #This causes more problems than it solves (e.g. sTeX setup)
  #chdir '/'                 or croak "Can't chdir to /: $!";
  open STDIN, '<', '/dev/null' 
    or croak("Fatal:server:daemonize  Can't read /dev/null: $!");
  open STDOUT, '>', '/dev/null'
    or croak("Fatal:server:daemonize  Can't write to /dev/null: $!");
  defined(my $pid = fork)
    or croak("Fatal:server:daemonize  Can't fork: $!");
  exit if $pid;
  setsid
    or croak("Fatal:server:daemonize  Can't start a new session: $!");
  *STDERR_SAVED = *STDERR;
  *STDERR = *STDOUT
    or croak("Fatal:server:daemonize Can't dup stdout: $!");
  return;
}

sub setup_server {
  my $localport = shift;
  my $sock_server = IO::Socket::INET->new(
        'Proto'     => 'tcp',
        'LocalPort' => $localport,
        'Listen'    => SOMAXCONN,
        'Reuse'     => 1,
    );
  croak("Fatal:server:init can't setup server") unless $sock_server;
  return $sock_server;
}

sub croak {
 print STDERR $_,"\n";
 exit 1;
}

#**********************************************************************
__END__

=pod

=head1 NAME

C<latexmls> - A server for latexml, latexmlpost and latexmlmath.
Remains initialized in memory until an inactivity timeout occurs.

=head1 SYNOPSYS

See the OPTIONS section in L<LaTeXML::Util::Config> for usage information.
Also consult latexmls --help

=head1 SEE ALSO

L<latexmlc>, L<ltxmojo>, L<LaTeXML::Util::Config>

=cut
#**********************************************************************
