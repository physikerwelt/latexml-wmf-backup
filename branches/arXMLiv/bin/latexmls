#!/usr/bin/perl -w

#######################
# A Server for LaTeXML
#######################

eval 'exec /usr/bin/perl -w -S $0 ${1+"$@"}'
    if 0; # not running under some shell
use strict;
use warnings;
use FindBin;
use lib "$FindBin::RealBin/../lib";
use Getopt::Long qw(GetOptionsFromString :config no_ignore_case);
use Pod::Usage;
use LaTeXML::Daemon;
use LaTeXML::Util::Pathname;
use LaTeXML::Util::ObjectDB;
use LaTeXML::Util::WWW;
use LaTeXML::Post;
use LaTeXML::Post::Writer;
use LaTeXML::Post::Scan;

use Carp;
use Clone qw(clone);
use POSIX qw( setsid );
use LWP::Simple;
use LWP;
use IO::Socket;
use IO::Prompt; #Authorization
our $authlist={};

#**********************************************************************
# Parse command line
my @ARGV_SAVED = @ARGV; #Save, so that we reinvoke when flushed
my $identity = "latexmls (LaTeXML version $LaTeXML::VERSION)";
#Since we allow runtime customization, we need two sets of the same
# switch variables:
#GLOBAL VARS
my($_verbosity,$_strict,$_comments,$_noparse,$_includestyles,
   $_errlog,$_post,$_parallelmath,$input_counter,$_input_limit,
   $_local,$_embed)=(0,0,1,0,0,0,0,0,0,0,0,0);
my $_timeout = 60;
my ($_format,$_mode,$_destination,$_postdest,$_log,$_postlog,$_base,$_procs_post,$_help,$_showversion,$_preamble,$_preamble_loaded)=
   ('xml','standard',q{},q{},q{},q{},q{},{},undef,undef,undef,q{});
my($_stylesheet,$_defaultcss,$_summary,$_icon,@_css)=(undef,1,0);
my ($_documentid);
my $_inputencoding;
my $_type = 'auto';
my @paths_ = (q{.});
my (@preload_,@debugs_);

#LOCAL VARS
my($verbosity,$strict,$comments,$noparse,$includestyles,
   $errlog,$post,$parallelmath,$input_limit,
   $timeout,$local)=
  ($_verbosity,$_strict,$_comments,$_noparse,$_includestyles,
   $_errlog,$_post,$_parallelmath,$_input_limit,
   $_timeout,$_local);
my ($format,$mode,$destination,$postdest,$log,$postlog,$base,$procs_post,$help,$showversion,$preamble,$embed)=
  ($_format,$_mode,$_destination,$_postdest,$_log,$_postlog,$_base,{},$_help,$_showversion,$_preamble,$_embed);
my($stylesheet,$defaultcss,$summary,$icon,@css)=($_stylesheet,$_defaultcss,$_summary,$_icon,@_css);
my ($documentid,$port);
my %portlist = ( math=>3334, fragment=>3344, standard=>3354);
my $inputencoding;
my $type = $_type;
my @paths = @paths_;
my (@preload,@debugs);

#Read global variables
GetOptions("destination=s" => \$_destination,
           "postdest=s" => \$_postdest,
	   "output=s"  => \$_destination,
	   "preload=s" => \@preload_,
	   "preamble=s" => \$_preamble,
           "base=s"  => \$_base,
	   "path=s"    => \@paths_,
	   "quiet"     => sub { $_verbosity--; },
	   "verbose"   => sub { $_verbosity++; },
	   "strict"    => \$_strict,
	   "xml"       => sub { $_format = 'xml'; },
	   "tex"       => sub { $_format = 'tex'; },
	   "box"       => sub { $_format = 'box'; },
	   "bibtex"    => sub { $_type='bibtex'; },
	   "noparse"   => \$_noparse,
	   "mode=s"  => \$_mode,
           "embed"   => \$_embed,
	   "autoflush=s" => \$_input_limit,
           "timeout=s"   => \$_timeout,
           "port=s"      => \$port,
           "local!"       => \$_local,
	   "log=s"       => \$_log,
           "postlog=s"   => \$_postlog,
           "summary!"    => \$_summary,
	   "includestyles"=> \$_includestyles,
	   "inputencoding=s"=>\$_inputencoding,
	   "post"      => \$_post,
	   "pmml"      => sub {$_procs_post->{'pmml'}=1;},
	   "cmml"      => sub {$_procs_post->{'cmml'}=1;},
	   "openmath"  => sub {$_procs_post->{'openmath'}=1;},
	   "keepTeX"   => sub {$_procs_post->{'keepTeX'}=1;},
	   "keepXMath" => sub {$_procs_post->{'keepXMath'}=1;},
	   "parallelmath" => \$_parallelmath,
	   "stylesheet=s"=>\$_stylesheet,
	   "css=s"                 =>\@css,
	   "defaultcss!"           =>\$defaultcss,
	   "comments!" => \$_comments,
	   "VERSION"   => \$_showversion,
	   "debug=s"   => sub { eval "\$LaTeXML::$_[1]::DEBUG=1; "; },
	   "documentid=s" => \$_documentid,
	   "help"      => \$_help,
	  ) or pod2usage(-message => $identity, -exitval=>1, -verbose=>0, -output=>\*STDERR);
pod2usage(-message=>$identity, -exitval=>1, -verbose=>2, -output=>\*STDOUT) if $_help;
if (!$_local && ($_destination || $_log || $_postdest || $_postlog)) {carp "I/O from filesystem not allowed without --local!\n".
                                          " Will revert to sockets!\n";
                                         undef $_destination; undef $_log;
                                         undef $_postdest; undef $_postlog;}
# HOWEVER, any post switch implies post:
$_post=1 if (keys %$_procs_post);

if($_showversion){ print STDERR "$identity\n"; exit(1); }

#**********************************************************************
#Set up the server
$port = $portlist{$_mode} unless $port;
my $server = setup_server($port);

#**********************************************************************
# Set up the processing.
print STDERR "$identity\n" if $verbosity >= 0;
$_mode = lc($_mode);
$_input_limit=5000
  if (($_mode eq "math") && (!$_input_limit || $_input_limit<1)); #if not set and math mode or if value not admissible
$_input_limit=1000 if (($_mode eq "fragment") && (!$_input_limit || $_input_limit<=0)); #Fragment mode
$_input_limit=100 if (!$_input_limit || $_input_limit<=0); #Standard mode

#Setup LOCAL VARS
($verbosity,$strict,$comments,$noparse,$includestyles,
 $errlog,$post,$parallelmath,$input_limit,$timeout,$local)=
  ($_verbosity,$_strict,$_comments,$_noparse,$_includestyles,
   $_errlog,$_post,$_parallelmath,$_input_limit,$_timeout,$_local);
($format,$mode,$destination,$postdest,$log,$postlog,$base,$help,$showversion,$preamble,$documentid,$inputencoding,$type)=
        ($_format,$_mode,$_destination,$_postdest,$_log,$_postlog,$_base,$_help,$_showversion,$_preamble,$_documentid,$_inputencoding,$_type);
($stylesheet,$defaultcss,$summary,$icon,@css)=($_stylesheet,$_defaultcss,$_summary,$_icon,@_css);
$procs_post = {};
$embed=$_embed;
#When in math mode, preload math packages:
if ($mode eq "math") {
    my  @mathpreload = ("LaTeX.pool", "article.cls", "amsmath.sty", "amsthm.sty", "amstext.sty", "amssymb.sty", "eucal.sty");
    @preload_=(@preload_,@mathpreload);
}
@paths = @paths_; @preload=@preload_; @debugs=@debugs_;

#Setup HTTP::Response var for URI requests
my $response;

@paths = map {pathname_canonical($_)} @paths;
my $latexml= LaTeXML::Daemon->new(preload=>[@preload], searchpaths=>[@paths],
			  verbosity=>$verbosity, strict=>$strict,
			  includeComments=>$comments,inputencoding=>$inputencoding,
			  includeStyles=>$includestyles,
			  documentid=>$documentid,
			  nomathparse=>$noparse);
if(my @baddirs = grep {! -d $_} @paths){
    warn "$identity: these path directories do not exist: ".join(', ',@baddirs)."\n"; }
binmode(STDERR,":utf8");

# install signal-handlers
local $SIG{'ALRM'} = 'dotimeout';
local $SIG{'TERM'} = 'doterm';
local $SIG{'INT'} = 'doterm';

#Initialize state:
$latexml->withState(sub {
  my($state)=@_;
  $latexml->initializeState('TeX.pool', @{$$latexml{preload} || []});
});
print STDERR "\n"; #Sanitize log.
# Preload the preamble if any (and not loaded)
if ($preamble) {
  #TODO: It is difficult to digest 2 files via LaTeXML into 1 XML output right now...
  $response=auth_get($preamble,$authlist);
  if ($response->is_success) {
    my $content = $response->content;
    $latexml->digestStringDaemonized($content,"standard",$preamble);
  } else {
    $latexml->digestFileDaemonized($preamble,"standard");
  }
  $_preamble_loaded = $preamble;
}

#Setting up Daemon
my $init_status = $latexml->getStatusMessage;
print STDERR "\n"; #Flush log
if ($init_status !~ /error/i) {
  daemonize();
} else {  croak $init_status; } #Demand errorless initialization

#Create restore point
my $stateRestore;
$latexml->withState(sub {
  my($state)=@_;
  $state->assignValue('_authlist',$authlist,'global');
});

#Flush daemon, every $input_limit files:
exec($0,@ARGV_SAVED) 
  or die ("Daemon autoflush Failed!\n") if $input_counter>=$input_limit;
#Set timeout, if wanted:
alarm($timeout);              #Timeout if inactive for too long...
print STDERR "\n\nInitialization complete...\n";
#**********************************************************************
# Daemon has been set up, now process files on demand:grep($_ !~ /^--/,
while ( my $client = $server->accept() ) {
  my $source = q{};
  my $sockstart=1;
  #Accept customizations for each input:
  #Setup LOCAL VARS
  ($verbosity,$strict,$comments,$noparse,$includestyles,
   $errlog,$post,$parallelmath,$input_limit,
   $timeout,$local)=
     ($_verbosity,$_strict,$_comments,$_noparse,$_includestyles,
      $_errlog,$_post,$_parallelmath,$_input_limit,
      $_timeout,$_local);
  ($format,$mode,$destination,$postdest,$log,$postlog,$base,$help,$showversion,$preamble,$documentid,$inputencoding,$type)=
    ($_format,$_mode,$_destination,$_postdest,$_log,$_postlog,$_base,$_help,$_showversion,$_preamble,$_documentid,$_inputencoding,$_type);
  ($stylesheet,$defaultcss,$summary,$icon,@css)=($_stylesheet,$_defaultcss,$summary,$_icon,@_css);
  $procs_post = {};
  @paths = @paths_; @preload=@preload_; @debugs=@debugs_;
  while (my $line = <$client>) {
    chomp $line if $line; #We don't need the trailing empty line
    $sockstart=0 unless $line=~/^--/;#Assume no options will be given if the line does not start with --
    if ($sockstart) {
      #Parse overwrites from current input:
      my ($ret,$args) = GetOptionsFromString($line,
           "destination=s" => \$destination,
	   "output=s"  => \$destination,
           "postdest=s" => \$postdest,
	   "preload=s" => \@preload,
	   "preamble=s" => \$preamble,
           "base=s" => \$base,
	   "path=s"    => \@paths,
	   "quiet"     => sub { $verbosity--; },
	   "verbose"   => sub { $verbosity++; },
	   "strict"    => \$strict,
	   "xml"       => sub { $format = 'xml'; },
	   "tex"       => sub { $format = 'tex'; },
	   "box"       => sub { $format = 'box'; },
	   "bibtex"    => sub { $type='bibtex'; },
	   "noparse"   => \$noparse,
	   "mode=s"  => sub {return;},#Ignore mode switch in runtime for now TODO: FIXME
           "embed"   => \$embed,
	   "autoflush=s" => \$input_limit,
           "timeout=s"   => \$timeout,
           "port=s"      => \$port,
           "local!"       => sub {carp "Local only possible to set on first server invocation!\n";},
	   "log=s"       => \$log,
           "postlog=s"   => \$postlog,
           "summary!"    => \$summary,
	   "includestyles"=> \$includestyles,
	   "inputencoding=s"=>\$inputencoding,
	   "post"      => \$post,
	   "pmml"      => sub {$$procs_post{'pmml'}=1;},
	   "cmml"      => sub {$$procs_post{'cmml'}=1;},
	   "openmath"  => sub {$$procs_post{'openmath'}=1;},
	   "keepTeX"   => sub {$$procs_post{'keepTeX'}=1;},
	   "keepXMath" => sub {$$procs_post{'keepXMath'}=1;},
	   "parallelmath" => \$parallelmath,
	   "stylesheet=s"=>\$stylesheet,
	   "css=s"                 =>\@css,
	   "defaultcss!"           =>\$defaultcss,
	   "comments!" => \$comments,
	   "VERSION"   => \$showversion,
	   "debug=s"   => sub { eval "\$LaTeXML::$_[1]::DEBUG=1; "; },
	   "documentid=s" => \$documentid,
	   "help"      => \$help,
      );
      pod2usage(-message=>$identity, -exitval=>1, -verbose=>2, -output=>\*STDOUT) if $help;
      if ($base && $base!~/(\w+):\/\//) { chdir "$base" or croak "Can't chdir to $base: $!";};
      if (!$local && ($destination || $log || $postdest || $postlog)) {carp "I/O from filesystem not allowed without --local!\n".
                                                " Will revert to sockets!\n";
                                            undef $destination; undef $log;
                                            undef $postdest; undef $postlog; }
      $source.=join(" ", grep {$_ !~ /^--/} @$args);
      $sockstart=0; next;
    }
    last if ($line =~ /^(\s*)END REQUEST(\s*)$/);
    $source .= $line if $line;
  }
  next unless $source;
  #Bookkeeping...
  alarm(0);                    #We are processing, ignore timeout here
  $input_counter++;
  chomp $source;
  $source =~ s/^\s+//m;                     #Cleanup space
  $source =~ s/\s+$//m;                     #Cleanup space
  next if (!$source);
  # Determine input type if local, otherwise only socket exchange:
  my ($isURL,$isString,$isFile);
  if ($local) {
    my @source_lines = split(/\n/,$source);
    $isString = $source if (scalar(@source_lines)>1 || $mode eq "math");
    unless ($isString) {
      $isFile = pathname_find($source,types=>['tex',q{}]);
      $isFile = pathname_canonical($isFile);
      $source = $isFile if $isFile;
      unless($isFile) {
        $response = auth_get($source,$authlist);
        $isURL = $response->is_success;
      }
    }
    $isString = $source unless ($isFile || $isURL); #Not file or URL - then process as string
  } else { $isString=$source; }
  if (!$local && ($isFile)) {carp "I/O from filesystem not allowed without --local!\n".
                                                " Will revert to sockets!\n";}
  #Math mode means post
  #(TODO: Rethink this, maybe we want more flexibility e.g. noparse XMath)
  #$post=1 if ($mode eq "math");
  # HOWEVER, any post switch implies post:
  $post=1 if (keys %$procs_post);
  #Instantiate targets for current input
  my ($dir,$name,$ext);
  ($dir,$name,$ext) = pathname_split($source) if $isFile;
  #Redirect to logfile, if requested:
  my ($clog);
  if ($log && $local) {
    $clog = $log;
    $clog=~s/#name/$name/eg;
    $clog=~s/#dir/$dir/eg;
    $clog=~s/#ext/$ext/eg;
    open(LOG,">",$clog) or croak "Couldn't open log file $clog : $!\n";
    *ERRORIG=*STDERR;
    *STDERR = *LOG;
  } else {
    #No log if not local (STDERR redirects to /dev/null)
  }
  my $cdest;
  if ($destination && $local) {
    $cdest = $destination;
    $cdest =~ s/#name/$name/eg;
    $cdest =~ s/#dir/$dir/eg;
    $cdest =~ s/#ext/$ext/eg;
  } else { #Output to client
    $cdest = $client;
  }
  my $cdestpost;
  if ($postdest && $local) {
    $cdestpost = $postdest;
    $cdestpost =~ s/#name/$name/eg;
    $cdestpost =~ s/#dir/$dir/eg;
    $cdestpost =~ s/#ext/$ext/eg;
  } else { #Output to $cdest!
    $cdestpost = $cdest;
    $cdestpost.=".xhtml" unless
      (!$cdestpost || ($cdestpost eq $client) || $cdestpost=~/\.xhtml$/ || 
       $cdestpost=~s/\.tex\.xml$/.xhtml/ || $cdestpost=~s/\.xml$/.xhtml/); #Some heuristics
  }
  $cdestpost = undef unless $post;
  my $deststat = (stat($cdest))[9] if ($summary && $cdest && ($cdest ne $client));
  my $destpoststat = (stat($cdestpost))[9] if ($summary && $cdestpost && ($cdestpost ne $client));

  ###########################################################################
  #   Start of conversion
  #

  $type = 'bibtex' if ($type eq 'auto') && ($source =~ /\.bib$/);
  # ========================================
  # First read and digest whatever we're given.
  my $digested;
  if ($mode eq "standard") {
    #In the classic case, we need to reinitialize latexml
    # on every input
    undef $latexml;
    $latexml= LaTeXML::Daemon->new(preload=>[@preload], searchpaths=>[@paths],
                           verbosity=>$verbosity, strict=>$strict,
                           includeComments=>$comments,inputencoding=>$inputencoding,
                           includeStyles=>$includestyles,
                           documentid=>$documentid,
                           nomathparse=>$noparse);
    $latexml->withState(sub {
                          my($state)=@_;
                          $latexml->initializeState('TeX.pool', @{$$latexml{preload} || []});
                        });
    # Preload the preamble if any (and not loaded)
    if ($_preamble) {
      #TODO: It is difficult to digest 2 files via LaTeXML into 1 XML output right now...
      $response=auth_get($_preamble,$authlist);
      if ($response->is_success) {
        my $content = $response->content;
        $latexml->digestStringDaemonized($content,"standard",$preamble);
      } else {
        $latexml->digestFileDaemonized($preamble,"standard");
      }
    }
    print STDERR "\n";          #Again, flush log
  } # End of standard use case

  # Preload the preamble if any (and not loaded)
  if ($preamble && ($preamble ne $_preamble_loaded)) {
    #TODO: It is difficult to digest 2 preamble files via LaTeXML right now...
    $response=auth_get($preamble,$authlist);
    if ($response->is_success) {
      $latexml->digestStringDaemonized($response->content,"standard",$preamble);
    } else {
      $latexml->digestFileDaemonized($preamble,"standard");
    }
  }

  $latexml->withState(sub {
                        my($state)=@_; #Sandbox state
                        #Save preamble information for further use:
                        $state->assignValue('_preamble_loaded',$preamble,'global');
                        $state->assignValue('_authlist',$authlist,'global');
                        $state->pushDaemonFrame; });
  my $serialized;
  my $dom;
  eval {
    if ($isURL) {
      $digested = $latexml->digestStringDaemonized($response->content,$mode,$source);
    } elsif ($isFile) {
      if ($type eq 'bibtex') {
        #TODO: Do we want URL support here?
        $digested = $latexml->digestBibTeXFileDaemonized($source,$mode);
      } else {
        $digested = $latexml->digestFileDaemonized($source,$mode); 
      }}
    elsif ($isString) {
      $source = mathdoc($source) if ($mode eq "math");
      $digested = $latexml->digestStringDaemonized($source,$mode);
    }
    # ========================================
    # Now, convert to DOM and output, if desired.
    if ($digested) {
      local $LaTeXML::Global::STATE = $$latexml{state};
      if ($format eq 'tex') {
        $serialized = LaTeXML::Global::UnTeX($digested);
      } elsif ($format eq 'box') {
        $serialized = $digested->toString;
      } else {
        $dom = $latexml->convertDocument($digested); 
        $serialized = $dom->toString(1);
      }
    }
    1;
  } or do {                     #Fatal occured!
    print STDERR "$@\n";
    print STDERR "\nConversion complete: ".$latexml->getStatusMessage.".\n";
    doSummary($cdest,$cdestpost,$client,$deststat,$destpoststat,$latexml->getStatusMessage) if ($summary);
    #Need to reset latexml in these cases
    if ($log) {
      close(LOG); *STDERR = *ERRORIG;
    }                           #Close log file
    #Undef variables
    undef $latexml;
    undef $digested;
    undef $dom;
    undef $serialized;
    undef $source;
    #Init:
    $latexml= LaTeXML::Daemon->new(preload=>[@preload], searchpaths=>[@paths],
                           verbosity=>$verbosity, strict=>$strict,
                           includeComments=>$comments,inputencoding=>$inputencoding,
                           includeStyles=>$includestyles,
                           documentid=>$documentid,
                           nomathparse=>$noparse);
    $latexml->withState(sub {
                          my($state)=@_;
                          $latexml->initializeState('TeX.pool', @{$$latexml{preload} || []});
                        });
    # Preload the preamble if any
    if ($preamble && $mode eq "fragment") {
      #TODO: It is difficult to digest 2 files via LaTeXML into 1 XML output right now...
      $response=auth_get($preamble,$authlist);
      if ($response->is_success) {
        $latexml->digestStringDaemonized($response->content,"standard",$preamble);
      } else {
        $latexml->digestFileDaemonized($preamble,"standard");
      }
    }
    print STDERR "\n";          #Again, flush log
    #Move to next...
    exec($0,@ARGV_SAVED) 
      or die ("Daemon autoflush Failed!\n") if $input_counter>=$input_limit;
    alarm($timeout);              #Timeout if inactive for too long...
    next;                       #Move on, no body to be produced.
  };
  print STDERR "\nConversion complete: ".$latexml->getStatusMessage.".\n";
  my $summaryMessage = $latexml->getStatusMessage;
  $latexml->withState(sub {
                        my($state)=@_; #Remove current state frame
                        $state->popDaemonFrame;
                        $$state{status} = {};
                      });
  if ($cdest && $local && ($cdest ne $client)) {
    open(OUT,">",$cdest) or croak "Couldn't open output file $cdest: $!";
  } elsif ($cdest==$client) {
    *OUT = *$cdest;
  }
  else {
    #  binmode(STDOUT,":utf8");
    *OUT = *STDOUT;
  }

  %$procs_post=%$_procs_post unless (scalar(keys %$procs_post)); #Fall back to defaults if no preferences
  $$procs_post{'pmml'}=1 unless (scalar(keys %$procs_post)); #Fall back to pmml as default
  print OUT $serialized if ($serialized && (!$post || $cdest ne $client));
  if ($cdest && $local && ($cdest ne $client)) {
    close(OUT);
  }
  if ($log && $local) { #Close log file
    close(LOG); *STDERR = *ERRORIG;
  }

  if ($post && $dom && (!$noparse)) {
    #Postprocess
    my $clogpost;
    $postlog = $log unless $postlog;
    if ($postlog && $local) {
      $clogpost = $postlog;
      $clogpost=~s/#name/$name/eg;
      $clogpost=~s/#dir/$dir/eg;
      $clogpost=~s/#ext/$ext/eg;
      my $wmode = ">";
      $wmode = ">>" if (($clogpost eq $clog) && (-e $clog));
      open(PLOG,"$wmode",$clogpost) or croak "Couldn't open log file $clog : $!\n";
      *ERRORIG=*STDERR;
      *STDERR = *PLOG;
      if ($clog eq $clogpost) {
        print STDERR "---------\n";
        print STDERR "LaTeXML Post-processing: \n";
      }
    } else {
      #No log if not local (STDERR redirects to /dev/null)
    }
    doPost(dest=>$cdestpost,stylesheet=>$stylesheet,dom=>$dom,mode=>$mode,format=>$format,
           parallel=>$parallelmath,procs=>$procs_post,isStream=>($cdestpost eq $client),
           verbosity=>$verbosity,defaultcss=>$defaultcss,embed=>$embed);
    if ($postlog && $local) { #Close log file
      close(PLOG); *STDERR = *ERRORIG;
    }
  }
  doSummary($cdest,$cdestpost,$client,$deststat,$destpoststat,$summaryMessage) if ($summary);
  close $client;
  #Undef variables
  undef $latexml if $mode eq "standard";
  undef $digested;
  undef $dom;
  undef $serialized;
  undef $source;
  undef $clog;
  #Move to next...
  exec($0,@ARGV_SAVED) 
    or die ("Daemon autoflush Failed!\n") if $input_counter>=$input_limit;
  alarm($timeout);              #Timeout if inactive for too long...
}

#======================================================================
# Helpers
#======================================================================
sub doPost {
  my (%options)=@_;
  my ($postdest,$style,$dom,$extract,$parallel,$proctypes,$isStream,$format,$verbosity,$defaultcss,$embed)= 
    map {$options{$_}} qw(dest stylesheet dom mode parallel procs isStream format verbosity defaultcss embed);
  $verbosity = $verbosity||0;
  my %PostOPS = (verbosity=>$verbosity,siteDirectory=>".");
  #Postprocess
  #Default is XHTML, XML otherwise (TODO: Expand)
  $format="xml" if ($style);
  $format="xhtml" unless ($format eq "xml");
  $style = "LaTeXML-xhtml.xsl" unless $style;
  my @css=();
  unshift (@css,"core.css") if ($defaultcss && !($extract eq "math"));
  $parallel = $parallel||0;
  my $doc;
  eval {
    $doc = LaTeXML::Post::Document->newFromString($dom->toString(1),nocache=>1,destination=>$postdest); 
    1;}
    or do {                     #Fatal occured!
      #Since this is postprocessing, we don't need to do anything
      #   just avoid crashing... and exit
      undef $doc;
      print STDERR "FATAL: Post-processor crashed! $@\n";
      return;
    };
  require LaTeXML::Post::MathML;
  require LaTeXML::Post::OpenMath;
  require LaTeXML::Post::PurgeXMath;
  my @mprocs=();

  push (@mprocs, LaTeXML::Post::MathML::Presentation->new(%PostOPS)) if $$proctypes{'pmml'};
  push (@mprocs, LaTeXML::Post::MathML::Content->new(%PostOPS)) if $$proctypes{'cmml'};
  push (@mprocs, LaTeXML::Post::OpenMath->new(%PostOPS)) if $$proctypes{'openmath'};
  my $main = shift(@mprocs);
  $main->setParallel(@mprocs) if $parallel;
  $main->keepTeX if ($$proctypes{'keepTeX'} && $parallel);
  my @procs=();
  push(@procs,$main);
  push(@procs,@mprocs) unless $parallelmath;
  push(@procs, LaTeXML::Post::PurgeXMath->new(%PostOPS)) unless $$proctypes{'keepXMath'};
  require LaTeXML::Post::XSLT;
  my @csspaths=();
  if (@css) {
    foreach my $css (@css) {
      $css .= '.css' unless $css =~ /\.css$/;
      # Dance, if dest is current dir, we'll find the old css before the new one!
      my @csssources = map {pathname_canonical($_)}
                           pathname_findall($css,types=>['css'],
                                            (),
                                            installation_subdir=>'style');
      my $csspath = pathname_absolute($css,pathname_directory('.'));
      while (@csssources && ($csssources[0] eq $csspath)) {
        shift(@csssources);
      }
      my $csssource = shift(@csssources);
      pathname_copy($csssource,$csspath)  if $csssource && -f $csssource;
      push(@csspaths,$csspath);
    }}
  push(@procs,LaTeXML::Post::XSLT->new(stylesheet=>$style,
					 parameters=>{number_sections
						      =>("true()"),
                                                      (@csspaths ? (CSS=>[@csspaths]):()),},
                                       %PostOPS)) if $style;
  push(@procs,LaTeXML::Post::Writer->new(format=>$format,omit_doctype=>0,%PostOPS))
    if ($postdest && !$isStream);
  my $postdoc;
  eval { ($postdoc) = LaTeXML::Post::ProcessChain($doc,@procs); 1;}
  or do {                     #Fatal occured!
    #Since this is postprocessing, we don't need to do anything
    #   just avoid crashing... and exit
    undef $doc;
    undef $postdoc;
    foreach (@procs) {
      undef $_;
    }
    foreach (@mprocs) {
      undef $_;
    }
    undef @procs;
    undef @mprocs;
    print STDERR "FATAL: Post-processor crashed! $@\n";
    return;
  };
  # If we want an embedable snippet, unwrap to body's "main" div
  if ($embed && ($mode eq "fragment")) {
    my $bodyel = $postdoc->findnode('//*[local-name()="body"]');
    my $topdiv;
    # Doing monkey hoops is very annoying, why won't LibXML
    # just fix their XPath support already?!
    foreach ($bodyel->childNodes) {
      $topdiv=$_;
      last if ($topdiv->nodeName eq 'div');
    }
    my $contentdiv;
    foreach ($topdiv->childNodes) {
      $contentdiv=$_;
      last if ($contentdiv->nodeName eq 'div');
    }
    my $maindiv;
    foreach ($contentdiv->childNodes) {
      $maindiv=$_;
      last if ($maindiv->nodeName eq 'div');
    }
    # Assign the top division to the post-document holder
    # Copy over all <html> attributes to the maindiv, so that we keep namespaces:
    my $htmlel = $postdoc->findnode('//*[local-name()="html"]');
    $htmlel->unbindNode;
    $htmlel->removeChildNodes;
    $htmlel->setNodeName('div');
    $htmlel->setAttribute('class','document');
    $maindiv->unbindNode;
    foreach ($maindiv->childNodes) {
      $_->unbindNode;
      $htmlel->addChild($_);
    }
    $postdoc = $htmlel;
  }
  if ($extract eq "math") {
    #Output to destination:
    my $mnodes = $postdoc->findnodes('//m:math');
    if ($mnodes->size <= 1) {
      outputXML($postdoc->findnode('//m:math'),$postdest||q{-},$isStream);
    } else {
      my $ancestor = $postdoc->findnode('//m:math')->parentNode;
      $ancestor = $ancestor->parentNode while ($ancestor->findnodes('.//m:math')->size != $mnodes->size);
      outputXML($ancestor,$postdest||q{-},$isStream);
    }
  }
  elsif ($isStream) {
    #Client requested entire document returned via socket, hence send back serialized:
    my $serialized = $postdoc->toString(1);
    print $postdest $serialized;
  }
  undef $doc;
  undef $postdoc;
  foreach (@procs) { undef $_; }
  foreach (@mprocs) { undef $_; }
  undef @procs;
  undef @mprocs;
  undef %options;
  undef %PostOPS;
  return;
}

sub outputXML {
  my($xml,$destxml,$isStream)=@_;
  # Need to move the node to a new document to set up namespaces
  my $newdoc = XML::LibXML::Document->new("1.0","UTF-8");
  return unless ref $xml;
  $newdoc->setDocumentElement($xml->cloneNode(1));
  my $serialized = $newdoc->toString(1);
  if ($destxml eq q{-}) {
      print $serialized;
  }
  elsif ($isStream) {
    print $destxml $serialized;
  }
  else {
      open(OUT,">",$destxml) or croak "Couldn't open output file $destxml: $!";
      print OUT $serialized;
      close OUT;
  }
  undef $serialized; 
  undef $newdoc;
  return;
}

sub mathdoc {
#======================================================================
# TeX Source
#======================================================================
# First read and digest whatever we're given.
    my ($tex) = @_;
# We need to determine whether the TeX we're given needs to be wrapped in \[...\]
# Does it have $'s around it? Does it have a display math environment?
# The most elegant way would be to notice as soon as we start adding to the doc
# and switch to math mode if necessary, but that's tricky.
# Let's just try a manual hack, looking for known switches...
our $MATHENVS = 'math|displaymath|equation*?|eqnarray*?'
  .'|multline*?|align*?|falign*?|alignat*?|xalignat*?|xxalignat*?|gather*?';

if(($tex =~ /\A\$/m) && ($tex =~ /\$\z/m)){} # Wrapped in $'s
elsif(($tex =~ /\A\\\(/m) && ($tex =~ /\\\)\z/m)){} # Wrapped in \(...\)
elsif(($tex =~ /\A\\\[/m) && ($tex =~ /\\\]\z/m)){} # Wrapped in \[...\]
elsif(($tex =~ /\A\\begin\{($MATHENVS)\}/m) && ($tex =~ /\\end\{$1\}\z/m)){}
else {
  $tex = '\[ '.$tex.' \]'; }

my $texdoc = <<"EODOC";
\\begin{document}
\\newcounter{equation}
\\newcounter{Unequation}
$tex
\\end{document}
EODOC
return $texdoc;
}

sub dotimeout {
  print "Daemon timed out after inactivity.\n";
  print "Self destructing...\n";
  kill 'TERM', $$;
  return;
}

sub doterm {
  print STDERR "Exiting...\n";
  exit;
}

sub daemonize {
  #chdir '/'                 or croak "Can't chdir to /: $!";
  #This causes more problems than it solves (e.g. sTeX setup)
  open STDIN, '<', '/dev/null'   or croak "Can't read /dev/null: $!";
  open STDOUT, '>', '/dev/null' or croak "Can't write to /dev/null: $!";
  defined(my $pid = fork)   or croak "Can't fork: $!";
  exit if $pid;
  setsid                    or croak "Can't start a new session: $!";
  *STDERR = *STDOUT         or croak "Can't dup stdout: $!";
  return;
}

sub setup_server {
  my $localport = shift;
  my $sock_server = IO::Socket::INET->new(
        'Proto'     => 'tcp',
        'LocalPort' => $localport,
        'Listen'    => SOMAXCONN,
        'Reuse'     => 1,
    );
  croak "can't setup server" unless $sock_server;
  return $sock_server;
}

sub doSummary {
  my ($cdest,$cdestpost,$client,$deststat,$destpoststat,$summaryMessage)=@_;
  my $writesuccess = 0; 
  $writesuccess = 1 if ($cdest && ($cdest ne $client) && ($deststat != (stat($cdest))[9]));
  my $writesuccesspost = 0;
  $writesuccesspost = 1 if ($cdestpost && ($cdestpost ne $client) && ($destpoststat != (stat($cdestpost))[9]));
  print $client $summaryMessage."\n";
  if ($writesuccess && $cdest) {
    print $client "Wrote $cdest\n";
  } elsif ($cdest && ($cdest ne $client)) {
    print $client "Error! Did not write file $cdest\n";
    }
  if (($writesuccesspost) && $cdestpost && ($cdestpost ne $cdest)) {
    print $client "Wrote $cdestpost\n";
  } elsif ($cdestpost && ($cdestpost ne $client) && ($cdestpost ne $cdest)) {
    print $client "Error! Did not write file $cdestpost\n";
  }
}

#**********************************************************************
__END__

=head1 NAME

C<latexmls> - A server for latexml, latexmlpost and latexmlmath.
Remains initialized in memory until an inactivity timeout occurs.

=head1 SYNOPSIS

latexmls [options]

 Options:
 --destination=file specifies destination file, requires --local.
 --output=file      [obsolete synonym for --destination]
 --postdest=file    specifies destination file for postprocessing,
                    requires --local, --post
 --preload=module   requests loading of an optional module;
                    can be repeated
 --includestyles    allows latexml to load raw *.sty file;
                    by default it avoids this.
 --preamble=file    loads a tex file containing document frontmatter.
                    Useful for fragment mode.
 --base=dir         Specifies the base directory that the server
                    operates in. Useful when converting documents 
                    that employ relative paths.
 --path=dir         adds dir to the paths searched for files,
                    modules, etc; 
 --log=file         specifies log file, reuqires --local (default: STDERR)
 --postlog=file     specifies log file for postprocessing, 
                    requires --local, --post 
                    default is appending to the --log file.
 --summary          print a one line summary message of 
                    the conversion outcome
 --autoflush=count  Automatically restart the daemon after 
                    "count" inputs. Good practice for vast batch 
                    jobs. (default: 10000)
 --timeout=secs     Set a timeout value for inactivity.
                    Default is 60 seconds, set 0 to disable.
 --port=number      Specify server port (default: 3334 for math, 
                    3344 for fragment and 3354 for standard)
 --local            Request a local server (default: off)
                    Required for the --log and --destination switches
                    Required for processing filenames on input
 --documentid=id    assign an id to the document root.
 --quiet            suppress messages (can repeat)
 --verbose          more informative output (can repeat)
 --strict           makes latexml less forgiving of errors
 --bibtex           processes the file as a BibTeX bibliography.
 --xml              requests xml output (default).
 --tex              requests TeX output after expansion.
 --box              requests box output after expansion
                    and digestion.
 --noparse          suppresses parsing math (default: off)
 --mode=modename    Specify daemon parsing mode
                    Supported: standard|math|fragment
                    (default: standard)
 --post             requests a followup post-processing
 --embed            requests an embeddable XHTML div (= document body)
                    (requires: --post,--mode=fragment, socket destination)
 --stylesheet       specifies a stylesheet,
                    to be used by the post-processor.
 --css=cssfile           adds a css stylesheet to html/xhtml
                         (can be repeated)
 --nodefaultcss          disables the default css stylesheet
 --pmml             converts math to Presentation MathML
                    (default for xhtml format)
 --cmml             converts math to Content MathML
 --openmath         converts math to OpenMath 
 --parallelmath     requests parallel math markup for MathML
                    (off by default)
 --keepTeX          keeps the TeX source of a formula as a MathML
                    annotation element (requires --parallelmath)
 --keepXMath        keeps the XMath of a formula as a MathML
                    annotation-xml element (requires --parallelmath)
 --nocomments       omit comments from the output
 --inputencoding=enc specify the input encoding.
 --VERSION          show version number.
 --debug=package    enables debugging output for the named
                    package
 --help             shows this help message.

In I<math> C<mode>, latexmls accepts one TeX formula on input.
In I<standard> and I<fragment> C<mode>, latexmls accepts one I<texfile>
filename per line on input, but only when --local is specified.
If I<texfile> has an explicit extension of C<.bib>, it is processed
as a BibTeX bibliography.

Each communication session allows local option overwriting on the first sent line.
The input will be read until a line containing "END OF REQUEST" is found. Please
take this into account to avoid hanging.

=head1 ToDo List

This is an early release, which has a list of future features planned. They include:
- Support fragments and standard LaTeX files sent via the socket, in addition to the filename scheme.
- Allow log transmission.

=head1 OPTIONS AND ARGUMENTS

=over 4

=item C<--destination>=I<file>

Requires: C<--local>

Specifies the destination file; by default the XML is written to stdout.
The Daemon allows using the #name, #dir and #ext patterns as variables for
the base of the source filename, the source directory and the source file extension.
An example would be: C<--destination=#dir/#name.xml>

=item C<--postdest>=I<file>

Requires: C<--local>, C<--post>

Behaves like C<--destination>, for the post-processing target.
makes use of the C<#dir>,C<#name>,C<#ext> patterns. 

If omitted and C<--destination> is not provided, but C<--post> is specified, 
the output will be returned via the socket. If C<--destination> is present, 
but C<--postdest> is omitted, the default will substitute the extension 
from C<.tex.xml> or C<.xml> to C<.xhtml>. If the C<--destination> extension is different, 
C<.xhtml> will be simply appended.

Note that for output formats different from .xhtml one should always specify
the C<--postdest> option.

=item C<--preload>=I<module>

Requests the loading of an optional module or package.  This may be useful if the TeX code
does not specificly require the module (eg. through input or usepackage).
For example, use C<--preload=LaTeX.pool> to force LaTeX mode.

=item C<--includestyles>

This optional allows processing of style files (files with extensions C<sty>,
C<cls>, C<clo>, C<cnf>).  By default, these files are ignored  unless a latexml
implementation of them is found (with an extension of C<ltxml>).

These style files generally fall into two classes:  Those
that merely affect document style are ignorable in the XML.
Others define new markup and document structure, often using
deeper LaTeX macros to achieve their ends.  Although the omission
will lead to other errors (missing macro definitions), it is
unlikely that processing the TeX code in the style file will
lead to a correct document.

=item C<--path>=I<dir>

Add I<dir> to the search paths used when searching for files, modules, style files, etc;
somewhat like TEXINPUTS.  This option can be repeated.

=item C<--log>=I<file>

Requires: C<--local>

Specifies the log file; be default any conversion messages are printed to stderr.
The Daemon allows using the C<#name>, C<#dir> and C<#ext> patterns as variables for
the base of the source filename, the source directory and the source file extension.
An example would be: C<--log=#dir/#name.log>

=item C<--postlog>=I<file>

Requires: C<--local>, C<--post>

Behaves like C<--log>, but reports on the status of the post-processing exclusively.
The C<#name>,C<#dir> and C<#ext> patterns can be used.
Default is merging this log at the original C<--log> target

=item C<--summary>

Return a one line summary message of the conversion outcome. The message is always sent back
via the socket, strictly after any other return values possible.

=item C<--autoflush>=I<count>

Automatically restart the daemon after converting "count" inputs.
Good practice for vast batch jobs. (default: 10000)

=item C<--timeout>=I<secs>

Set an inactivity timeout value in seconds. If the daemon is not given any input
for the timeout period it will automatically self-destruct.
The default value is 60 seconds, set to 0 to disable.

=item C<--port>=I<number>

Specify server port (default: 3334 for math, 3344 for fragment and 3354 for standard)

=item C<--local>

Request a local server (default: off)
Required for the C<--log> and C<--destination> switches
Required for processing filenames on input, as well as for any filesystem access.
If switched off, the only means of communication with the server is via the respective socket.
Caveat: When C<--local> is disabled, fatal errors cause an empty output at the moment.

=item C<--documentid>=I<id>

Assigns an ID to the root element of the XML document.  This ID is generally
inherited as the prefix of ID's on all other elements within the document.
This is useful when constructing a site of multiple documents so that
all nodes have unique IDs.

=item C<--quiet>

Reduces the verbosity of output during processing, used twice is pretty silent.

=item C<--verbose>

Increases the verbosity of output during processing, used twice is pretty chatty.
Can be useful for getting more details when errors occur.

=item C<--strict>

Specifies a strict processing mode. By default, undefined control sequences and
invalid document constructs (that violate the DTD) give warning messages, but attempt
to continue processing.  Using C<--strict> makes them generate fatal errors.

=item C<--bibtex>

Forces latexml to treat the file as a BibTeX bibliography.
Note that the timing is slightly different than the usual
case with BibTeX and LaTeX.  In the latter case, BibTeX simply
selects and formats a subset of the bibliographic entries; the
actual TeX expansion is carried out when the result is included
in a LaTeX document.  In contrast, latexml processes and expands
the entire bibliography; the selection of entries is done
during post-processing.  This also means that any packages
that define macros used in the bibliography must be
specified using the C<--preload> option.

=item C<--xml>

Requests XML output; this is the default.

=item C<--tex>

Requests TeX output for debugging purposes;  processing is only carried out through expansion and digestion.
This may not be quite valid TeX, since Unicode may be introduced.

=item C<--box>

Requests Box output for debugging purposes;  processing is carried out through expansion and digestions,
and the result is printed.

=item C<--mode>

fragment: Parses frontmatter and \begin{document}...\end{document} fragments.
          Assumes that the documentclass is fixed (if any), which achieves a big speedup,
          since no state reinitialization is necessary. Use the C<--preload> switch
          to load the document class when invoking the daemon.
          Example: C<latexmls --preload=LaTeX.pool --preload=article.cls --mode=fragment>

standard: Default, turns on the classic, unoptimized processing of documents as performed by latexml.
          This is suitable for processing sets of heterogeneous documents, but is slower in general.
          Example: C<latexmls --mode=standard>

math:     Like latexmlmath, parses a single TeX formula per line.
          Example: C<latexmls --mode=math --pmml --keepTeX --parallelmath>

=item C<--post>

Request post-processing of converted XML to XHTML. Default behaviour is
creating XHTML output with Presentational MathML.

=item C<--embed>

Requests an embeddable XHTML div (requires: --post, --mode=fragment), respectively the
top division of the document's body.
Caveat: This experimental mode is enabled only for fragment mode and post-processed
documents (to XHTML). Also, this option can not be used if an explicit --destination
or --postdest are provided.

=item C<--pmml>

Requests conversion of math to Presentation MathML.
Conversion is the default for xhtml format.

=item C<--cmml>

Requests or disables conversion of math to Content MathML.
Conversion is disabled by default.
B<Note> that this conversion is only partially implemented.

=item C<--openmath>

Requests or disables conversion of math to OpenMath.
Conversion is disabled by default.
B<Note> that this conversion is not yet supported in C<latexmls>.

=item C<--keepTeX>

By default, when any of the MathML or OpenMath conversions
are used, the source TeX formula will be removed;
This option preserves it as a MathML annotation in parallel markup.
B<Note> that C<--parallelmath> and C<--pmml> or C<--cmml> are required.

=item C<--keepXMath>

By default, when any of the MathML or OpenMath conversions
are used, the intermediate math representation will be removed;
This option preserves it as a MathML annotation in parallel markup.
B<Note> that C<--parallelmath> and C<--pmml> or C<--cmml> are required.

=item C<--parallelmath>

Requests or disables parallel math markup.
Parallel markup is the default for xhtml formats when multiple math
formats are requested.

This method uses the MathML C<semantics> element with additional formats
appearing as C<annotation>'s.
The first math format requested must be either Presentation or Content MathML;
additional formats may be MathML or OpenMath.

If this option is disabled and multiple formats are requested, the
representations are simply stored as separate children of the C<Math> element.


=item C<--stylesheet>=I<file>

Sets a stylesheet of choice to be used by the postprocessor. Requires C<--post>

=item C<--css>=I<cssfile>

Adds I<cssfile> as a css stylesheet to be used in the transformed html/xhtml.
Multiple stylesheets can be used; they are included in the html in the
order given, following the default C<core.css>
(but see C<--nodefaultcss>). Some stylesheets included in the distribution are
  --css=navbar-left   Puts a navigation bar on the left.
                      (default omits navbar)
  --css=navbar-right  Puts a navigation bar on the left.
  --css=theme-blue    A blue coloring theme for headings.
  --css=amsart        A style suitable for journal articles.

=item C<--nodefaultcss>

Disables the inclusion of the default C<core.css> stylesheet.

=item C<--nocomments>

Normally latexml preserves comments from the source file, and adds a comment every 25 lines as
an aid in tracking the source.  The option --nocomments discards such comments.

=item C<--inputencoding=>I<encoding>

Specify the input encoding, eg. C<--inputencoding=iso-8859-1>.
The encoding must be one known to Perl's Encode package.
Note that this only enables the translation of the input bytes to
UTF-8 used internally by LaTeXML, but does not affect catcodes.
In such cases, you should be using the inputenc package.
Note also that this does not affect the output encoding, which is
always UTF-8.

=item C<--VERSION>

Shows the version number of the LaTeXML package..

=item C<--debug>=I<package>

Enables debugging output for the named package. The package is given without the leading LaTeXML::.

=item C<--help>

Shows this help message.

=back

=head1 SEE ALSO

L<latexmlc>, L<latexmld>, L<latexml>, L<latexmlpost>, L<latexmlmath>, L<LaTeXML>

=cut
#**********************************************************************

