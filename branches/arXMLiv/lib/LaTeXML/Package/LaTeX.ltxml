# -*- CPERL -*-
# /=====================================================================\ #
# |  LaTeX                                                              | #
# | Implementation for LaTeXML                                          | #
# |=====================================================================| #
# | Part of LaTeXML:                                                    | #
# |  Public domain software, produced as part of work done by the       | #
# |  United States Government & not subject to copyright in the US.     | #
# |---------------------------------------------------------------------| #
# | Bruce Miller <bruce.miller@nist.gov>                        #_#     | #
# | http://dlmf.nist.gov/LaTeXML/                              (o o)    | #
# \=========================================================ooo==U==ooo=/ #

#**********************************************************************
# Organized following 
#  "LaTeX: A Document Preparation System"
#   by Leslie Lamport
#   2nd edition
# Addison Wesley, 1994
# Appendix C. Reference Manual
#**********************************************************************
# NOTE: A lot of this should be in Primitives.pm 
# either builtin, or inherited from plain.
#**********************************************************************
package LaTeXML::Package::Pool;
use strict;
use LaTeXML::Package;
use XML::LibXML;
use LaTeXML::Util::Pathname;
use LaTeXML::Util::LibXML;
no warnings 'redefine';

#**********************************************************************
# C.1.  Commands and Environments.
#**********************************************************************

#======================================================================
# C.1.1 Command Names and Arguments
#======================================================================
# Nothing...

#======================================================================
# C.1.2 Environments
#======================================================================

# In LaTeX, \newenvironment{env} defines \env and \endenv.
# \begin{env} & \end{env} open/close a group, and invoke these.
# In fact, the \env & \endenv don't have to have been created by
# \newenvironment; And in fact \endenv doesn't even have to be defined!
# [it is created by \csname, and equiv to \relax if no previous defn]

# We need to respect these usages here, but we also want to be able
# to define environment constructors that `capture' the body so that
# it can be processed specially, if needed.  These are the magic
# '\begin{env}', '\end{env}' control sequences created by DefEnvironment.

DefExpandable('\begin{}',sub { 
  my($gullet,$env)=@_;
  my $name = $env->toString;
  if(LookupDefinition(T_CS("\\begin{$name}"))){
    T_CS("\\begin{$name}"); } # Magic cs!
  else {			# If not defined, let stomach handle it.
    (T_CS('\begingroup'),T_CS("\\$name")); }});

DefExpandable('\end{}',  sub { 
  my($gullet,$env)=@_;
  my $name = $env->toString;
  my $t;
  if   (LookupDefinition($t=T_CS("\\end{$name}"))){ $t; } # Magic CS!
  elsif(LookupDefinition($t=T_CS("\\end$name")))  { ($t, T_CS('\endgroup')); }
  else { ( T_CS('\endgroup')); }});

#======================================================================
# C.1.3 Fragile Commands
#======================================================================
# Because of the way we `move information', revertable and pre-processed,
# I don't think we actually need to do anything ... 
# [Course that means we're not _really_ TeX!]
DefExpandable('\protect',undef);

#======================================================================
# C.1.4 Declarations
#======================================================================
# actual implementation later.
#======================================================================
# C.1.5 Invisible Commands
#======================================================================
# actual implementation later.

#======================================================================
# C.1.6 The \\ Command
#======================================================================
# In math, \\ is just a formatting hint, unless within an array, cases, .. environment.
DefConstructor("\\\\ OptionalMatch:* [Dimension]",
	       "?#isMath(<ltx:XMHint name='\\'/>)(\n)", alias=>"\\\\\n");

#**********************************************************************
# C.2. The Structure of the Document
#**********************************************************************
#   prepended files (using filecontents environment)
#   preamble (starting with \documentclass)
#   \begin{document}
#    text
#   \end{document}

DefEnvironment('{document}',
	       "<ltx:document id='#id'>#body</ltx:document>",
	       beforeDigest=> sub { AssignValue(inPreamble=>0); },
	       afterDigestBegin=>sub { $_[1]->setProperty(id=>Expand(T_CS('\thedocument@ID'))); },
	       afterDigest=> sub { $_[0]->getGullet->flush; return; });

#**********************************************************************
# C.3. Sentences and Paragraphs
#**********************************************************************

#======================================================================
# C.3.1 Making Sentences
#======================================================================
# quotes;  should these be handled in DOM/construction?
# dashes:  We'll need some sort of Ligature analog, or something like
# Omega's OTP, to combine sequences of "-" into endash, emdash,
# Perhaps it also applies more semantically?
# Such as interpreting certain sequences as section headings,
# or math constructs.

# Spacing; in Primitives.pm

# Special Characters; in Primitives.pm

# Logos
# \TeX is in Primitives.pm
DefConstructor('\LaTeX', 'LaTeX');

our @MonthNames=(qw( January February March April May June
		     July August September October November December));
DefExpandable('\today',sub { 
   Explode($MonthNames[LookupValue('\month')->valueOf-1]
	   ." ".LookupValue('\day')->valueOf
	   .', '.LookupValue('\year')->valueOf); });

DefConstructor('\emph{}', "<ltx:emph>#1</ltx:emph>", mode=>'text');

#======================================================================
# C.3.2 Making Paragraphs
#======================================================================
# \noindent, \indent, \par in Primitives.pm

# Style parameters
# \parindent, \baselineskip, \parskip alreadin in Primitives.pm

DefPrimitive('\linespread{}', undef);

#======================================================================
# C.3.3 Footnotes
#======================================================================
# NOTE: probably should default the mark to some counter?
DefConstructor('\footnote[]{}',
	       "<ltx:note class='foot' ?#1(mark='#1')>#2</ltx:note>");
# NOTE: DOM should reattach the footnotetext to the footnotemark ?
#  Hmm, in general the mark & text _could_ come in either order...
DefConstructor('\footnotemark[]',""); # ????
DefConstructor('\footnotetext[]{}',
	       "<ltx:note class='foot' ?#1(mark='#1')>#2</ltx:note>");

# Style parameters
DefRegister('\footnotesep' => Dimension(0));
DefPrimitive('\footnoterule',undef);

#======================================================================
# C.3.4 Accents and Special Symbols
#======================================================================
# See Primitives.pm

# See Section 3.3.2 Mathematical Symbols, below

#**********************************************************************
# C.4 Sectioning and Table of Contents
#**********************************************************************

#======================================================================
# C.4.1 Sectioning Commands.
#======================================================================
# Note that LaTeX allows fairly arbitrary stuff in \the<ctr>, although
# it can get you in trouble.  However, in almost all cases, the result
# is plain text.  So, I'm putting refnum as an attribute, where I like it!
# You want something else? Redefine!

# Also, we're adding an id to each, that is parallel to the refnum, but
# valid as an ID.  You can tune the representation by defining, eg. \thesection@ID

# A little more messy than seems necessary:
#  We don't know whether to step the counter and update \@currentlabel until we see the '*',
# but we have to know it before we digest the title, since \label can be there!

# These are defined in terms of \@startsection so that
# casual user redefinitions work, too.
DefMacro('\chapter',       '\@startsection{chapter}{}{}{}{}{}');
DefMacro('\part',          '\@startsection{part}{}{}{}{}{}');
DefMacro('\section',       '\@startsection{section}{}{}{}{}{}');
DefMacro('\subsection',    '\@startsection{subsection}{}{}{}{}{}');
DefMacro('\subsubsection', '\@startsection{subsubsection}{}{}{}{}{}');
DefMacro('\paragraph',     '\@startsection{paragraph}{}{}{}{}{}');
DefMacro('\subparagraph',  '\@startsection{subparagraph}{}{}{}{}{}');
map(Tag("ltx:$_", autoClose=>1),
    qw(part chapter section subsection subsubsection paragraph subparagraph));

DefExpandable('\@startsection{}{}{}{}{}{} OptionalMatch:*', sub {
  my($gullet,$type,$level,$ignore3,$ignore4,$ignore5,$ignore6,$flag)=@_;
  if($flag){
    refStepID(ToString($type));
    (T_CS('\\@@section'),
     T_BEGIN,$type->unlist,T_END,
     T_OTHER('['),T_OTHER(']'),
     T_OTHER('['),T_CS('\@currentID'),T_OTHER(']')); }
  else {
    refStepCounter(ToString($type));
    (T_CS('\\@@section'),
     T_BEGIN,$type->unlist,T_END,
     T_OTHER('['),T_CS('\@currentlabel'),T_OTHER(']'),
     T_OTHER('['),T_CS('\@currentID'),T_OTHER(']')); }});

DefConstructor('\\@@section{}[][][]{}',sub {
  my($document,$type,$refnum,$id,$toctitle,$title)=@_;
  $document->openElement("ltx:".$type->toString,refnum=>$refnum,id=>$id);
  $document->insertElement('ltx:title',$title);
  $document->insertElement('ltx:toctitle',$toctitle) if $toctitle; },
  properties=>{refnum=>'#2',id=>'#3'});

# Not sure if this is best, but if no explicit \section'ing...
Tag('ltx:section',autoOpen=>1);
#======================================================================
# C.4.2 The Appendix
#======================================================================
# NOTE: 2 options:
#  1) redefine \section, etc to produce <appendix>, <subappendix>, etc.
#  2) Wrap remainder of doc with <appendix>
# DefPrimitive('\appendix');

#======================================================================
# C.4.3 Table of Contents
#======================================================================
# Ignore these; leave it up to post processing.
DefPrimitive('\tableofcontents', undef);
DefPrimitive('\listoffigures',   undef);
DefPrimitive('\listoftables',    undef);

DefPrimitive('\addcontentsline{}{}{}', undef);
DefPrimitive('\numberline{}{}', undef);
DefPrimitive('\addtocontents{}{}', undef);

#======================================================================
# C.4.4 Style registers
#======================================================================
DefRegister('\secnumdepth' => Number(0));
DefRegister('\tocdepth'    => Number(0));

#**********************************************************************
# C.5 Classes, Packages and Page Styles
#**********************************************************************

#======================================================================
# C.5.1 Document Class
#======================================================================
# \documentclass is defined in Primitives.pm, to automatically switch
# to LaTeX mode when processing LaTeX files.

# Style Parameters
DefRegister('\bibindent'    => Dimension(0));
DefRegister('\columnsep'    => Dimension(0));
DefRegister('\columnseprule'=> Dimension(0));
DefRegister('\mathindent'   => Dimension(0));

#======================================================================
# C.5.2 Packages
#======================================================================
# We'll prefer to load package.pm, but will try package.sty or 
# package.tex (the latter being unlikely to work, but....)
# See Stomach.pm for details
# Ignorable packages ??
# pre-defined packages??

DefConstructor('\usepackage[]{}',
	       "<?latexml package='#2' ?#1(options='#1')?>",
	       afterDigest=>sub { my($stomach,$whatsit)=@_;
				  my $options=$whatsit->getArg(1);
				  my $packages=$whatsit->getArg(2);

				  my @pkgs = split(',',$packages->toString);
				  $options = [($options ? split(',',($options->toString)) :())];
				  map(RequirePackage($_,options=>$options),@pkgs);
				  return});
DefConstructor('\RequirePackage[]{}[]',
	       "<?latexml package='#2' ?#1(options='#1')?>",
	       afterDigest=>sub { my($stomach,$whatsit)=@_;
				  my $options=$whatsit->getArg(1);
				  my $package=$whatsit->getArg(2);
				  $options = [($options ? split(',',($options->toString)) :())];
				  RequirePackage(ToString($package), options=>$options); });
DefConstructor('\LoadClass[]{}[]',
	       "<?latexml class='#2' ?#1(options='#1')?>",
	       afterDigest=>sub { my($stomach,$whatsit)=@_;
				  my $options=$whatsit->getArg(1);
				  my $class=$whatsit->getArg(2);
				  $options = [($options ? split(',',($options->toString)) :())];
				  RequirePackage(ToString($class), options=>$options); });

#======================================================================
# C.5.3 Page Styles
#======================================================================
# Ignored
DefPrimitive('\pagestyle{}',    undef);
DefPrimitive('\thispagestyle{}',undef);
DefPrimitive('\markright{}',    undef);
DefPrimitive('\markboth{}{}',   undef);
DefPrimitive('\pagenumbering{}',undef);
DefPrimitive('\twocolumn[]',    undef);
DefPrimitive('\onecolumn',      undef);

# Style parameters from Fig. C.3, p.182
DefRegister('\paperheight'   => Dimension(0));
DefRegister('\paperwidth'    => Dimension(0));
DefRegister('\textheight'    => Dimension(0));
DefRegister('\textwidth'     => Dimension('6in'));
DefRegister('\topmargin'     => Dimension(0));
DefRegister('\headheight'    => Dimension(0));
DefRegister('\headsep'       => Dimension(0));
DefRegister('\footskip'      => Dimension(0));
DefRegister('\footheight'    => Dimension(0));
DefRegister('\evensidemargin'=> Dimension(0));
DefRegister('\oddsidemargin' => Dimension(0));
DefRegister('\marginparwidth'=> Dimension(0));
DefRegister('\marginparsep'  => Dimension(0));
DefRegister('\columnwidth'   => Dimension('6in'));
DefRegister('\linewidth  '   => Dimension('6in'));
DefRegister('\baselinestretch'   => Dimension(0));

#======================================================================
# C.5.4 The Title Page and Abstract
#======================================================================

DefMacro('\@title','');
DefMacro('\@author','');
DefMacro('\@date','\today');
DefPrimitive('\title{}',    sub { DefMacro('\@title',$_[1])});
DefPrimitive('\author{}',   sub { DefMacro('\@author',$_[1])});
DefPrimitive('\date{}',     sub { DefMacro('\@date',$_[1])});
DefConstructor('\thanks{}', "<ltx:thanks>#1</ltx:thanks>");

# Hmm, this should ideally split authors into multiple author lists?
DefConstructor('\and', " and ");

# Introduce secret control sequences to format the title, date, etc.
# These will be used by \maketitle when the time comes.
DefConstructor('\fmt@title{}', "<ltx:title>#1</ltx:title>");
DefConstructor('\fmt@author{}', "<ltx:author>#1</ltx:author>");
# Would be nice to put the ISO date as an attribute!
DefConstructor('\fmt@date{}', "<ltx:creationdate>#1</ltx:creationdate>");
# This needs to be a macro so that \@author, etal, get expanded.
DefMacro('\maketitle', '\fmt@title{\@title}\fmt@author{\@author}\fmt@date{\@date}');

DefEnvironment('{abstract}','<ltx:abstract>#body</ltx:abstract>');
# Presumably you'll do whatever you need to specify author, etc ???
DefEnvironment('{titlepage}','#body');

#**********************************************************************
# C.6 Displayed Paragraphs
#**********************************************************************
DefEnvironment('{center}',
	       '<ltx:centering>#body</ltx:centering>');
DefEnvironment('{centering}',
	       '<ltx:centering>#body</ltx:centering>');
# NOTE: center the _line_ (till \\ or \par or ?) ! How to get it?
DefPrimitive('\centering',undef);

# Hmm, not sure here about using minipage.
# In fact, probably centering & minipage should combine into some
# sort of generic block, with attributes...
DefEnvironment('{flushleft}',
	       "<ltx:minipage justified='left'>#body</ltx:minipage>");
DefEnvironment('{flushright}',
	       "<ltx:minipage justified='right'>#body</ltx:minipage>");

#======================================================================-
# C.6.1 Quotations and Verse
#======================================================================-
DefEnvironment('{quote}',   
	       '<ltx:quote>#body</ltx:quote>');
DefEnvironment('{quotation}',
	       '<ltx:quotation>#body</ltx:quotation>');
# NOTE: Handling of \\ within these environments?
DefEnvironment('{verse}',
	       '<ltx:verse>#body</ltx:verse>');

#======================================================================
# C.6.2 List-Making environments
#======================================================================
Tag('ltx:item', autoClose=>1);
DefConstructor('\item[]',
	       "<ltx:item>?#1(<ltx:tag>#1</ltx:tag>)");

sub refStepItemCounter {
  refStepCounter('enum'.ToString(Tokens(roman(LookupValue('itemlevel'))))); }

sub beforeItemize {
  my($type)=@_;
  my $level = AssignValue(itemlevel=>LookupValue('itemlevel')+1);
  Let('\item'=>"\\".$type.'@item');
  resetCounter('enum'.ToString(Tokens(roman(LookupValue('itemlevel')))));
}

DefConstructor('\itemize@item[]',
	       "<ltx:item id='#id'>?#1(<ltx:tag>#1</ltx:tag>)",
	       properties=>sub{ refStepItemCounter(); });
DefConstructor('\enumerate@item[]',
	       "<ltx:item id='#id' refnum='#refnum'>?#1(<ltx:tag>#1</ltx:tag>)",
	       properties=>sub{ refStepItemCounter(); });
DefConstructor('\description@item[]',
	       "<ltx:item id='#id'>?#1(<ltx:tag>#1</ltx:tag>)",
	       properties=>sub{ refStepItemCounter(); });

AssignValue(itemlevel=>0);

  
DefEnvironment('{itemize}',
	       "<ltx:itemize id='#id'>#body</ltx:itemize>",
	       beforeDigest=>sub { beforeItemize('itemize'); },
	       properties=>sub { refStepCounter('@itemize'); });
DefEnvironment('{enumerate}',
	       "<ltx:enumerate  id='#id'>#body</ltx:enumerate>",
	      beforeDigest=>sub { beforeItemize('enumerate'); },
	       properties=>sub { refStepCounter('@itemize'); });
DefEnvironment('{description}',
	       "<ltx:description  id='#id'>#body</ltx:description>",
	       beforeDigest=>sub { beforeItemize('description'); },
	       properties=>sub { refStepCounter('@itemize'); });

# NOTE: Do I need to do anything with
# \labelitemi, labelitemii, labelitemiii or labelitemiv ?
# Probably would be useful (once I've got counters properly implemented)
# to add a number to the items.

#======================================================================
# C.6.3 The list and trivlist environments.
#======================================================================
# Mostly just punting, here; you probably want a more meaningful name
# for your list if you want better XML.
DefEnvironment('{list}{}{}',
	       "<ltx:list default_label='#1' declarations='#2'>#body</ltx:list>");
DefEnvironment('{trivlist}',
	       '<ltx:trivlist>#body</ltx:trivlist>');

DefRegister('\topsep'        => Glue(0));
DefRegister('\partopsep'     => Glue(0));
DefRegister('\itemsep'       => Glue(0));
DefRegister('\parsep'        => Glue(0));
DefRegister('\leftmargin'    => Dimension(0));
DefRegister('\rightmargin'   => Dimension(0));
DefRegister('\listparindent' => Dimension(0));
DefRegister('\itemindent'    => Dimension(0));
DefRegister('\labelsep'      => Dimension(0));

# NOTE: Eventually use \makelabel to construct the list ?
#\makelabel{label}
# Could do something with this, but it's a headache.
DefPrimitive('\usecounter{}', undef);

#======================================================================
# C.6.4 Verbatim
#======================================================================

# NOTE: how's the best way to get verbatim material through?
DefEnvironment('{verbatim}', '<ltx:verbatim>#body</ltx:verbatim>');
DefEnvironment('{verbatim*}','<ltx:verbatim>#body</ltx:verbatim>');

# verbatim is a bit of special case;
# It looks like an environment, but it only ends with an explicit "\end{verbatim}" on it's own line.
# So, we'll end up doing things more manually.
# We're going to sidestep the Gullet for inputting, 
# and also the usual environment capture.
InstallDefinition(LaTeXML::Constructor
		  ->new(T_CS('\begin{verbatim}'),undef,
			"<ltx:verbatim font='#font'>#body</ltx:verbatim>",
			beforeDigest=>[sub { $_[0]->bgroup; 
					     AssignValue(current_environment=>'verbatim');
					     MergeFont(family=>'typewriter');
					     Digest(T_CS('\par')); }],
			afterDigest=>[sub {
					my($stomach,$whatsit)=@_;
					$stomach->egroup;
					my $font = $whatsit->getFont;
					my $loc  = $whatsit->getLocator;
					my @lines = $stomach->getGullet->getMouth->readRawLines("\\end{verbatim}");
					# Note last line ends up as Whatsit's "trailer"
					$whatsit->setBody(map(LaTeXML::Box->new($_,$font,$loc,T_OTHER($_)),
							      @lines, "\end{verbatim}"));
					return; }]));

# WARNING: This code binds $STATE to a simple State object with known fixed catcodes.
# The State normally contains ALL the bindings, etc and links to other important objects.
# We CAN do that here, since we are ONLY tokenizing from a new Mouth, bypassing stomach & gullet.
# However, be careful with any changes.

# Hmm, this should really be constructor or something so that at least typewriter font
# is used, if not wrapped in a <verb> something???
our $EMPTY_CATTABLE=LaTeXML::State->new(catcodes=>'none');
DefConstructor('\verb', "<ltx:verbatim font='#font'>#body</ltx:verbatim>",
###	       font=>{family=>'typewriter'},
	       beforeDigest=>[sub { $_[0]->bgroup; MergeFont(family=>'typewriter'); }],
	       afterDigest=>sub { 
		 my($stomach,$whatsit)=@_;
		 $stomach->egroup; 
		 my $font = $whatsit->getFont;
		 my $loc  = $whatsit->getLocator;
		 my $mouth = $stomach->getGullet->getMouth;
		 my ($init,$body);
		 { local $STATE = $EMPTY_CATTABLE;
		   $init = $mouth->readToken;
		   $init = $mouth->readToken if $init->toString eq '*'; # Should I bother handling \verb* ?
		   $body = $mouth->readTokens($init); }
		 $whatsit->setBody(map(LaTeXML::Box->new($_->toString,$font,$loc,$_),$body->unlist,$init)); },
	       reversion=>sub { (T_CS('\verb'),$_[0]->getTrailer->revert,
				 $_[0]->getBody->revert,$_[0]->getTrailer->revert); }
);

# This is defined by the alltt package.
# Environment('alltt', ?);

#**********************************************************************
# C.7 Mathematical Formulas
#**********************************************************************

#======================================================================
# C.7.1 Math Mode Environments
#======================================================================
DefEnvironment('{displaymath}', 
	       "<ltx:equation>"
	       . "<ltx:Math mode='display'>"
	       .  "<ltx:XMath>"
	       .   "#body"
	       .  "</ltx:XMath>"
	       . "</ltx:Math>"
	       ."</ltx:equation>",
	       mode=>'display_math');
DefEnvironment('{math}',
	       "<ltx:Math mode='inline'>"
	       . "<ltx:XMath>"
	       .  "#body"
	       . "</ltx:XMath>"
	       ."</ltx:Math>",
	       mode=>'inline_math');
DefEnvironment('{equation}',
	       "<ltx:equation id='#id' refnum='#refnum'>"
	       . "<ltx:Math mode='display'>"
	       .  "<ltx:XMath>"
	       .   "#body"
	       .  "</ltx:XMath>"
	       . "</ltx:Math>"
	       ."</ltx:equation>",
	       mode=>'display_math',
	       properties=> sub { refStepCounter('equation') });
DefEnvironment('{equation*}',
	       "<ltx:equation id='#id'>"
	       . "<ltx:Math mode='display'>"
	       .  "<ltx:XMath>"
	       .   "#body"
	       .  "</ltx:XMath>"
	       . "</ltx:Math>"
	       ."</ltx:equation>",
	       mode=>'display_math',
	       properties=> sub { refStepID('equation') });

# NOTE: This has to interact with equation to CANCEL (or backtrack?) the
# numbering?
DefPrimitive('\nonumber',undef);

# Define \( ..\) and \[ ... \] to act like environments.
DefConstructor('\[',
	       "<ltx:equation id='#id'>"
	       . "<ltx:Math mode='display'>"
	       .  "<ltx:XMath>"
	       .   "#body"
	       .  "</ltx:XMath>"
	       . "</ltx:Math>"
	       ."</ltx:equation>",
	       beforeDigest=> sub{ $_[0]->beginMode('display_math'); },
	       captureBody=>1,
	       properties=> sub { refStepID('equation') });
DefConstructor('\]'  ,"",beforeDigest=> sub{ $_[0]->endMode('display_math'); });
DefConstructor('\(' ,
	       "<ltx:Math mode='inline'>"
	       . "<ltx:XMath>"
	       .  "#body"
	       . "</ltx:XMath>"
	       ."</ltx:Math>",
	       beforeDigest=> sub{ $_[0]->beginMode('inline_math'); },
	       captureBody=>1);
DefConstructor('\)'   ,"", beforeDigest=> sub{ $_[0]->endMode('inline_math'); });

DefExpandable('\ensuremath{}', sub {
  my($gullet,$stuff)=@_;
  if(LookupValue('IN_MATH')){ @$stuff; }
  else { (T_MATH,@$stuff,T_MATH); }});

# NOTE: The numbering isn't right.
# And the parseability will have to be worked on!
DefEnvironment('{eqnarray}',
	       sub { my($document,%props)=@_;
		     $document->openElement('ltx:equation',
					    refnum=>$props{refnum}, id=>$props{id});
		     $document->openElement('ltx:Math',mode=>'display');
		     $document->openElement('ltx:XMath');
		     my $n=$props{trailer}->getProperty('n_columns');
		     alignment($document,$props{body},
			       parseTabularPattern('rcl'),0,
			       name=>'eqnarray');
		 $document->closeElement('ltx:XMath');
		 $document->closeElement('ltx:Math');
		 $document->closeElement('ltx:equation'); },
	       mode=>'display_math',
	       properties=> sub { refStepCounter('equation') },
	       beforeDigest=>\&before_alignment,
	       afterDigest=>\&after_alignment);
DefEnvironment('{eqnarray*}',
	       sub { my($document,%props)=@_;
		     $document->openElement('ltx:equation', id=>$props{id});
		     $document->openElement('ltx:Math',mode=>'display');
		     $document->openElement('ltx:XMath');
		     my $n=$props{trailer}->getProperty('n_columns');
		     alignment($document,$props{body},
			       parseTabularPattern('rcl'),0,
			       name=>'eqnarray');
		 $document->closeElement('ltx:XMath');
		 $document->closeElement('ltx:Math');
		 $document->closeElement('ltx:equation'); },
	       mode=>'display_math',
	       properties=> sub { refStepID('equation') },
	       beforeDigest=>\&before_alignment,
	       afterDigest=>\&after_alignment);

DefMacro('\lefteqn{}','\multicolumn{3}{l}{#1\mbox{}}');

# Style Parameters
#  \abovedisplayskip \abovedisplayshortskip, \jot are in Primitives.pm
DefRegister('\mathindent' =>Dimension(0)); 

#======================================================================
# C.7.2 Common Structures
#======================================================================
# sub, superscript and prime are in Primitives.pm

our %fracstylemap=(display=>'text', text=>'script',
		   script=>'scriptscript', scriptscript=>'scriptscript');
sub beforeFrac {
  $_[0]->bgroup;
  AssignValue(mathstyle=>$fracstylemap{LookupValue('mathstyle')}); }
sub afterFrac  {
  $_[0]->egroup;
  $_[1]->setProperty('style',LookupValue('mathstyle')); }

# Needed by amsmath (at least)
sub beforeTFrac { $_[0]->bgroup; AssignValue(mathstyle=>'text');
		  beforeFrac(@_); }
sub afterTFrac  { afterFrac(@_); $_[0]->egroup; }

sub beforeDFrac { $_[0]->bgroup; AssignValue(mathstyle=>'display'); 
		  beforeFrac(@_); }
sub afterDFrac  { afterFrac(@_); $_[0]->egroup; }

DefConstructor('\frac{}{}',
	       "<ltx:XMApp>"
	       . "<ltx:XMTok meaning='div' role='MULOP' style='#style'/>"
	       . "<ltx:XMArg>#1</ltx:XMArg><ltx:XMArg>#2</ltx:XMArg>"
	       ."</ltx:XMApp>",
	       beforeDigest=>\&beforeFrac, afterDigest =>\&afterFrac);

# Ellipsis: See Primitives

#======================================================================
# C.7.3 Mathematical Symbols
#======================================================================
# See Tables 3.3 through 3.8 (pp 41--44)
# Defined in Primitives.pm
# [Possibly some are strictly LaTeX and should be moved here?]

#======================================================================
# C.7.4 Arrays
#======================================================================
#  See Section C.10.2

#======================================================================-
# C.7.5 Delimiters
#======================================================================-
# All this is already in Primitives.pm

DefConstructor('\stackrel{}{}',
	       "<ltx:XMApp role='RELOP'>"
	       .  "<ltx:XMTok role='SUPERSCRIPTOP' scriptpos='#scriptpos'/>"
	       .  "<ltx:XMWrap>#2</ltx:XMWrap>"
	       .  "<ltx:XMWrap>#1</ltx:XMWrap>"
	       ."</ltx:XMApp>",
	       properties=>{scriptpos=>sub{ "mid".$_[1]->getProperty('level'); }}
);
#======================================================================-
# C.7.6 Putting One Thing Above Another
#======================================================================-
# All this is already in Primitives.pm

#======================================================================-
# C.7.7 Spacing
#======================================================================-
# All this is already in Primitives.pm

#======================================================================
# C.7.8 Changing Style
#======================================================================
# For Math style changes, we record the current font, which is then merged
# into the Whatsit's created for letters, etc.  The merging depends on
# the type of letter, greek, symbol, etc.
# Apparently, with the normal TeX setup, these fonts don't really merge,
# rather they override all of family, series and shape.

DefConstructor('\mathrm{}', '#1',  bounded=>1, requireMath=>1, font=>{family=>'serif'});
DefConstructor('\mathit{}',  '#1', bounded=>1, requireMath=>1, font=>{shape=>'italic'});
DefConstructor('\mathbf{}',  '#1', bounded=>1, requireMath=>1, font=>{series=>'bold'});
DefConstructor('\mathsf{}',  '#1', bounded=>1, requireMath=>1, font=>{family=>'sansserif'});
DefConstructor('\mathtt{}',  '#1', bounded=>1, requireMath=>1, font=>{family=>'typewriter'});
DefConstructor('\mathcal{}', '#1', bounded=>1, requireMath=>1, font=>{family=>'caligraphic'});
DefConstructor('\mathscr{}', '#1', bounded=>1, requireMath=>1, font=>{family=>'script'});
DefConstructor('\mit',       '',   requireMath=>1, font=>{family=>'italic'});

#**********************************************************************
# C.8 Definitions, Numbering and Programming
#**********************************************************************

#======================================================================
# C.8.1 Defining Commands
#======================================================================

DefPrimitive('\newcommand OptionalMatch:* {Token}[][]{}', sub {
  my($stomach,$star,$cs,$nargs,$opt,$body)=@_;
  Fatal(Stringify($cs)." is already defined") if LookupDefinition($cs);
  DefMacro($cs->toString . convertLaTeXArgs($nargs,$opt),$body); });

DefPrimitive('\renewcommand OptionalMatch:* {Token}[][]{}', sub {
  my($stomach,$star,$cs,$nargs,$opt,$body)=@_;
  DefMacro($cs->toString . convertLaTeXArgs($nargs,$opt),$body); });

DefPrimitive('\providecommand OptionalMatch:* {Token}[][]{}', sub {
  my($stomach,$star,$cs,$nargs,$opt,$body)=@_;
  return if LookupDefinition($cs);
  DefMacro($cs->toString . convertLaTeXArgs($nargs,$opt),$body); });

# Need to figure out exactly what `robust' means to LaTeXML...
DefPrimitive('\DeclareRobustCommand OptionalMatch:* {Token}[][]{}', sub {
  my($stomach,$star,$cs,$nargs,$opt,$body)=@_;
  return if LookupDefinition($cs);
  DefMacro($cs->toString . convertLaTeXArgs($nargs,$opt),$body); });

# The next font declaration commands are based on
# http://tex.loria.fr/general/new/fntguide.html
# we ignore font encoding
DefPrimitive('\DeclareSymbolFont{}{}{}{}{}', sub {
  my ($stomach, $name, $enc, $family, $series, $shape) = @_;
  AssignValue('fontdeclaration@'.$name->toString,
	      {family=>$family->toString,
	       series=>$series->toString,
	       shape =>$shape->toString}); });
DefPrimitive('\DeclareSymbolFontAlphabet{}{}', sub {
  my ($stomach, $cs, $name) = @_;
  my $font = LookupValue('fontdeclarations@'.$name->toString) || {};
  DefConstructor($cs->toString, '', font=>$font); });

DefPrimitive('\DeclareMathAlphabet{}{}{}{}{}', sub {
  my ($stomach, $cs, $enc, $family, $series, $shape) = @_;
  DefConstructor($cs, '', font=>{family=>$family,
				 series=>$series,
				 shape =>$shape}); });

DefPrimitive('\DeclareFontShape{}{}{}{}{}{}', undef);
DefPrimitive('\DeclareFontFamily{}{}{}', undef);
DefPrimitive('\DeclareSizeFunction{}{}', undef);

#======================================================================
# C.8.2 Defining Environments
#======================================================================
# Note that \env & \endenv defined by \newenvironment CAN be 
# invoked directly.

DefPrimitive('\newenvironment OptionalMatch:* {}[][]{}{}', sub {
  my($stomach,$star,$name,$nargs,$opt,$begin,$end)=@_;
  $name = $name->toString;
  Fatal("Environment $name is already defined") if LookupDefinition(T_CS("\\$name"));
  DefMacro(join('','\\',$name, convertLaTeXArgs($nargs,$opt)),$begin);
  DefMacro(join('','\\end',$name),$end); });

DefPrimitive('\renewenvironment OptionalMatch:* {}[][]{}{}', sub {
  my($stomach,$star,$name,$nargs,$opt,$begin,$end)=@_;
  $name = $name->toString;
  DefMacro(join('','\\',$name, convertLaTeXArgs($nargs,$opt)),$begin);
  DefMacro(join('','\\end',$name),$end); });

#======================================================================
# C.8.3 Theorem-like Environments
#======================================================================
# NOTE: Implement.
#  define a new environment which constructs a theorem ?
# Def('\newtheorem','{}[]{}[]", ....);
# => something like <theorem type="foo"> .. </theorem>

# The core non-customizable part is defined here.
# For customizable theorems, see amsthm.
AssignValue('thm@swap' => 'N');
AssignValue('thm@style'=>'plain');
DefRegister('\thm@headfont'=>Tokens());
DefRegister('\thm@bodyfont'=>Tokens());
DefRegister('\thm@headpunct'=>Tokens());

DefPrimitive('\th@plain', sub {
  AssignValue('\thm@headfont' => T_CS('\bfseries'));
  AssignValue('\thm@bodyfont' => T_CS('\itshape'));
  AssignValue('\thm@headpunct'=> T_OTHER('.'));
  return; });

DefMacro('\@thmcountersep','.');

DefExpandable('\newtheorem OptionalMatch:* {}[]{}[]', sub {
  my ($stomach, $flag, $thmset, $otherthmset, $text, $reset) = @_;
  $thmset = $thmset->toString;
  $otherthmset = $otherthmset && $otherthmset->toString;
  $text   = undef unless $text->unlist;
  $reset  = $reset ? $reset->toString : undef;

  my $counter = $otherthmset || $thmset;
  my $swap    = LookupValue('thm@swap') eq 'S';
  my $style   = LookupValue('thm@style');

  if(!$otherthmset){
    NewCounter($counter, $reset,
	       idprefix => "Thm$counter");
    DefMacro("\\the$counter","\\the$reset\\\@thmcountersep\\arabic{$counter}")
      if $reset; }

  DefEnvironment("{$thmset}[]",
		 "<ltx:theorem id='#id' refnum='#refnum'>"
		 . "<ltx:title>#title</ltx:title>"
		 .  "#body"
		 ."</ltx:theorem>",

		 beforeDigest=>sub { Digest(Tokens(T_CS('\th@'.$style))); },
		 afterDigestBegin=> sub {
		   my($stomach,$whatsit)=@_;
		   my $note = $whatsit->getArg(1);
		   my $refnum = $whatsit->getProperty('refnum');
		   my($a,$b) = ($swap ? ($refnum,$text) : ($text,$refnum));
		   my @toks=(T_BEGIN,T_CS('\the'),T_CS('\thm@headfont'));
		   push(@toks,
			($a ? $a->unlist :()),
			($a && $b ? (T_SPACE):()),
			($b ? $b->unlist : ()));
		   if($note){
		     push(@toks,T_SPACE,T_OTHER('(')) if $text;
		     push(@toks,$note->revert);
		     push(@toks,T_OTHER(')')) if $text; }
		   push(@toks,T_CS('\the'),T_CS('\thm@headpunct'),T_END);
		   $whatsit->setProperties(title=>Digest(Tokens(@toks)));

		   Digest(Tokens(T_CS('\the'),T_CS('\thm@bodyfont'))); },
		 ($counter 
		  ? (properties => sub {
		       ($flag ? refStepID($counter) : refStepCounter($counter));})
		  :()),
		 scope => 'global');
});


#======================================================================
# C.8.4 Numbering
#======================================================================
# We're attempting to mimic LaTeX's counter mechanisms, while leveraging
# it to add id attributes to the main document structural elements.
# These id's should be both unique, and parallel the visible reference numbers
# (as much as possible).  Also, for consistency, we add id's to unnumbered
# document elements (eg from \section*); this requires an additional counter
# (eg. UNsection) and  mechanisms to track it.

# Defines a new counter named $ctr.
# If $within is defined, $ctr will be reset whenever $within is incremented.
# Keywords:
#  idprefix : specifies a prefix to be used in formatting ID's for document structure elements
#           counted by this counter.  Ie. subsection 3 in section 2 might get: id="S2.SS3"
#   nested : a list of counters that correspond to scopes which are "inside" this one.
#           Whenever any definitions scoped to this counter are deactivated,
#           the inner counter's scopes are also deactivated.
#           NOTE: I'm not sure this is even a sensible implementation,
#           or why inner should be different than the counters reset by incrementing this counter.

sub NewCounter { 
  my($ctr,$within,%options)=@_;
  my $unctr = "UN$ctr";		# UNctr is counter for generating ID's for UN-numbered items.
  DefRegister("\\c\@$ctr",Number(0));
  AssignValue("\\c\@$ctr"=>Number(0),'global');
  AssignValue("\\cl\@$ctr"=>Tokens(),'global');
  DefRegister("\\c\@$unctr",Number(0));
  AssignValue("\\c\@$unctr"=>Number(0),'global');
  AssignValue("\\cl\@$unctr"=>Tokens(),'global');
  AssignValue("\\cl\@$within" =>
	      Tokens(T_CS($ctr),T_CS($unctr),
		     (LookupValue("\\cl\@$within") ? LookupValue("\\cl\@$within")->unlist :())),
	      'global') if $within;
  AssignValue("\\cl\@UN$within" =>
	      Tokens(T_CS($unctr),
		     (LookupValue("\\cl\@UN$within") ? LookupValue("\\cl\@UN$within")->unlist :())),
	      'global') if $within;
  AssignValue('nested_counters_'.$ctr =>$options{nested}) if $options{nested};
  DefMacro("\\the$ctr","\\arabic{$ctr}");
  my $prefix = $options{idprefix};
  if(defined $prefix){
    if($within){
      DefMacro("\\the$ctr\@ID","\\ifx\\\@empty\\the$within\@ID\\else\\the$within\@ID.\\fi $prefix\\\@$ctr\@ID"); }
    else {
      DefMacro("\\the$ctr\@ID","$prefix\\\@$ctr\@ID"); }
    DefMacro("\\\@$ctr\@ID","0"); }
  return; }

sub stepCounter {
  my($ctr)=@_;
  AssignValue("\\c\@$ctr"=>LookupValue("\\c\@$ctr")->add(Number(1)),'global');
  # and reset any within counters!
  if(my $nested = LookupValue("\\cl\@$ctr")){
    foreach my $c ($nested->unlist){
      resetCounter($c->toString); }}
  Expand(T_CS("\\the$ctr")); }

# HOW can we retract this?
sub refStepCounter {
  my($ctr)=@_;
  my $v = stepCounter($ctr);
  InstallDefinition(LaTeXML::Expandable->new(T_CS("\\\@$ctr\@ID"),undef,
					     Tokens(Explode(LookupValue('\c@'.$ctr)->valueOf))));
  my $id = Expand(T_CS("\\the$ctr\@ID"));
  InstallDefinition(LaTeXML::Expandable->new(T_CS('\@currentlabel'),undef,$v));
  InstallDefinition(LaTeXML::Expandable->new(T_CS('\@currentID'),undef,$id));

  # Any scopes activated for previous value of this counter (& any nested counters) must be removed.
  # This may also include scopes activated for \label
  deactivateCounterScope($ctr);
  # And install the scope (if any) for this reference number.
  AssignValue(current_counter=>$ctr,'local');
  AssignValue('scopes_for_counter:'.$ctr => [$ctr.':'.ToString($v)],'local');
  $STATE->activateScope($ctr.':'.ToString($v));
  (refnum=>$v, id=>$id); }

# For UN-numbered units
sub refStepID {
  my($ctr)=@_;
  my $unctr = "UN$ctr";
  my $v = stepCounter($unctr);
  InstallDefinition(LaTeXML::Expandable->new(T_CS("\\\@$ctr\@ID"),undef,
					     Tokens(T_OTHER('x'),Explode(LookupValue('\c@'.$unctr)->valueOf))));
  my $id = Expand(T_CS("\\the$ctr\@ID"));
  InstallDefinition(LaTeXML::Expandable->new(T_CS('\@currentID'),undef,$id));
  (id=>$id); }

sub deactivateCounterScope {
  my($ctr)=@_;
#  print STDERR "Unusing scopes for $ctr\n";
 if(my $scopes = LookupValue('scopes_for_counter:'.$ctr)){
    map($STATE->deactivateScope($_), @$scopes); }
  foreach my $inner_ctr (@{LookupValue('nested_counters_'.$ctr) || []}){
    deactivateCounterScope($inner_ctr); }}

sub resetCounter {
  my($ctr)=@_;
  AssignValue('\c@'.$ctr => Number(0),'global'); 
  # and reset any within counters!
  if(my $nested = LookupValue("\\cl\@$ctr")){
    foreach my $c ($nested->unlist){
      resetCounter($c->toString); }}
  return;}

# For LaTeX documents, We want id's on para, as well as sectional units.
# However, para get created implicitly on Document construction, rather than
# explicitly during digestion (via a whatsit), we can't use the usual LaTeX counter mechanism.
sub number_para {
  my($document,$node,$whatsit)=@_;
  # Get prefix from first parent with an id.
  my(@parents)=$document->findnodes('ancestor::*[@id]',$node); # find 1st id'd parent.
  my $prefix= (@parents ? $parents[$#parents]->getAttribute('id')."." : '');

  # Get the previous number within parent; Worried about intervening elements around para's, but...
  my(@siblings)=$document->findnodes("preceding-sibling::ltx:para",$node);
  my $n=1;
  $n = $1+1  if(@siblings && $siblings[$#siblings]->getAttribute('id')=~/(\d+)$/);

  $node->setAttribute(id=>$prefix."p$n"); }

Tag('ltx:para',afterOpen=>\&number_para);
 
DefPrimitive('\newcounter{}[]',sub { shift; NewCounter(map($_ && $_->toString,@_)); return;});

DefPrimitive('\setcounter{}{Number}',sub {
  my($stomach,$ctr,$value)=@_;
  $ctr="\\c\@".$ctr->toString;
  AssignValue($ctr=>$value,'global');
  return});

DefPrimitive('\addtocounter{}{Number}',sub {
  my($stomach,$ctr,$value)=@_;
  $ctr="\\c\@".$ctr->toString;
  AssignValue($ctr=>LookupValue($ctr)->add($value),'global'); });

DefPrimitive('\stepcounter{}',   sub { stepCounter($_[1]->toString); return; });
DefPrimitive('\refstepcounter{}',sub { refStepCounter($_[1]->toString); return; });

DefExpandable('\value{}', sub {
  Explode(LookupValue('\c@'.$_[1]->toString)->valueOf);});
DefExpandable('\arabic{}',sub {
  Explode(LookupValue('\c@'.$_[1]->toString)->valueOf); });
DefExpandable('\roman{}', sub {
  roman(LookupValue('\c@'.$_[1]->toString)->valueOf); });
DefExpandable('\Roman{}', sub {
  Roman(LookupValue('\c@'.$_[1]->toString)->valueOf); });
DefExpandable('\alph{}',  sub {
  T_OTHER(chr(LookupValue('\c@'.$_[1]->toString)->valueOf+ord('a')-1));});
DefExpandable('\Alph{}',  sub {
  T_OTHER(chr(LookupValue('\c@'.$_[1]->toString)->valueOf+ord('A')-1));});
our @fnsymbols=("*", "\x{2020}", "\x{2021}", UTF(0xA7), UTF(0xB6),
		"\x{2225}", "**", "\x{2020}\x{2020}","\x{2021}\x{2021}");
DefExpandable('\fnsymbol{}',sub { 
		T_OTHER($fnsymbols[LookupValue('\c@'.$_[1]->toString)->valueOf-1]);});

#======================================================================
# C.8.5 The ifthen Package.
#======================================================================
# \ifthenelse
# and sundry conditionals...
#
# Yeah, maybe this'll get done someday....

#**********************************************************************
# C.9 Figures and Other Floating Bodies
#**********************************************************************

#======================================================================
# C.9.1 Figures and Tables
#======================================================================

# Note that, technically, the number is associated with the caption.
# (to allow multiple figures per figure environment?).
# We'll have to sort that out later....
DefConstructor('\caption[]{}',
	       "<ltx:caption>#2</ltx:caption>\n?#1(<ltx:toccaption>#1</ltx:toccaption>)");
DefEnvironment('{figure}[]',
	       "<ltx:figure id='#id' refnum='#refnum' ?#1(placement='#1')>#body</ltx:figure>",
	       properties=> sub { refStepCounter('figure') });
DefEnvironment('{figure*}[]',
	       "<ltx:figure id='#id' refnum='#refnum' ?#1(placement='#1')>#body</ltx:figure>",
	       properties=> sub { refStepCounter('figure') });
DefEnvironment('{table}[]',
	       "<ltx:table id='#id' refnum='#refnum' ?#1(placement='#1')>#body</ltx:table>",
	       properties=> sub { refStepCounter('table')} );
DefEnvironment('{table*}[]',
	       "<ltx:table id='#id' refnum='#refnum' ?#1(placement='#1')>#body</ltx:table>",
	       properties=> sub { refStepCounter('table')} );


DefPrimitive('\suppressfloats[]', undef);

NewCounter('topnumber');
DefMacro('\topfraction',"0.25");
NewCounter('bottomnumber');
DefMacro('\bottomfraction',"0.25");
NewCounter('totalnumber');
DefMacro('\textfraction',"0.25");
DefMacro('\floatpagefraction',"0.25");
NewCounter('dbltopnumber');
DefMacro('\dblfloatpagefraction',"0.25");
DefMacro('\dblfloatpagefraction',"0.25");
DefRegister('\floatsep',Glue(0));
DefRegister('\textfloatsep',Glue(0));
DefRegister('\intextsep',Glue(0));
DefRegister('\dblfloatsep',Glue(0));
DefRegister('\dbltextfloatsep',Glue(0));

#======================================================================
# C.9.2 Marginal Notes
#======================================================================

DefConstructor('\marginpar[]{}', "<ltx:note class='margin'>#2</ltx:note>");
DefPrimitive('\reversemarginpar',undef);
DefPrimitive('\normalmarginpar', undef);
DefRegister('\marginparpush',Dimension(0));

#**********************************************************************
# C.10 Lining It Up in Columns
#**********************************************************************

#======================================================================
# C.10.1 The tabbing Environment
#======================================================================

# NOTE: Do it!!

#======================================================================
# C.10.2 The array and tabular Environments
#======================================================================
# Tabular are a bit tricky in that we have to arrange for tr and td to
# be openned and closed at the right times; the only real markup is
# the & and \\. Also \multicolumn has to be cooperative.
# Along with this, we have to track which column specification applies
# to the current column.
# To simulate LaTeX's tabular borders & hlines, we simply add border
# attributes to all cells.  For HTML, CSS will be necessary to display them.
# [We'll ignore HTML's frame, rules and colgroup mechanisms.]

# The Core alignment support is in LaTeXML::Util::Alignment and in TeX.ltxml


DefEnvironment('{tabular}[] TabularPattern',
	       sub { my($document,$pos,$pattern,%props)=@_;
		     alignment($document,$props{body},$pattern,1); },
	       beforeDigest=>\&before_alignment,
	       afterDigest=>\&after_alignment,
	       mode=>'text');

DefEnvironment('{tabular*}{}[] TabularPattern', 
	       sub { my($document,$width,$pos,$pattern,%props)=@_;
		     alignment($document,$props{body},$pattern,1); },
	       beforeDigest=>\&before_alignment,
	       afterDigest=>\&after_alignment,
	       mode=>'text');
###Tag('ltx:tabular', afterClose=>\&guess_alignment_headers);

# Open, but don't close, so "&" can operate correctly.
# The td is already open, but we need to replace it's attributes.
DefConstructor('\multicolumn{Number} TabularPattern {}', \&alignment_multicol);

##DefConstructor('\hline',sub { alignment_hline($_[0],0); });

DefConstructor('\cline{}', sub {
  my($document,$cols)=@_;
  $cols = ToString($cols);
  my @cols=();
  while($cols=~ s/^,?(\d+)//){
    my $n = $1;
    push(@cols, ($cols =~ s/^-(\d+)// ? ($n-1..$1-1) : ($n-1))); }
  alignment_hline($document,0,@cols); });

DefConstructor('\vline',"");	# ???
DefRegister('\arraycolsep',Dimension(0));
DefRegister('\tabcolsep',Dimension(0));
DefRegister('\arrayrulewidth',Dimension(0));
DefMacro('\extracolsep{}','');
DefMacro('\arraystretch',"1");

#======================================================================
# Array and similar environments

DefEnvironment('{array}[] TabularPattern',sub {
   my($document,$pos,$colspec,%props)=@_;
   alignment($document,$props{body},$colspec,1,role=>'ARRAY'); },
	       requireMath=>1,
	       beforeDigest=>\&before_alignment,
	       afterDigest=>\&after_alignment);

#**********************************************************************
# C.11 Moving Information Around
#**********************************************************************

#======================================================================
# C.11.1 Files
#======================================================================
DefPrimitive('\nofiles',undef);

#======================================================================
# C.11.2 Cross-References
#======================================================================

# \label attaches a label to the nearest parent that can accept a label attribute
DefConstructor('\label Semiverbatim',
	       "^ label='#1'",
	       reversion=>'',
	       afterDigest=>sub {
		 my $label = $_[1]->getArg(1)->toString;
		 my $scope = 'label:'.$label;
		 if(my $ctr = LookupValue('current_counter')){
		   unshift(@{LookupValue('scopes_for_counter:'.$ctr)},$scope);
		   $STATE->activateScope($scope);
		   $_[0]->beginMode('text');
		   AssignValue('LABEL@'.$label, Digest(T_CS('\@currentlabel')),'global');
		   $_[0]->endMode('text'); }
		 return; });

DefConstructor('\ref Semiverbatim', "<ltx:ref labelref='#1'>&LookupValue('LABEL@#1')</ltx:ref>");
DefConstructor('\pageref Semiverbatim', "<ltx:ref labelref='#1'>&LookupValue('LABEL@#1')</ltx:ref>"); # Same??
#======================================================================
# C.11.3 Bibliography and Citation
#======================================================================

# NOTE: Not really complete, since I haven't dealt with bibliographies!
DefConstructor('\bibliography Semiverbatim',
	       "<ltx:bibliography files='#1'/>");
DefPrimitive('\bibliographystyle{}', undef);
DefEnvironment('{thebibliography}{}',
	       "<ltx:bibliography>"
	       . "<ltx:title>References</ltx:title>"
	       . "<ltx:biblist>#body</ltx:biblist>"
	       ."</ltx:bibliography>");

# NOTE: 
DefConstructor('\bibitem[] Semiverbatim',
	       "<ltx:bibitem key='#2'>?#1(<ltx:biblabel>#1</ltx:biblabel>)<ltx:bibblock>");
DefConstructor('\newblock',"<ltx:bibblock>");
Tag('ltx:bibitem', autoClose=>1);
Tag('ltx:bibblock', autoClose=>1);

# Here's an annoyance: The case of the keys have to agree in LaTeX,
# but can be different from the BibTeX!!!
# (bibtex matches case insensitively)
# Only sane solution is to downcase the keys in both places.
sub makecite {
  my($style,$show, $document,$phrase1,$phrase2,$ref)=@_;
  $ref = lc(ToString($ref)); $ref =~ s/\s//g;
  $document->openElement('ltx:cite', ref=>$ref,style=>$style, show=>$show);
  if(defined $phrase1 && defined $phrase2){
    $document->insertElement('ltx:citepre',$phrase1);
    $document->insertElement('ltx:citepost',$phrase2); }
  elsif(defined $phrase1){
    $document->insertElement('ltx:citepost',$phrase1); }
  $document->closeElement('ltx:cite'); }

# Most of this is really natbib style.
DefConstructor('\cite[][] Semiverbatim',       sub { makecite('parenthetic','all',@_); });
DefConstructor('\citet[][] Semiverbatim',      sub { makecite('intext','all',@_); });
DefConstructor('\citep[][] Semiverbatim',      sub { makecite('parenthetic','all',@_); });
DefConstructor('\citeauthor[][] Semiverbatim', sub { makecite('intext','author',@_); });
DefConstructor('\citeyear[][] Semiverbatim',   sub { makecite('intext','year',@_); });
DefConstructor('\citeyearpar[][] Semiverbatim',sub { makecite('parenthetic','year',@_); });


#======================================================================
# C.11.4 Splitting the input
#======================================================================
# LaTeX's \input is a bit different...
DefPrimitive('\input', sub {
  my($stomach)=@_;
  my $gullet=$stomach->getGullet;
  my $path;
  if($gullet->ifNext(T_BEGIN)){ # Read LaTeX style
    $path=Expand($gullet->readArg); }
  else {			# Read TeX style.
    my ($token,@tokens)=();
    while(($token = $gullet->readXToken) && ($token->getCatcode != CC_SPACE)){
      push(@tokens,$token); }
    $path = Tokens(@tokens); }
  # Special case HACK.  If filename ends .sty, we're probably really
  # trying to load a style file!  Look for .ltxml!
  $path = $path->toString if ref $path;
  if($path =~ s/\.sty$//){
    $gullet->input($path,['ltxml','sty']); }
  else {
    $gullet->input($path,['tex','']); }
  return; });

# Note that even excluded files SHOULD have the effects of their inclusion
# simulated by having read the corresponding aux file;
# But we're not bothering with that.
DefPrimitive('\include{}',sub { 
  my($stomach,$path)=@_;
  $path = $path->toString;
  my $table = LookupValue('including@only');
  $stomach->getGullet->input($path,['tex','']) if !$table || $$table{$path};
  return;});

DefPrimitive('\includeonly{}',sub {
  my($stomach,$paths)=@_;
  $paths = $paths->toString;
  my $table = LookupValue('including@only');
  AssignValue('including@only', $table = {}, 'global') unless $table;
  map( $$table{$_}=1, split(',',$paths));
  return; });

#Environment('filecontents','{}',?
#Environment('filecontents*','{}',?

DefPrimitive('\listfiles',undef);

#======================================================================
# C.11.5 Index and Glossary
#======================================================================
DefEnvironment('{theindex}', "<ltx:theindex>#body</ltx:theindex>");
DefPrimitive('\printindex',  undef);
DefPrimitive('\makeindex',   undef);
DefPrimitive('\makeglossary',undef);

# Format of Index entries:
#   \index{entry!entry}  gives multilevel index (handled)
# Each entry:
#   foo@bar  sorts on "foo" but prints "bar" (not handled yet)
# The entries can end with a |expression:
#   \index{...|(}    this page starts a range for foo (not handled)
#   \index{...|)}    this page ends a range (not handled)
#   \index{...|see{key}}  cross reference (not handled yet)
#      [I think makeindex just prints key, but we'll have to create an actual cross link!!!]
#   \index{...|textbf}  (etc) causes the number to be printed in bold!
#
# I guess the formula is that
#    \index{foo!whatever{pi}{pa}{po}}  => \whatever{pi}{pa}{po}{page}
# How should this get interpreted??

# A bit screwy, but....
# Expand \index{a!b!...} into \@index{\@indexphrase{a}\@indexphrase{b}...}
sub process_index_phrases {
  my($gullet,$phrases)=@_;
  my @expansion = (T_CS('\@index'),T_BEGIN);
  # Split the text into phrases, separated by "!"
  my @tokens = $phrases->unlist;
  push(@tokens,T_OTHER('!')) unless $tokens[$#tokens]->getString eq '!'; # Add terminal !
  my @phrase=();
  foreach my $tok (@tokens){
    if($tok->getString eq '!'){
      while(@phrase && ($phrase[$#phrase]->getString =~ /\s/)){ pop(@phrase); }
      push(@expansion,T_CS('\@indexphrase'),T_BEGIN,@phrase,T_END)
	if @phrase;
      @phrase=(); }
    elsif(!@phrase && ($tok->getString =~ /\s/)){}	# Skip leading whitespace
    else { 
      push(@phrase,$tok); }}
  push(@expansion,T_END);
  @expansion; }

DefExpandable('\index{}', \&process_index_phrases);

DefConstructor('\@index{}',"^<ltx:index>#1</ltx:index>", mode=>'text', reversion=>'');
DefConstructor('\@indexphrase{}',"<ltx:indexphrase>#1</ltx:indexphrase>");

# NOTE:
# DefConstructor('\glossary','{}',sub { ...
#======================================================================
# C.11.6 Terminal Input and Output
#======================================================================

DefPrimitive('\typeout{}',sub {
  my($stomach,$stuff)=@_;
  print STDERR ToString(Expand($stuff));
  return; });

#DefPrimitive('\typein[]{}',sub {
#  print STDERR ToString($_[2]); 
#  # Then setValue $_[1] to read ???
#	       });

#**********************************************************************
# C.12 Line and Page Breaking
#**********************************************************************

#======================================================================
# C.12.1 Line Breaking
#======================================================================
DefPrimitive('\linebreak[]',undef);
DefPrimitive('\nolinebreak[]',undef);
# \\ already defined
DefConstructor('\newline',"\n");
DefPrimitive('\-',undef);	# We don't do hyphenation.
# \hyphenation in Primitives.pm

DefPrimitive('\sloppy',undef);
DefPrimitive('\fussy',undef);
DefEnvironment('{sloppypar}','#body');

#======================================================================
# C.12.2 Page Breaking
#======================================================================
DefPrimitive('\pagebreak[]',undef);
DefPrimitive('\nopagebreak[]',undef);
DefPrimitive('\enlargethispage OptionalMatch:* {}',undef);

DefPrimitive('\clearpage',undef); # Could possibly mean something?
DefPrimitive('\cleardoublepage',undef);

DefPrimitive('\samepage',undef);

#**********************************************************************
# C.13 Lengths, Spaces and Boxes
#**********************************************************************

#####
#####
#  Complete to here
#  [except for NOTE'd entries, of course]
#####
#####

#======================================================================
# C.13.1 Length
#======================================================================
# \fill
# \stretch
# \newlength{cmd}
DefPrimitive('\newlength{Token}',sub {
  my($stomach,$cmd)=@_;
  DefRegister($cmd->toString,Dimension(0)); });
# \setlength{cmd}{len}
# Damn people sure can abuse TeX!
##DefPrimitive('\setlength{Token}{Dimension}',sub{
##  my($stomach,$cmd,$dimen)=@_;
##  LookupDefinition($cmd)->setValue($dimen);});
DefMacro('\setlength{}{}','#1#2\relax');
# \addtolength{cmd}{len}
## DefPrimitive('\addtolength{Token}{Dimension}',sub{
##   my($stomach,$cmd,$dimen)=@_;
##   my $register =  LookupDefinition($cmd);
##   $register->setValue($register->valueOf->add($dimen));});
DefMacro('\addtolength{}{}','\advance#1 #2\relax');
# \settowidth{cmd}{text}
# \settoheight{cmd}{text}
# \settodepth{cmd}{text}

# Assuming noone tries to get clever with figuring out the allocation of 
# numbers, these become simple DefRegister's
DefPrimitive('\newcount{Token}', sub { DefRegister($_[1]->toString,Number(0)); });
DefPrimitive('\newdimen{Token}', sub { DefRegister($_[1]->toString,Dimension(0)); });
DefPrimitive('\newskip{Token}',  sub { DefRegister($_[1]->toString,Glue(0)); });
DefPrimitive('\newmuskip{Token}',sub { DefRegister($_[1]->toString,MuGlue(0)); });
#DefPrimitive('\newbox{Token}',  sub { DefRegister($_[1]->toString,LaTeXML::Box->new()); });
DefPrimitive('\newtoks{Token}',  sub { DefRegister($_[1]->toString,Tokens()); });

#======================================================================
# C.13.2 Space
#======================================================================
DefPrimitive('\hspace OptionalMatch:* {}',undef);
DefPrimitive('\vspace OptionalMatch:* {}',undef);
# \addvspace{len}
# \hfill, \vfill

#======================================================================
# C.13.3 Boxes
#======================================================================
DefConstructor('\mbox{}',
	       "<ltx:text>#1</ltx:text>", mode=>'text');
DefConstructor('\makebox[Dimension][]{}',
	       "<ltx:text ?#1(width='#1') ?#2(pos='#2')>#3</ltx:text>",
	       mode=>'text');
DefConstructor('\fbox{}',
	       "<ltx:text framed='rectangle'>#1</ltx:text>", mode=>'text');
DefConstructor('\framebox[Dimension][]{}',
	       "<ltx:text ?#1(width='#1') ?#2(pos='#2') framed='rectangle'>#3</ltx:text>",
	       mode=>'text');
DefPrimitive('\newsavebox{Token}',sub { AssignValue('box'.$_[1]->toString, LaTeXML::List->new()); });
DefPrimitive('\sbox{Token}{}',sub {
   AssignValue('box'.$_[1]->toString, Digest($_[2])); return;});
DefPrimitive('\savebox{Token}[][]{}',sub {
   AssignValue('box'.$_[1]->toString, Digest($_[4])); return;});
DefEnvironment('{lrbox}{Token}','',
  afterDigest=>sub{ 
    my($stomach,$whatsit)=@_;
    AssignValue('box'.$whatsit->getArg(1)->toString, $whatsit->getProperty('body')); });
DefPrimitive('\usebox{Token}', sub { LookupValue('box'.$_[1]->toString);});

DefConstructor('\parbox[][Dimension]{}',
	       "<ltx:minipage ?#2(width='#2') ?#1(pos='#1') justified='yes'>#3</ltx:minipage>",
	       mode=>'text');
DefEnvironment('{minipage}[]{Dimension}',
	       "<ltx:minipage ?#2(width='#2') ?#1(pos='#1') justified='yes'>#body</ltx:minipage>",
	       mode=>'text');
DefConstructor('\rule[Dimension]{Dimension}{Dimension}', 
	       "<ltx:rule ?#1(raise='#1') width='#2' height='#3'/>");
DefConstructor('\raisebox{Dimension}[Dimension][Dimension]{}',
	       "<ltx:text raise='#1'>#4</ltx:text>");

#**********************************************************************
# C.14 Pictures and Color
#**********************************************************************
#======================================================================
# C.14.1 The picture environment
#======================================================================

#----------------------------------------------------------------------

sub ResolveReader {
  my ($itemtype) = @_;
  if(ref $itemtype eq 'CODE'){ $itemtype; }
  else {
    $itemtype = $itemtype->toString if ref $itemtype;
    LaTeXML::Parameters::checkReaderFunction('Read'.$itemtype); }}

sub ReadPair {
  my($gullet,$itemtype, $xarg, $yarg)=@_;
  my $itemreader;
  if(!$itemtype){ $itemreader=\&ReadFloat; }
  else { $itemreader = ResolveReader($itemtype); }
  if(!$itemreader){ Error("Cannot find reader for Pair items from $itemtype"); }
  $gullet->skipSpaces;
  if($gullet->ifNext(T_OTHER('('))){
    $gullet->readToken;  $gullet->skipSpaces;
    my $x = &$itemreader($gullet,$xarg);
    $gullet->skipSpaces; $gullet->readUntil(T_OTHER(',')); $gullet->skipSpaces;
    my $y = &$itemreader($gullet,$yarg);
    $gullet->skipSpaces; $gullet->readUntil(T_OTHER(')')); $gullet->skipSpaces;
    Pair($x,$y); }}

sub ReadFloat { $_[0]->skipSpaces; $_[0]->readFloat; }

sub ptValue { $_[0]?$_[0]->ptValue:undef; }

# This eases conversion of a Pair to 2 attributes.
sub PairAttr {
  my($pair,$xattr,$yattr)=@_;
  ($pair ? { $xattr=>ptValue($pair->getX), $yattr=>ptValue($pair->getY) } : {}); }

sub SimplePairAttr {
  my($pair,$xattr,$yattr)=@_;
  ($pair ? { $xattr=>$pair->getX, $yattr=>$pair->getY } : {}); }

#----------------------------------------------------------------------
# Picture parameters.
DefRegister('\unitlength', Dimension('1pt'));
DefPrimitive('\thinlines', sub { AssignValue('\@wholewidth',Dimension('0.4pt')); });
DefPrimitive('\thicklines', sub { AssignValue('\@wholewidth',Dimension('0.8pt')); });
DefRegister('\@wholewidth'=>Dimension('0.4pt'));
DefMacro('\linethickness{}', '\@wholewidth #1\relax');

DefPrimitive('\arrowlength{Dimension}', sub { AssignValue('\arrowlength',$_[1]); });

#----------------------------------------------------------------------
# Picture transformation support
sub slopeToPicCoord {
  my ($slope,$xlength) = @_;
  my($mx,$my)=($slope->getX,$slope->getY);
  my $s = $mx->sign();
  $xlength = picScale($xlength);
  Pair($xlength->multiply($s),
       $xlength->multiply(($s==0)?$my->sign():
			  $my->valueOf/$mx->absolute->valueOf)); }

sub picScale {
  ($_[0] ? $_[0]->multiply(LookupValue('\unitlength')): undef); }

sub picProperties {
  my (%props) = @_;
  if(($props{stroke}||'black') ne 'none'){
    $props{thick}=ptValue(LookupValue('\@wholewidth')); }
  if (my $arrowlength=LookupValue('\arrowlength')){
    $props{arrowlength}=ptValue($arrowlength); }
  %props; }

#----------------------------------------------------------------------
# the code
sub before_picture {
  Let(T_CS('\line'),     T_CS('\pic@line'));
  Let(T_CS('\vector'),   T_CS('\pic@vector'));
  Let(T_CS('\circle'),   T_CS('\pic@circle'));
  Let(T_CS('\oval'),     T_CS('\pic@oval'));
  Let(T_CS('\qbezier'),  T_CS('\pic@qbezier'));
  Let(T_CS('\makebox'),  T_CS('\pic@makebox'));
  Let(T_CS('\framebox'), T_CS('\pic@framebox'));
  Let(T_CS('\dashbox'),  T_CS('\pic@dashbox'));
  Let(T_CS('\frame'),    T_CS('\pic@frame'));
}

sub after_picture {}

# NOTE: Untex should prefix a setting of unitlength!!!
DefEnvironment('{picture} Pair OptionalPair',
	       "<ltx:picture %&SimplePairAttr(#size,width,height) fill='black' stroke='black'>"
	       . "#body"
	       ."</ltx:picture>",
	       beforeDigest=>\&before_picture,
	       properties=>sub { (unitlength=>LookupValue('\unitlength'),
				  picProperties(size=>picScale($_[1]))); },
	       afterDigest=>\&after_picture);

DefConstructor('\put Pair {}',
	       "<ltx:g transform='#pos'>#2</ltx:g>",
	       properties=>sub { pos=>'translate('.ptValue(picScale($_[1])).')'; });

DefConstructor('\pic@line Pair {Float}',
	       "<ltx:line points='#points' stroke-width='#thick'/>",
	       alias=>'\line',
	       properties=>sub { picProperties(points=>'0,0 '.slopeToPicCoord($_[1],$_[2])->ptValue()); });

DefConstructor('\pic@vector Pair {Float}',
	       "<ltx:line points='#points' stroke-width='#thick' terminators='->'"
	       . " arrowlength='#arrowlength'/>",
	       alias=>'\vector',
	       properties=>sub { picProperties(points=>'0,0 '.slopeToPicCoord($_[1],$_[2])->ptValue()); });

DefConstructor('\pic@circle OptionalMatch:* {Float}',
	       "<ltx:circle x='0' y='0' r='&ptValue(#radius)' fill='#fill' stroke='#stroke'"
	       .  " stroke-width='#thick'/>",
	       alias=>'\circle',
	       properties=>sub {
		 my ($stomach,$filled,$dia) = @_;
		 $dia=picScale($dia);
		 $dia=$dia->add(LookupValue('\@wholewidth')) unless $filled;
		 picProperties(radius=>$dia->multiply(0.5),
			       ($filled ? 'stroke' : 'fill')=>'none'); });

DefConstructor('\pic@oval [Float] Pair []',
	       "<ltx:rect %&PairAttr(#pos,x,y) %&PairAttr(#size,width,height) rx='&ptValue(#radius)'"
	       . "  fill='none' part='#3' stroke-width='#thick'/>",
	       alias=>'\oval',
	       properties=>sub{
		 my ($stomach,$r,$size,$part) = @_;
		 $size = picScale($size);
		 my $halfsize = $size->multiply(0.5);
		 my $pos = Pair($halfsize->getX->negate,$halfsize->getY->negate);
		 $r = ($r ? picScale($r) : Dimension('40pt'));
		 $r=$r->smaller($halfsize->getX->absolute);
		 $r=$r->smaller($halfsize->getY->absolute);
		 picProperties(size=>$size, pos=>$pos, radius=>$r); });

DefConstructor('\pic@qbezier [Number] Pair Pair Pair',
               "<ltx:bezier ?#1(displayedpoints='#1') points='&ptValue(#pt)' stroke-width='#thick' />",
	       alias=>'\qbezier',
	       properties=>sub {
		 picProperties(pt=>PairList(picScale($_[2]),picScale($_[3]),picScale($_[4]))); });

DefConstructor('\pic@makebox Pair []{}',
	       "<ltx:g %&PairAttr(#size,width,height) pos='#2'>#3</ltx:g>",
	       alias=>'\makebox',
	       properties=>sub { picProperties(size=>picScale($_[1])); });

DefConstructor('\pic@framebox Pair []{}',
	       "<ltx:rect x='0' y='0' %&PairAttr(#size,width,height) stroke-width='#thick' fill='none'/>"
	       . "<ltx:g %&PairAttr(#size,width,height) pos='#2'> #3 </ltx:g>",
	       alias=>'\framebox',
	       properties=>sub { picProperties(size=>picScale($_[1])); });

DefConstructor('\pic@dashbox {Float} Pair [] {}',
	       "<ltx:rect x='0' y='0' %&PairAttr(#size,width,height)"
	       . " stroke-width='#thick' stroke-dasharray='&ptValue(#dash)' fill='none'/>".
	       "<ltx:g %&PairAttr(#size,width,height) pos='#3'> #4 </ltx:g>",
	       alias=>'\dashbox',
	       properties=>sub { picProperties(dash=>picScale($_[1]),size=>picScale($_[2])); });

DefConstructor('\pic@frame{}',
	       "<ltx:g framed='yes' stroke-width='#thick'>#1</ltx:g>",
	       alias=>'\frame',
	       properties=>sub { picProperties(); });

our %alignments = (l=>'left',c=>'center',r=>'right');
DefConstructor('\shortstack[]{}',
	       "<ltx:vbox align='#align'><ltx:text>#2</ltx:text></ltx:vbox>",
	       bounded=>1,
	       beforeDigest=>sub{ DefConstructor("\\\\ OptionalMatch:* [Dimension]",
						 "</ltx:text><ltx:text>", alias=>"\\\\\n"); },
	       properties=>{ align=>sub { ($_[1] ? $alignments{ToString($_[0])} : undef); }},
	       mode=>'text');

DefMacro('\multiput Pair Pair {}{}',  sub {
	   my($gullet,$pos,$d,$nt,$body)=@_;
	   my($x,$y,$dx,$dy,$n)=map($_->toString, ($pos->getX,$pos->getY,$d->getX,$d->getY,$nt));
	   my @exp=();
	   for(my $i=0; $i<$n; $i++){
	     push(@exp,T_CS('\put'),T_OTHER('('),Explode($x),T_OTHER(','),Explode($y),T_OTHER(')'),
		  T_BEGIN,$body->unlist,T_END);
	     $x += $dx; $y+=$dy; }
	   @exp; });

sub add_picture_TeX {
  my($document,$node,$thing)=@_;
  if($thing && !$thing->getProperty('_added_tex')){
    local $LaTeXML::PICTURE_SCALE = Dimension('1pt')->valueOf;
    my $tex = ToString(Tokens($thing->revert));
    $tex = "\\setlength{\\unitlength}{".ToString($thing->getProperty('unitlength'))."}".$tex;
    $node->setAttribute(tex=>$tex); }
  $thing->setProperty('_added_tex',1); }

Tag('ltx:picture',   afterOpen=>\&add_picture_TeX);

Tag('ltx:g', afterClose=> sub {
      my ($document,$node) = @_;
      $node->parentNode->removeChild($node) unless $node->hasChildNodes; });

# \savebox -- already defined differntly in C.13 above ? 

#**********************************************************************
# C.15 Font Selection
#**********************************************************************
#======================================================================
# C.15.1 Changing the Type Style
#======================================================================
# Text styles.

# What about \f@family, etc....?
# These are not allowed in math.
DefConstructor('\mdseries', '',  forbidMath=>1, font=>{series=>'medium'});
DefConstructor('\bfseries', '',  forbidMath=>1, font=>{series=>'bold'});

DefConstructor('\rmfamily', '',  forbidMath=>1, font=>{family=>'serif'});
DefConstructor('\sffamily', '',  forbidMath=>1, font=>{family=>'sansserif'});
DefConstructor('\ttfamily', '',  forbidMath=>1, font=>{family=>'typewriter'});

DefConstructor('\upshape',  '', forbidMath=>1, font=>{shape=>'upright'});
DefConstructor('\itshape',  '', forbidMath=>1, font=>{shape=>'italic'});
DefConstructor('\slshape',  '', forbidMath=>1, font=>{shape=>'slanted'});
DefConstructor('\scshape',  '', forbidMath=>1, font=>{shape=>'smallcaps'});

DefConstructor('\normalfont', '', font=>{family=>'serif', series=>'medium', shape=>'upright'});

DefConstructor('\verbatim@font', '', font=>{family=>'typewriter', series=>'medium', shape=>'upright'});

# If these series or shapes appear in math, they revert it to roman, medium, upright (?)
DefConstructor('\textmd{}', "?#isMath(<ltx:text>#1</ltx:text>)(#1)", mode=>'text',
	       bounded=>1, font=>{series=>'medium'});
DefConstructor('\textbf{}', "?#isMath(<ltx:text>#1</ltx:text>)(#1)", mode=>'text',
	       bounded=>1, font=>{series=>'bold'});
DefConstructor('\textrm{}', "?#isMath(<ltx:text>#1</ltx:text>)(#1)", mode=>'text',
	       bounded=>1, font=>{family=>'serif'});
DefConstructor('\textsf{}', "?#isMath(<ltx:text>#1</ltx:text>)(#1)", mode=>'text',
	       bounded=>1, font=>{family=>'sansserif'});
DefConstructor('\texttt{}', "?#isMath(<ltx:text>#1</ltx:text>)(#1)", mode=>'text',
	       bounded=>1, font=>{family=>'typewriter'});

DefConstructor('\textup{}', "?#isMath(<ltx:text>#1</ltx:text>)(#1)", mode=>'text',
	       bounded=>1, font=>{shape=>'upright'});
DefConstructor('\textit{}', "?#isMath(<ltx:text>#1</ltx:text>)(#1)", mode=>'text',
	       bounded=>1, font=>{shape=>'italic'});
DefConstructor('\textsl{}', "?#isMath(<ltx:text>#1</ltx:text>)(#1)", mode=>'text',
	       bounded=>1, font=>{shape=>'slanted'});
DefConstructor('\textsc{}', "?#isMath(<ltx:text>#1</ltx:text>)(#1)", mode=>'text',
	       bounded=>1, font=>{shape=>'smallcaps'});

DefConstructor('\textnormal{}', '#1',
	       bounded=>1, font=>{family=>'serif',series=>'medium',shape=>'upright'});

DefPrimitive('\mathversion{}',sub {
  my($stomach,$version)=@_;
  $version = $version->toString;
  if($version eq 'bold'     ){ 
    AssignValue(mathfont=>LookupValue('mathfont')->merge(forcebold=>1), 'local'); }
  elsif($version eq 'normal'){ 
    AssignValue(mathfont=>LookupValue('mathfont')->merge(forcebold=>0), 'local'); }
  else { Fatal("Unknown math verison \"$version\""); }});

DefMacro('\newfont{}{}', '\font#1=#2\relax');

#======================================================================
# C.15.2 Changing the Type Size
#======================================================================
# Handled in Primitive.pm

#======================================================================
# C.15.3 Special Symbol
#======================================================================
# \symbol{num} ????

# These in LaTeX, but not in the book...
DefConstructor('\textdollar',"\$");
DefConstructor('\textemdash',"\x{2014}"); # EM DASH
DefConstructor('\textendash',"\x{2013}"); # EN DASH
DefConstructor('\textexclamdown',UTF(0xA1)); # INVERTED EXCLAMATION MARK
DefConstructor('\textquestiondown',UTF(0xBF));	# INVERTED QUESTION MARK
DefConstructor('\textquotedblleft',"\x{201C}"); # LEFT DOUBLE QUOTATION MARK
DefConstructor('\textquotedblright',"\x{201D}"); # RIGHT DOUBLE QUOTATION MARK
DefConstructor('\textquoteleft',"\x{2018}");     # LEFT SINGLE QUOTATION MARK
DefConstructor('\textquoteright',"\x{2019}");    # RIGHT SINGLE QUOTATION MARK
DefConstructor('\textsterling',UTF(0xA3));	 # POUND SIGN
DefConstructor('\textasteriskcentered',"*");
DefConstructor('\textbackslash',UTF(0x5C)); # REVERSE SOLIDUS
DefConstructor('\textbar',"|");
DefConstructor('\textbraceleft',"{");
DefConstructor('\textbraceright',"}");
DefConstructor('\textbullet',"\x{2022}");    # BULLET
DefConstructor('\textdaggerdbl',"\x{2020}"); # DOUBLE DAGGER
DefConstructor('\textdagger',"\x{2021}");    # DAGGER
DefConstructor('\textparagraph',UTF(0xB6)); # PILCROW SIGN
DefConstructor('\textperiodcentered',"\x{22C5}"); # DOT OPERATOR
DefConstructor('\textsection',UTF(0xA7));	      # SECTION SIGN
DefConstructor('\textcircled{}',"<ltx:text framed='circle'>#1</ltx:text>");
DefConstructor('\textless',"<");
DefConstructor('\textgreater',">");
DefConstructor('\textcopyright',UTF(0xA9)); # COPYRIGHT SIGN
DefConstructor('\textasciicircum',"^");
DefConstructor('\textasciitilde',"~");
DefConstructor('\textcompwordmark',""); # ???
DefConstructor('\textunderscore',"_");
DefConstructor('\textvisiblespace',"\x{2420}"); # SYMBOL FOR SPACE;  Not really the right symbol!
DefConstructor('\textellipsis',"\x{2026}"); # HORIZONTAL ELLIPSIS
DefConstructor('\textregistered',UTF(0xAE)); # REGISTERED SIGN
DefConstructor('\texttrademark',"\x{2122}");  # TRADE MARK SIGN
DefConstructor('\textsuperscript{}',"<ltx:text raise='0.5em'>#1</ltx:text>");
DefConstructor('\textordfeminine',UTF(0xAA)); # FEMININE ORDINAL INDICATOR
DefConstructor('\textordmasculine',UTF(0xBA)); # MASCULINE ORDINAL INDICATOR


#**********************************************************************
# Other stuff
#**********************************************************************
# Some stuff that got missed in the appendices ?

DefMacro('\@namedef{}','\expandafter\def\csname #1\endcsname');
DefMacro('\@nameuse{}','\csname #1\endcsname');

DefMacro('\@spaces','\space\space\space\space');
Let('\@sptoken',T_SPACE);
#======================================================================
# Internals used in Packages
DefMacro('\NeedsTeXFormat{}[]','');
DefMacro('\ProvidesClass{}[]','');
DefMacro('\ProvidesPackage{}[]','');
DefMacro('\ProvidesFile{}[]','');
DefMacro('\DeclareOption{}{}', sub {
  my($gullet,$option,$code)=@_;
  InstallDefinition(
       LaTeXML::Expandable->new(T_CS('\ds@'.$option->toString),undef,
		   Expand(Tokens($gullet->neutralizeTokens($code->unlist)))));
  (); });
DefMacro('\PassOptionsToPackage{}{}','');
DefMacro('\PassOptionsToClass{}{}','');
DefMacro('\CurrentOption','');
DefMacro('\OptionNotUsed','');
DefMacro('\ExecuteOptions{}', sub{
  my($gullet,$options)=@_;
  map(T_CS('\ds@'.$_),split(',',$options->toString)); });
DefMacro('\ProcessOptions','');

# What should be done with these? :
DefMacro('\AtEndOfPackage{}','');
DefMacro('\AtEndOfClass{}','');
DefMacro('\AtBeginDocument{}','');
DefMacro('\AtEndDocument{}','');

DefMacro('\@ehc',"I can't help");

sub make_message {
  my($cs,@args)=@_;
  join("\n",map(Expand($_)->toString,@args)); }

DefMacro('\@onlypreamble{}',''); # Don't bother enforcing this.

DefMacro('\GenericError{}{}{}{}', sub{ Fatal(make_message(@_)); });
DefMacro('\GenericWarning{}{}',   sub{ Warn(make_message(@_)); });
DefMacro('\GenericInfo{}{}{}{}',  sub{ print STDERR "Info: ".make_message(@_)."\n"; });

DefMacro('\PackageError{}{}{}',
  ' \GenericError{%
      (#1)\@spaces\@spaces\@spaces\@spaces
   }{%
      Package #1 Error: #2%
   }{%
      See the #1 package documentation for explanation.%
   }{#3}');
DefMacro('\PackageWarning{}{}',
   '\GenericWarning{%
      (#1)\@spaces\@spaces\@spaces\@spaces
   }{%
      Package #1 Warning: #2%
   }');
DefMacro('\PackageWarningNoLine{}{}',
  ' \PackageWarning{#1}{#2\@gobble}');
DefMacro('\PackageInfo{}{}',
  '\GenericInfo{%
      (#1) \@spaces\@spaces\@spaces
   }{%
      Package #1 Info: #2%
   }');
DefMacro('\ClassError{}{}{}',
  '\GenericError{%
      (#1) \space\@spaces\@spaces\@spaces
   }{%
      Class #1 Error: #2%
   }{%
      See the #1 class documentation for explanation.%
   }{#3}');
DefMacro('\ClassWarning{}{}',
  '\GenericWarning{%
      (#1) \space\@spaces\@spaces\@spaces
   }{%
      Class #1 Warning: #2%
   }');
DefMacro('\ClassWarningNoLine{}{}',
  '\ClassWarning{#1}{#2\@gobble}');
DefMacro('\ClassInfo{}{}',
  '\GenericInfo{%
      (#1) \space\space\@spaces\@spaces
   }{%
      Class #1 Info: #2%
   }');
DefMacro('\@latex@error{}{}',
  '\GenericError{%
      \space\space\space\@spaces\@spaces\@spaces
   }{%
      LaTeX Error: #1%
   }{%
      See the LaTeX manual or LaTeX Companion for explanation.%
   }{#2}');
DefMacro('\@latex@warning{}',
  '\GenericWarning{%
      \space\space\space\@spaces\@spaces\@spaces
   }{%
      LaTeX Warning: #1%
   }');
DefMacro('\@latex@warning@no@line{}',
  '\@latex@warning{#1\@gobble}');
DefMacro('\@latex@info{}',
   '\GenericInfo{%
      \@spaces\@spaces\@spaces
   }{%
      LaTeX Info: #1%
   }');
DefMacro('\@latex@info@no@line{}',
  '\@latex@info{#1\@gobble}');

#======================================================================

#======================================================================
# Some control structure from latex.ltx
# (amazing that it actually works!)
# How much of this control struture will I need?
RawTeX(<<'EOTeX');
\def\@nnil{\@nil}
\def\@empty{}
\def\@fornoop#1\@@#2#3{}
\long\def\@for#1:=#2\do#3{%
  \expandafter\def\expandafter\@fortmp\expandafter{#2}%
  \ifx\@fortmp\@empty \else
    \expandafter\@forloop#2,\@nil,\@nil\@@#1{#3}\fi}
\long\def\@forloop#1,#2,#3\@@#4#5{\def#4{#1}\ifx #4\@nnil \else
       #5\def#4{#2}\ifx #4\@nnil \else#5\@iforloop #3\@@#4{#5}\fi\fi}
\long\def\@iforloop#1,#2\@@#3#4{\def#3{#1}\ifx #3\@nnil
       \expandafter\@fornoop \else
      #4\relax\expandafter\@iforloop\fi#2\@@#3{#4}}

EOTeX

#======================================================================
DefMacro('\check@mathfonts','');
DefMacro('\fontsize{}{}','');
DefMacro('\math@fontsfalse','');
DefMacro('\math@fontstrue','');
DefMacro('\selectfont','');

#======================================================================
# Various symbols, accents, etc from Chapter 3 defined in Primitives.pm

#**********************************************************************
# Semi-Undocumented stuff
#**********************************************************************
DefMacro('\@ifnextchar Token {}{}', sub {
  my($gullet,$token,$if,$else)=@_;
  my $next = $gullet->readNonSpace;
  # NOTE: Not actually substituting, but collapsing ## pairs!!!!
  ( LaTeXML::Expandable::substituteTokens($token->equals($next) ? $if : $else),$next); });

DefMacro('\@ifundefined{}{}{}',sub {
  my($gullet,$name,$if,$else)=@_;
  my $cs = T_CS('\\'.ToString($name));
  (LookupMeaning($cs) ne $cs ? $if->unlist : $else->unlist); });

DefMacro('\IfFileExists{}{}{}', sub{
  my($gullet,$file,$if,$else)=@_;
  (pathname_find($file->toString,paths=>LookupValue('SEARCHPATHS')) ? $if->unlist : $else->unlist); });

DefMacro('\InputIfFileExists{}{}{}', sub{
  my($gullet,$file,$if,$else)=@_;
  if(pathname_find($file->toString,paths=>LookupValue('SEARCHPATHS'))){
    $gullet->input($file);
    $if->unlist; }
  else { $else->unlist; }});

#======================================================================
# Hair
DefPrimitive('\makeatletter',sub { AssignCatcode('@'=>CC_LETTER,'local'); });
DefPrimitive('\makeatother', sub { AssignCatcode('@'=>CC_OTHER, 'local'); });

#**********************************************************************
#**********************************************************************
# Sundry (is this ams ?)
DefConstructor('\textprime',UTF(0xB4)); # ACUTE ACCENT

#**********************************************************************
1;
