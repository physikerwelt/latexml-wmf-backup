# -*- CPERL -*-
# /=======================================================\ #
# |  xcolor.sty - Implementation for LaTeXML              | #
# |=======================================================| #
# | Part of LaTeXML : http://dlmf.nist.gov/LaTeXML/       | #
# | Copyright (c) 2006 arXMLiv group                      | #
# | Released under the GNU Public License                 | #
# |=======================================================| #
# | Author: Silviu Vlad Oprea                             | #
# | E-mail: s.oprea@jacobs-university.de                  | #
# \=======================================================/ #

# TODO: DOCUMENTATION

package LaTeXML::Package::Pool;
use strict;
use LaTeXML::Package;

RequirePackage('color');

# Options to determine target color model
# Monochrome needs to be handled. Others
# are to be ignored.
DeclareOption('natural',  sub { });
DeclareOption('rgb',  sub { });
DeclareOption('cmy',  sub { });
DeclareOption('cmyk',  sub { });
DeclareOption('hsb',  sub { });
DeclareOption('gray',  sub { });
DeclareOption('RGB',  sub { });
DeclareOption('HTML',  sub { });
DeclareOption('HSB',  sub { });
DeclareOption('Gray',  sub { });
DeclareOption('monochrome',  sub { });

# Irrelevant
DeclareOption('showerrors',  sub { });
DeclareOption('hideerrors',  sub { });

# Declare different sets of colors
DeclareOption('dvipsnames',  sub { });
DeclareOption('dvipsnames*',  sub { });
DeclareOption('svgnames',  sub { });
DeclareOption('svgnames*',  sub { });
DeclareOption('x11names',  sub { });
DeclareOption('x11names*',  sub { });

# Load colortbl package - TODO
DeclareOption('table',  sub { });

# Load pdfcolmk package - omitted
DeclareOption('fixpdftex',  sub { });

# Load hyperref - TODO
DeclareOption('hyperref',  sub { });

# Write prologue info to .xcp file for every color
# definition - irrelevant
DeclareOption('prologue',  sub { });

# Others - Irrelevant
DeclareOption('kernelfbox',  sub { });
DeclareOption('xcdraw',  sub { });
DeclareOption('noxcdraw',  sub { });
DeclareOption('fixinclude',  sub { });

ProcessOptions();

# Declaring constants
RawTeX('\def\rangeHsb{360}');
RawTeX('\def\rangetHsb{60,30;120,60;180,120;210,180;240,240}');
RawTeX('\def\rangeHSB{240}');
RawTeX('\def\rangeRGB{255}');
RawTeX('\def\rangeGray{15}');

# Storing the 147 SVG colors. This is needed for color mixing.
my %colors = (
  'black'          => '#000000', 'navy'             => '#000080',
  'mediumblue'     => '#0000CD', 'blue'             => '#0000FF',
  'green'          => '#008000', 'teal'             => '#008080',
  'deepskyblue'    => '#00BFFF', 'darkturquoise'    => '#00CED1',
  'lime'           => '#00FF00', 'springgreen'      => '#00FF7F',
  'aqua'           => '#00FFFF', 'midnightblue'     => '#191970',
  'lightseagreen'  => '#20B2AA', 'forestgreen'      => '#228B22',
  'darkslategray'  => '#2F4F4F', 'darkslategrey'    => '#2F4F4F',
  'mediumseagreen' => '#3CB371', 'turquoise'        => '#40E0D0',
  'steelblue'      => '#4682B4', 'darkslateblue'    => '#483D8B',
  'indigo'         => '#4B0082', 'darkolivegreen'   => '#556B2F',
  'cornflowerblue' => '#6495ED', 'mediumaquamarine' => '#66CDAA',
  'dimgray'        => '#696969', 'slateblue'        => '#6A5ACD',
  'slategrey'      => '#708090', 'slategray'        => '#708090',
  'lightslategrey' => '#778899', 'mediumslateblue'  => '#7B68EE',
  'chartreuse'     => '#7FFF00', 'aquamarine'       => '#7FFFD4',
  'purple'         => '#800080', 'olive'            => '#808080',
  'skyblue'        => '#87CEEB', 'lightskyblue'     => '#87CEFA',
  'darkred'        => '#8B0000', 'darkmagenta'      => '#8B008B',
  'darkseagreen'   => '#8FBC8F', 'lightgreen'       => '#90EE90',
  'darkviolet'     => '#9400D3', 'palegreen'        => '#98FB98',
  'yellowgreen'    => '#9ACD32', 'sienna'           => '#A0522D',
  'darkgray'       => '#A9A9A9', 'darkgrey'         => '#A9A9A9',
  'greenyellow'    => '#ADFF2F', 'paleturquoise'    => '#AFEEEE',
  'powderblue'     => '#B0E0E6', 'firebrick'        => '#B22222',
  'mediumorchid'   => '#BA55D3', 'rosybrown'        => '#BC8F8F',
  'silver'         => '#C0C0C0', 'mediumvioletred'  => '#C71585',
  'peru'           => '#CD853F', 'chocolate'        => '#D2691E',
  'lightgray'      => '#D3D3D3', 'lightgrey'        => '#D3D3D3',
  'orchid'         => '#DA70D6', 'goldenrod'        => '#DAA520',
  'crimson'        => '#DC143C', 'gainsboro'        => '#DCDCDC',
  'burlywood'      => '#DEB887', 'lightcyan'        => '#E0FFFF',
  'darksalmon'     => '#E9967A', 'violet'           => '#EE82EE',
  'lightcoral'     => '#F08080', 'khaki'            => '#F0E68C',
  'honeydew'       => '#F0FFF0', 'azure'            => '#F0FFFF',
  'wheat'          => '#F5DEB3', 'beige'            => '#F5F5DC',
  'mintcream'      => '#F5FFFA', 'ghostwhite'       => '#F8F8FF',
  'antiquewhite'   => '#FAEBD7', 'linen'            => '#FAF0E6',
  'oldlace'        => '#FDF5E6', 'red'              => '#FF0000',
  'magenta'        => '#FF00FF', 'deeppink'         => '#FF1493',
  'tomato'         => '#FF6347', 'hotpink'          => '#FF69B4',
  'darkorange'     => '#FF8C00', 'lightsalmon'      => '#FFA07A',
  'lightpink'      => '#FFB6C1', 'pink'             => '#FFC0CB',
  'peachpuff'      => '#FFDAB9', 'navajowhite'      => '#FFDEAD',
  'bisque'         => '#FFE4C4', 'mistyrose'        => '#FFE4E1',
  'papayawhip'     => '#FFEFD5', 'lavenderblush'    => '#FFF0F5',
  'cornsilk'       => '#FFF8DC', 'lemonchiffon'     => '#FFFACD',
  'snow'           => '#FFFAFA', 'yellow'           => '#FFFF00',
  'ivory'          => '#FFFFF0', 'white'            => '#FFFFFF',
  'darkgreen'      => '#006400', 'darkblue'         => '#00008B',
  'darkcyan'       => '#008B8B', 'mediumspringgreen' => '#00FA9A',
  'cyan'           => '#00FFFF', 'dodgerblue'        => '#1E90FF',
  'seagreen'       => '#2E8B57', 'limegreen'         => '#32CD32',
  'royalblue'      => '#4169E1', 'mediumturquoise'   => '#48D1CC',
  'cadetblue'      => '#5F9EA0', 'dimgrey'           => '#696969',
  'olivedrab'      => '#6B8E23', 'lightslategray'    => '#778899',
  'lawngreen'      => '#7CFC00', 'maroon'            => '#800000',
  'gray'           => '#808080', 'blueviolet'        => '#8A2BE2',
  'saddlebrown'    => '#8B4513', 'mediumpurple'      => '#9370DB',
  'darkorchid'     => '#9932CC', 'brown'             => '#A52A2A',
  'lightblue'      => '#ADD8E6', 'lightsteelblue'    => '#B0C4DE',
  'darkgoldenrod'  => '#B8860B', 'darkkhaki'         => '#BDB76B',
  'indianred'      => '#CD5C5C', 'tan'               => '#D2B48C',
  'thistle'        => '#D8BFD8', 'palevioletred'     => '#DB7093',
  'plum'           => '#DDA0DD', 'lavender'          => '#E6E6FA',
  'palegoldenrod'  => '#EEE8AA', 'aliceblue'         => '#F0F8FF',
  'sandybrown'     => '#F4A460', 'whitesmoke'        => '#F5F5F5',
  'fuchsia'        => '#FF00FF', 'orangered'         => '#FF4500',
  'coral'          => '#FF7F50', 'orange'            => '#FFA500',
  'gold'           => '#FFD700', 'moccasin'          => '#FFE4B5',
  'blanchedalmond' => '#FFEBCD', 'seashell'          => '#FFF5EE',
  'floralwhite'    => '#FFFAF0', 'lightyellow'       => '#FFFFE0',
  'salmon'         => '#FA8072', 'lightgoldenrodyellow' => '#FAFAD2');

# param:  string representing the name of the color
# return: the equivalent in hex model
sub GetColor {
  my ($color, $model) = map(ToString($_), @_);
  my $hex;
  # this color?
  if ($color eq '.') { return (LookupValue('color_.') || "#000000"); }
  # maybe some saved named color
  while (my $color_ = LookupValue('color_'.$color)) { $color = $color_; }
  # OK perhaps xcolor specific?
  if (!($color =~ /\#/)) {
    ($hex = $colors{lc $color})? return $hex : Error("color $color is undefined..."); }
  $color; }

# param:  color in hex model
# return: the complement
sub GetComplement {
  my $color = $_[0];
  my $complement = '#';
  my $group = qr/[0-9A-Z]{2}/;
  while ($color =~ s/($group)//) {
    $complement .= sprintf("%02X", 255-hex($1)); }
  $complement; }

# param:  two color in hex model and an int
# return: p% of the first color mixed with (1-p)% of the second
sub MixColors {
  my ($color1, $color2, $p) = @_;
  my $group = qr/[0-9A-Z]{2}/; # A group of 2 hex digits
  my $result = '#';
  $p /= 100;
  while ($color1 =~ s/($group)//) {
    my $temp = $1;
    $color2 =~ s/($group)//;
    $result .= sprintf("%02X", $p*hex($temp) + (1 - $p)*hex($1)); }
  $result; }

# Helping function for conversion from hex to hsb, as explained
# in the documentation of the XColor package, by Dr. Uwe Kern,
# http://mirror.informatik.uni-mannheim.de/pub/mirrors/tex-archive/macros/latex/contrib/xcolor/xcolor.pdf
sub Theta {
  my ($x,$y,$z,$u,$v) = @_;
  return (($u*($x - $z) + $v*($x - $y))/(6*($x - $z)), ($x - $z)/$x, $x); }

# Multiplies a color vector by a (subunitar) value
sub ColorMult {
  my ($color,$m) = @_;
  my $group = qr/[0-9A-Z]{2}/; # A group of 2 hex digits
  my $result = '#';
  while ($color =~ s/($group)//) {
    $result .= sprintf("%02X", $m*hex($1));
  }
  $result;
}

# param:  color in hex model
# return: color in hsb model
# XColor documentation, Dr. Uwe Kern
sub HEXToHsb {
  my $color = $_[0];
  my $group = qr/[0-9A-Z]{2}/;
  my $rangeRGB = ToString Expand Tokenize '\rangeRGB';
  $color =~ /#($group)($group)($group)/;
  my $r = hex($1)/$rangeRGB; my $g = hex($2)/$rangeRGB; my $b = hex($3)/$rangeRGB;
  my $i = 4 * ($r >= $g) + 2 * ($g >= $b) + ($b >= $r);
  my $h; my $s; my $v;
  if ($i == 1) { Theta($b, $g, $r, 3, 1); }
  elsif ($i == 2){ Theta($g, $r, $b, 1, 1); }
  elsif ($i == 3) { Theta($g, $b, $r, 3, -1); }
  elsif ($i == 4) { Theta($r, $b, $g, 5, 1); }
  elsif ($i == 5) { Theta($b, $r, $g, 5, -1); }
  elsif ($i == 6) { Theta($r, $g, $b, 1, -1); }
  elsif ($i == 7) { return (0, 0, $b); }
  else { Error("RGB values out of range..."); } }

#param:  hsb model
#return: tHsb model
sub hsbTotHsb {
  my ($h, $s, $b) = @_;
  my $rangeHsb = ToString(Expand Tokenize '\rangeHsb');
  my $rangetHsb = '0,0;'.ToString(Expand Tokenize '\rangetHsb')."\rangeHsb, rangeHsb";
  my $h_deg = $h * $rangeHsb;
  my $xn_1 = 240; my $yn_1 = 240; my $xn = 360; my $yn = 360;
  #while ($rangetHsb =~ s/(\d+),(\d+)// && $2 < $h_deg) {
  #  $xn_1 = $xn; $yn_1 = $yn; $xn = $1; $yn = $2;
  #}
  return ($xn_1 + (($xn - $xn_1)/($yn - $yn_1))*($h_deg - $yn_1), $s, $b);
}

# Checking the (CRAZY!) syntax for the <color> expression
# and computing the equivalent in the HTML model
# <color> -> <color_expr><func_expr1>...<func_exprn>
sub convert {
  my ($cs_name,$color) = map(ToString($_),@_);
  my $this_color;
  my $finalcolor;

    # <expr>       -> <prefix><ne_name><mix_expr><postfix>
    my $prefix     = qr/-/; #
    # If <name>    = . it refers to the this color
    #              = '' it refers to color white
    my $name       = qr/|[-]*\.|[-]*[a-zA-Z0-9]+/;
    my $ne_name    = qr/[-]*\.|[-]*[a-zA-Z0-9@]+/;
      # <mix_expr> -> !<pct1>!<name1>!...<pctn>!(<namen>)?
      # If <pct>   = '' or > 100 it is considered 100
      #            = '.' or < 0 it is considered 0
      my $pct      =  qr/(\d*\.?\d*|[+-]*\d+\.?\d*|[+-]*\d*\.?\d+)/;
    my $mix_expr   = qr/!$pct(!$name!$pct)*(!$name)?/;
      # <postfix>  -> |!!<plus>|!![<num>]
      my $plus     = qr/\++/;
      my $num      = qr/\d+/;
    my $postfix    = qr/!!($plus|\[$num\])/;
  my $expr         = qr/(?<prefix_>$prefix*)(?<ne_name_>$ne_name)
                     ((?<mix_expr_>$mix_expr)(?<postfix_>$postfix)?)?/x;

  # <ext_expr>       -> <core_model>,<div>:<expr1><dec1>;...;<exprk><deck>
  #                     | <core_model>:<expr1><dec1>;...;<exprk><deck>
    my $core_model   = qr/rgb|cmy|cmyk|hsb|gray/;
    my $div          = qr/[+-]*(\d*[1-9]+\d*(\.\d*)?|\d*\.\d*[1-9]+\d*)/;
    # PGF flaw here; decided to not allow div to be empty
    my $dec          = qr/[+-]*(\d*\.?\d*)/;
  my $ext_expr       = qr/(?<core_model_>$core_model)(,(?<div_>$div))?:
                       (?<exprs_>($expr|$name),$dec(;($expr|$name),$dec)*)/x;

  # <color_expr>     -> <name> | <expr> | <ext_expt>
  my $color_expr     = qr/$expr|$ext_expr/;

  # <func_expr>      -> ><function>,<arg1>,...,<argj>
    my $function     = qr/wheel|twheel/;
    my $angle        = $div;
    my $full_circle  = $div;
  my $func_expr      = qr/(?<func_expr_>>$function,($angle|$angle,$full_circle))/;

  # <color>          -> <color_expr><func_expr1>...<func_expri>
  my $color_regexp   = qr/(?<color_expr_>$color_expr)(?<func_expr_>($func_expr)*)/;

  if ($color =~ /^$color_regexp$/) {
    my $result;
    my $func_expr_ = $+{func_expr_};
    if (!defined $+{core_model_}) {
      my $prefix = $+{prefix_};
      my $name_ = $+{ne_name_};
      my $mix_expr_ = $+{mix_expr_};
      my $postfix_ = $+{postfix_};
      $name_ =~ s/--//g;
      my $result = GetColor $name_;
      if ($mix_expr_) {
        while ($mix_expr_ =~ s/^!([^!]*)(!([^!]*))?//x) {
          my $color = (!$3? 'white' : $3);
          my $factor = $1; $factor =~ s/--//;
          $factor = ($factor eq '' ? 100 : ($factor eq '.'? 0 : $factor));
          $factor < 0? $factor = 0 : ($factor > 100? $factor = 100 : 1); $color =~ s/--//g;
          $color = ($color =~ s/-//? GetComplement GetColor $color : GetColor $color);
          $result = MixColors($result, $color, $factor);
        }
      }
      if ($prefix) { $prefix =~ s/--//g;
        if ($prefix =~ m/-/) { $result = GetComplement $result; }
      }
      $finalcolor = $result;
    } else {
      my $div_ = 0;
      my $exprs_ = $+{exprs_};
      if ($+{div_}) { $div_ = $+{div_}; $div_ =~ s/--//g;}
      else {
        my $exprs_2 = $exprs_;
        while ($exprs_2 =~ s/(?<EXPR>$expr),(?<DEC>$dec)//) {
          my $dec_ = $+{DEC}; $dec_ =~ s/--//g;
          $div_ += ($dec_ eq '' || $dec_ eq '.'? 0: $dec_);
        }
      }
      # DOCUMENTATION!
      while ($exprs_ =~ s/(?<EXPR>$expr),(?<DEC>$dec)//) {
        my $dec_ = $+{DEC};
        my $expr_ = $+{EXPR};
        $dec_ =~ s/--//g;
	if (!$finalcolor) { $finalcolor = ColorMult(convert('temp', $expr_), $dec_/$div_); }
        else {
        $finalcolor = ColorMult(
                        MixColors(
                          $finalcolor,
                          ColorMult(convert('temp', $expr_), $dec_/$div_),
                        50),
                      2);
        }
      }
      # print $finalcolor;
    }
    if ($func_expr_) {
      my $h; my $s; my $b;
      while ($func_expr_ =~ s/>(wheel|twheel),($pct)(,($div))?//) {
        ($h, $s, $b) = HEXToHsb $finalcolor;
        my $rangeHsb = ToString Expand Tokenize '\rangeHsb';
        if ($1 eq 'wheel') {
          ($h = $h + $2/($5? $5 : $rangeHsb)) != 1? $h = $h - int($h): 1;
        } else {
          # Not working. Problem: rangetHsb while hsb between 0 and 1 still
          ($h, $s, $b) = hsbTotHsb($h, $s, $b);
          ($h = ($h + $rangeHsb*$2/($5? $5 : $rangeHsb))/$rangeHsb) != 1? $h = $h - int($h): 1;
	}
      }
      $finalcolor = ConvertColor('hsb',"$h,$s,$b"); #print $finalcolor;
    }
  } else {
    Error("syntax error in <color> expression $color...\n");
  }
  return $finalcolor;
}

# \colorlet[<type>]{<name>}[<num model>]{<color>}
# TODO convert color
DefPrimitive('\colorlet[]{}[]{}',
	        sub {
		 my ($stomach, @args) = @_;
		 my($type,$name,$num_model,$color) = map(ToString(Expand $_),@args);
                 my $hexrepr = convert($name,$color);
		 AssignValue('color_'.$name, $hexrepr);
                 # For pgf -> svg
                 $hexrepr =~ /#(..)(..)(..)/; # Should always be like this if it gets here
                 DefMacroI('\\\\color@'.$name, undef,
                           '\relax'.
                           '\relax'.
                           '{rgb '.(hex($1)/255).' '.(hex($2)/255).' '.(hex($3)/255).'}'.
                           '{rgb}'.
                           '{'.(hex($1)/255).','.(hex($2)/255).','.(hex($3)/255).'}');
                 return; });

# Defining macros for each color (this is what xcolor does and it is crucial for pgf->svg)
while (my ($key, $value) = each(%colors)) {
  $value =~ /#(..)(..)(..)/;
  DefMacroI('\\\\color@'.$key, undef,
            '\relax'.
            '\relax'.
            '{rgb '.(hex($1)/255).' '.(hex($2)/255).' '.(hex($3)/255).'}'.
            '{rgb}'.
            '{'.(hex($1)/255).','.(hex($2)/255).','.(hex($3)/255).'}');
}

# A stub. Should be redefined with respect to certain needs.
#Let(T_CS('\XC@mcolor'), T_CS('\relax'));

# \set@color sets 'this' color and XC@mcolor calls the
# system layer commands, if any.
DefMacro('\color[]{}', '\colorlet{.}[#1]{#2}\set@color\XC@mcolor');

DefConstructor('\set@color', "",
	       afterDigest=>sub {
                 my $color = LookupValue('color_.');
		 AssignValue('preambleTextcolor', $color) if LookupValue('inPreamble');
		 MergeFont(color=>$color);
		 return; });

#********************************************************************************
1;
