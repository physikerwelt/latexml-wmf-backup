# -*- CPERL -*-
# /=====================================================================\ #
# |  DLMF                                                               | #
# | Implementation for LaTeXML                                          | #
# |=====================================================================| #
# | Part of LaTeXML:                                                    | #
# |  Public domain software, produced as part of work done by the       | #
# |  United States Government & not subject to copyright in the US.     | #
# |---------------------------------------------------------------------| #
# | Bruce Miller <bruce.miller@nist.gov>                        #_#     | #
# | http://dlmf.nist.gov/LaTeXML/                              (o o)    | #
# \=========================================================ooo==U==ooo=/ #
package LaTeXML::Package::Pool;
use strict;
use LaTeXML::Package;
use XML::LibXML;
#**********************************************************************
# Document
#**********************************************************************
RelaxNGSchema("DLMF");

RequirePackage('DLMFsupport');

# If we get this, we're doing a "chapter"
DefPrimitive('\thischapter[]{}', sub {
  my($stomach,$chnum,$chcode)=@_;
  $chcode=ToString($chcode);
  $chnum= ($chnum ? ToString($chnum) : $chcode);

  AssignValue(DOCUMENTID=>$chnum,'global');
  DefMacroI('\thechapter',undef,$chnum); 
  DefMacroI('\thechapter@ID',undef,"C$chnum");
  DefMacroI('\@currentlabel',undef,$chcode);
  AssignValue("\\c\@chapter"=>$chnum,'global');
  AssignValue(current_counter=>'chapter','local');
  AssignValue(Chapter=>$chnum,'global');
  AssignValue(ChapterID=>"C$chnum",'global');
  AssignValue(ChapterLabel=>CleanLabel("ch:$chcode"),'global');
  Tag('ltx:chapter', afterOpen=>\&insertDLMFFrontMatter);
  Tag('ltx:chapter', afterClose=>\&extractSourceNotes);
});

sub LookupChapterMetaID { ToString(LookupValue('ChapterID')).".info"; }
  
DefEnvironment('{document}',
	       "?&LookupValue(Chapter)"
	       .  "(<ltx:chapter xml:id='&LookupValue(ChapterID)' refnum='&LookupValue(Chapter)'"
	       .         " labels='&LookupValue(ChapterLabel)'>"
	       .      "<ltx:metadata xml:id='&LookupChapterMetaID()'/>"
	       .      "#body"
	       .    "</ltx:chapter>)"
	       .  "(<ltx:document>#body</ltx:document>)",
	       beforeDigest=> sub { AssignValue(inPreamble=>0); 
				    Digest(T_CS('\@add@source@date')); 
				    Digest(T_CS('\@add@conversion@date')); },
	       afterDigest=> sub { $_[0]->getGullet->flush; return; });

sub insertDLMFFrontMatter {
  my($document)=@_;
  Digest(T_CS('\default@gallery'));
  insertFrontMatter($document); }

sub extractSourceNotes {
  my($doc)=@_;
  my $savenode = $doc->getNode;
  # Extract "source" notes from References \part (if any), and remove the part.
  my $ch = ToString(LookupValue('ChapterID'));
  if(my $pt = $doc->findnode("//ltx:part[child::ltx:title[text() = 'References']]")){
    $pt->parentNode->removeChild($pt); }
  else {
    Warn("No 'References' part found"); }
  $doc->setNode($savenode); }
#======================================================================
# Redefine to add a <metadata> block
# \@@section{type}[refnum][id][toctitle]{title}
DefConstructor('\\@@section{}[][][]{}',sub {
  my($document,$type,$refnum,$id,$toctitle,$title)=@_;
  $id = ToString($id);
  $document->openElement("ltx:".ToString($type),refnum=>$refnum,'xml:id'=>$id);
  $document->insertElement('ltx:title',$title);
  $document->insertElement('ltx:toctitle',$toctitle) if $toctitle;
  $document->insertElement('ltx:metadata',undef, 'xml:id'=>$id.".info");
},
  properties=>{refnum=>'#2',id=>'#3'},
  bounded=>1);

#======================================================================
# DLMF's Numbering scheme.
DefPrimitive('\subparagraph',sub { Error("Don't use \\subparagraph!!!"); });

NewCounter('chapter',      undef,       idprefix=>'C');
NewCounter('part',         'chapter',   idprefix=>'PT');
NewCounter('section',      'chapter',   idprefix=>'S');
NewCounter('subsection',   'section',   idprefix=>'SS');
NewCounter('subsubsection','subsection',idprefix=>'SSS');
NewCounter('paragraph',    'section',   idprefix=>'P');
NewCounter('sidebar',      'chapter',   idprefix=>'SB');

DefMacro('\thechapter',      'XX');
DefMacro('\thechapter@ID',   'XX');
DefMacro('\thepart',         '');
DefMacro('\thesection',      '\thechapter.\arabic{section}');
DefMacro('\thesubsection',   '\thesection(\roman{subsection})');
DefMacro('\thesubsubsection','\thesubsection(\roman{subsubsection})');
DefMacro('\theparagraph',    '');
DefMacro('\thesubparagraph', '');
DefMacro('\thesidebar',      '\thechapter.SB\arabic{sidebar}');

NewCounter('equation', 'section', idprefix=>'E');
NewCounter('equationgroup', 'section', idprefix=>'EG');
NewCounter('figure',   'section', idprefix=>'F');
NewCounter('table',    'section', idprefix=>'T');
# Note that these are ambiguous
DefMacro('\theequation','\thesection.\arabic{equation}');
DefMacro('\theequationgroup','');
DefMacro('\thefigure',  '\thesection.\arabic{figure}');
DefMacro('\thetable',   '\thesection.\arabic{table}');

NewCounter('@itemizei',   'section',    idprefix=>'I');
NewCounter('@itemizeii',  '@itemizei',  idprefix=>'I');
NewCounter('@itemizeiii', '@itemizeii', idprefix=>'I');
NewCounter('@itemizeiv',  '@itemizeiii',idprefix=>'I');
NewCounter('@itemizev',   '@itemizeiv', idprefix=>'I');
NewCounter('@itemizevi',  '@itemizev',  idprefix=>'I');

NewCounter('enumi',  '@itemizei',   idprefix=>'i');
NewCounter('enumii', '@itemizeii',  idprefix=>'i');
NewCounter('enumiii','@itemizeiii', idprefix=>'i');
NewCounter('enumiv', '@itemizeiv',  idprefix=>'i');
# A couple of more levels, since we use these for ID's!
NewCounter('enumv',  '@itemizev',   idprefix=>'i');
NewCounter('enumvi', '@itemizevi',  idprefix=>'i');

DefMacro('\theenumi',           '\arabic{enumi}');
DefMacro('\theenumii',          '\alph{enumii}');
DefMacro('\theenumiii',         '\roman{enumiii}');
DefMacro('\theenumiv',          '\Alph{enumiv}');

# Number these per section.
NewCounter('@XMARG', 'section',idprefix=>'XM');
NewCounter('@XMDECL','section',idprefix=>'XMD');

#**********************************************************************
# Frontmatter

DefPrimitive('\status{}', sub{ AssignValue(chapter_status=>$_[1]); });

DefMacro('\author[]{}',
 '\@add@frontmatter{ltx:creator}[role=author,idref=\ifx.#1.\else bio.#1\fi]{\@personname{#2}}');

DefConstructor('\@affiliation{}',"^ <ltx:contact role='affiliation'>#1</ltx:contact>");
DefMacro('\affiliation{}','\@add@to@frontmatter{ltx:creator}{\@affiliation{#1}}');

DefConstructor('\@email{}',"^ <ltx:contact role='email'>#1</ltx:contact>");
DefMacro('\email{}', '\@add@to@frontmatter{ltx:creator}{\@email{#1}}');

DefConstructor('\addCopyright{}{}','');#"<ltx:copyright year='#1'>#2</ltx:copyright>");

## DefMacro('\acknowledgements{}', '\@add@frontmatter{ltx:acknowledgements}{#1}');
# No, float it to the metadata.
DefConstructor('\acknowledgements{}', '^<ltx:acknowledgements>#1</ltx:acknowledgements>');

DefConstructor('\@galleryitem Semiverbatim Semiverbatim',
	       "<ltx:galleryitem labelref='#label' graphic='#2'/>",
	       properties=>sub { 
		 (ToString($_[1])
		  ? (label=>CleanLabel(ToString(Digest(T_CS('\thechapter'))).".".ToString($_[1]),
				       "SIDEBAR"))
		  : ()); });
DefMacro('\galleryitem Semiverbatim Semiverbatim',
#	 '\@add@to@frontmatter{ltx:gallery}{\@galleryitem{\ifx.#1.\else sb:\thechapter.#1\fi}{#2}}'
	 '\@add@to@frontmatter{ltx:gallery}{\@galleryitem{#1}{#2}}'
	.'\gdef\default@gallery{}');

DefMacro('\default@gallery',
	 '\galleryitem{}{}'
	 .'\galleryitem{}{}');
DefPrimitive('\gallerynote{}',undef); # Ignore
#**********************************************************************
# Backmatter.
# Ignore bibliography.
DefConstructor('\bibliography Semiverbatim','');

#**********************************************************************
# More environments.
DefEnvironment('{figuregroup}', "<ltx:figuregroup>#body</ltx:figuregroup>");
DefEnvironment('{figuregroup*}',"<ltx:figuregroup>#body</ltx:figuregroup>");

DefEnvironment('{tablegroup}', "<ltx:tablegroup>#body</ltx:tablegroup>");
DefEnvironment('{tablegroup*}',"<ltx:tablegroup>#body</ltx:tablegroup>");


#**********************************************************************
# Pseudo environments.
# Not really environments that transform to elements, since they
# don't necessarily nest properly with the more important document structure.
DefEnvironment('{onecolumn}', "<ltx:begin_onecolumn/>#body<ltx:end_onecolumn/>");
# Oh, what the heck, strip out printonly, and make electroniconly disappear!
DefEnvironment('{printonly}', "<ltx:printonly>#body</ltx:printonly>");
Tag('ltx:printonly', afterClose=>sub { $_[1]->getParentNode->removeChild($_[1]); });
DefMacro('\onlyprint{}', "");

DefEnvironment('{electroniconly}','#body');
DefMacro('\onlyelectronic{}',"#1"); # macro? constructor?

DefEnvironment('{sidebar}{}{}{}',
	       "<ltx:sidebar labels='#label' xml:id='#id'>"
	       . "<ltx:title>#2</ltx:title>"
	       . "<ltx:creator role='author'><ltx:personname>#3</ltx:personname></ltx:creator>"
	       . "#body"
	       ."</ltx:sidebar>",
	       beforeDigest=> sub { 
		 Let('\thesection','\thesidebar');
		 Let('\thesection@ID','\thesidebar@ID'); },
	       properties=> sub { (RefStepCounter('sidebar'),
				   label => sub { CleanLabel(ToString(Digest(T_CS('\thechapter'))).".".ToString($_[1]),
							     "SIDEBAR"); }); });

#**********************************************************************
# Metadata
DefConstructor('\note{}', "^<ltx:note>#1</ltx:note>", mode=>'text', reversion=>'');
DefConstructor('\origref[]{}', "^<ltx:origref ref='#2'>#1</ltx:origref>", mode=>'text', reversion=>'');

# New form of \index allows * (to hide from printed index)
DefMacro('\index OptionalMatch:*{}', sub { my($gullet,$star,$phrases)=@_;
						process_index_phrases($gullet,$phrases); });
# Also, redefine phrase to add a keyword to the metadata.
DefMacro('\@indexphrase[]{}','\@@indexphrase[#1]{#2}\@@indexkeyword[#1]{#2}');
DefConstructor('\@@indexphrase[]{}',
	       "<ltx:indexphrase key='#key'>#2</ltx:indexphrase>",
	       properties=>{key=>sub { CleanIndexKey($_[1]); }});
DefConstructor('\@@indexkeyword[]{}',
	       "^<ltx:indexkeyword key='#key'>#2</ltx:indexkeyword>",
	       properties=>{key=>sub { CleanIndexKey($_[1]); }});
Tag('ltx:indexkeyword',afterClose=>\&addIndexKey);

# NOTE: the "^" prefix allows these to float up out of math mode.
DefConstructor('\MarkDefn []{}{}',
	       "^<ltx:mark sortkey='#1' type='definition'>"
	       .  "<ltx:tag>#2</ltx:tag>"
	       .  "<ltx:text>#3</ltx:text>"
	       ."</ltx:mark>",
	       mode=>'text', reversion=>'');
DefConstructor('\MarkNotation []{}{}',
	       "^<ltx:mark sortkey='#1' type='notation'>"
	       .  "<ltx:tag>#2</ltx:tag>"
	       .  "<ltx:text>#3</ltx:text>"
	       ."</ltx:mark>",
	       mode=>'text', reversion=>'');

DefMacro('\indexdefn{}','\index{#1|textbf}'); # This'll work.
DefMacro('\indexodd{}',''); # Ignore
DefMacro('\indexnew{}','\index{#1}');
DefMacro('\indexlong{}','\index{#1}');
#**********************************************************************
# More Math environments.
# See als DLMFsupport

# If the equation contains a single aligned environment,
# We'd like to split it into several unnumbered aligned equations,
# and convert the equation into an equationgroup.
sub maybeResplitAMSAlign {
  my($document,$whatsit)=@_;
  if(my $equation = $document->getLastChildElement($document->getNode)){
    my $id = $equation->getAttribute('xml:id');
    my @maths = $document->findnodes('ltx:Math',$equation);
    if(scalar(@maths)==1){
      my @mnodes = $document->getChildElements($document->getFirstChildElement($maths[0]));
      if((scalar(@mnodes)==1) && ($document->getNodeQName($mnodes[0]) eq 'ltx:XMArray')
	 && (($mnodes[0]->getAttribute('name')||'') eq 'aligned')){
	$maths[0]->unbindNode;
	$equation->setNodeName('equationgroup');
	my $equationgroup = $equation;
	foreach my $mtr ($document->getChildElements($mnodes[0])){
	  # new equation for each row.
	  my $eqn  = addNewChildLate($document,$equationgroup,'ltx:equation');
	  $document->setAttribute($eqn,'xml:id'=>$document->modifyID($id."X"));
	  my @mtds = $document->getChildElements($mtr);
	  while(@mtds){
	    my $lhs = shift(@mtds)->firstChild; # content has an XMArg!
	    my $rhs = shift(@mtds)->firstChild;
	    my $cloned_lhs = cloneMath($document,$lhs);
	    my $cloned_rhs = cloneMath($document,$rhs);
	    my $lhs_box = $document->getNodeBox($lhs);
	    my $rhs_box = $document->getNodeBox($rhs);
	    my $fork = addNewChildLate($document,$eqn,'ltx:MathFork');
	    # Copy essentials to new node.
	    if(my $font = $lhs->getAttribute('_font')){
	      $fork->setAttribute(_font=>$font); }
	    if(my $box = $lhs->getAttribute('_box')){
	      $fork->setAttribute(_box=>$box); }
	    # Synthesize the main branch by combining the lhs & rhs.
	    my $math = addNewChildLate($document,$fork,'ltx:Math');
	    my @nodes = ($lhs->childNodes,$rhs->childNodes);

	    appendTeXfromBox($document,$math,$lhs_box);
	    appendTeXfromBox($document,$math,$rhs_box);

	    my $xmath = addNewChildLate($document,$math,'ltx:XMath');
	    map($xmath->appendChild($_), @nodes);
	    # Now, add a branch, with the lhs & rhs separated.
	    my $branch = addNewChildLate($document,$fork,'ltx:MathBranch');

	    my $ltd=addEquationgroupSplitEquationTD($document,$branch,'right',$cloned_lhs->childNodes);
	    my $rtd=addEquationgroupSplitEquationTD($document,$branch,'left',$cloned_rhs->childNodes);
	    appendTeXfromBox($document,$ltd->firstChild,$lhs_box);
	    appendTeXfromBox($document,$rtd->firstChild,$rhs_box);
      }}}}}}

# Append the TeX from the boxes to $node
sub appendTeXfromBox {
  my($document,$node,@boxes)=@_;
  if($node && @boxes){
    my $tex = $node->getAttribute('tex') || '';
    my $ctex =$node->getAttribute('content-tex') || $tex;
    local $LaTeXML::DUAL_BRANCH = 'presentation';
    $tex = join(' ',grep($_,$tex,map((s/^\s*\\displaystyle\s*//&&$_)||$_,map(UnTeX($_),@boxes))));
    $LaTeXML::DUAL_BRANCH = 'content';
    $ctex = join(' ',grep($_,$ctex,map(UnTeX($_),@boxes)));
    $tex =~ s/^\s*\\displaystyle\s*//; # strip leading \displaystyle
    $ctex =~ s/\\displaystyle\s*//g;   # strip all \displaystyle
    $node->setAttribute(tex=>'\displaystyle '.$tex);
    $node->setAttribute('content-tex'=>$ctex) unless $ctex eq $tex; }}

# equationmix contains several math environments, 
# Each math produces inline math, BUT we've set displaystyle in them!
# Let's try making equationmix like equationgroup.
# We can't easily tell (till later) how much space we've got to pack math's into,
# so let's just align them all on seperate rows.

DefMacro('\begin@equationmix@math','\[');
# This tries to read any trailing punctuation (actually, non \begin or \end!) and wrap as text.
DefMacro('\end@equationmix@math',sub {
  my($gullet)=@_;
  my($tok,@toks);
  while(($tok = $gullet->readToken)
	&& !($tok->equals(T_CS('\begin')) || $tok->equals(T_CS('\end')))){
    push(@toks,$tok); }
  $gullet->unread($tok) if $tok;
  while(@toks && ($toks[0]->getCatcode == CC_SPACE)){ shift(@toks); }
  while(@toks && ($toks[$#toks]->getCatcode == CC_SPACE)){ pop(@toks); }
  ((@toks ? (T_CS('\hbox'),T_BEGIN,@toks,T_END) : ()),
   T_CS('\]'));
 });

DefEnvironment('{equationmix@math}',
	       "<ltx:equation xml:id='#id'>"
	       . "<ltx:Math>"
	       .  "<ltx:XMath>"
	       .   "#body"
	       .  "</ltx:XMath>"
	       . "</ltx:Math>"
	       . "#insertion"
	       ."</ltx:equation>",
	       mode=>'display_math',
	       properties=> sub { RefStepID('equation') },
	       beforeDigest=> sub{ $_[0]->beginMode('display_math'); },
	       afterDigest=>sub {
		 my($stomach,$whatsit)=@_; # This is the whatsit for the \end!!!
		 $stomach->endMode('display_math');
		 my $gullet = $stomach->getGullet;
		 my($tok,@toks);
		 while(($tok = $gullet->readToken)
		       && !($tok->equals(T_CS('\begin')) || $tok->equals(T_CS('\end')))){
		   push(@toks,$tok); }
		 $gullet->unread($tok) if $tok;
		 while(@toks && ($toks[0]->getCatcode == CC_SPACE)){ shift(@toks); }
		 while(@toks && ($toks[$#toks]->getCatcode == CC_SPACE)){ pop(@toks); }
		 if(@toks){
		   $whatsit->setProperty(insertion=>Digest(Tokens(T_CS('\hbox'),T_BEGIN,@toks,T_END))); }
		 return; },
	       beforeConstruct=>sub {
		 $_[1]->setProperty(insertion=>$_[1]->getProperty('trailer')->getProperty('insertion')); });

DefEnvironment('{equationmix}[]', 
	       "<ltx:equationgroup xml:id='#id' refnum='#refnum'>"
	       . "<ltx:metadata xml:id='#id.info'/>"
	       . "#body"
	       ."</ltx:equationgroup>",
	       properties=> sub { RefStepCounter('equation') },
	       beforeDigest => sub {
		 Let(T_CS('\begin{math}'),T_CS('\begin{equationmix@math}'));
		 Let(T_CS('\end{math}'),T_CS('\end{equationmix@math}')); },
	       afterConstruct=>\&alignEquationgroupEquations);
DefEnvironment('{equationmix*}[]',
	       "?#nogroup(#body)(<ltx:equationgroup xml:id='#id'>#body</ltx:equationgroup>)",
	       properties=> sub { RefStepID('equationgroup') },
	       beforeDigest => sub {
		 Let(T_CS('\begin{math}'),T_CS('\begin{equationmix@math}'));
		 Let(T_CS('\end{math}'),T_CS('\end{equationmix@math}')); },
	       beforeConstruct=>sub {
		 my($document,$whatsit)=@_;
		 if($document->findnodes('ancestor-or-self::ltx:equationgroup',
					 $document->getNode)){
		   $whatsit->setProperty(nogroup=>1); }},
	       afterConstruct=>\&alignEquationgroupEquations);

# NOTE: I haven't handled the subequation case!!! (where equations themselves get numbered!)
DefEnvironment('{equationgroup}[]', 
	       "<ltx:equationgroup xml:id='#id' refnum='#refnum'>"
	       . "<ltx:metadata xml:id='#id.info'/>"
	       . "#body"
	       ."</ltx:equationgroup>",
	       properties=> sub { RefStepCounter('equation') },
	       afterConstruct=>\&alignEquationgroupEquations);
DefEnvironment('{equationgroup*}[]',
	       "<ltx:equationgroup xml:id='#id'>#body</ltx:equationgroup>",
	       properties=> sub { RefStepID('equationgroup') },
	       afterConstruct=>\&alignEquationgroupEquations);

# Since equationgroup aligns equations within them, we'd like to use the MathFork
# mechanism to provide aligned chunks.  But we're doing it backwards from
# eqnarray: We need to split each equation, rather than reassemble them.
# Presumably _top_ level relations are the right places (sum/integral limits are boxed).
# Even worse, we've got to attach TeX to the new Math nodes, derived from
# the boxes that created the equation. But the association between nodes & boxes
# is tricky; a single whatsit box can create multiple nodes.
 sub alignEquationgroupEquations {
   my($document,$whatsit)=@_;
   if(my $equationgroup = $document->getLastChildElement($document->getNode)){
     # Remove any intertext insertions that have ended up empty.
     foreach my $inter ($document->findnodes('ltx:text | ltx:block',$equationgroup)){
       $equationgroup->removeChild($inter) unless $inter->childNodes; }
     foreach my $equation ($document->findnodes('ltx:equation',$equationgroup)){
       my @maths=$document->findnodes('ltx:Math',$equation);
       if(scalar(@maths)==1){ 	# Single Math in equation

	 # First, we copy the math, and look for a relation.
	 my $copy = cloneMath($document,$maths[0]);
	 my @nodes = $copy->firstChild->childNodes; # nodes inside the XMath
	 my @boxes = $document->getNodeBox($maths[0])->getBody->unlist;
	 # move the copied nodes into the 1st td until we get a relation.
	 my (@lhs,@lhs_boxes);
	 while(@nodes && (($nodes[0]->nodeType != XML_ELEMENT_NODE)
			  || (($nodes[0]->getAttribute('role')||'') !~/^(RELOP|ARROW)/))){
	   push(@lhs,shift(@nodes)); }
	 if(@nodes){
	   my $relbox = $nodes[0]->getAttribute('_box');
	   while(@boxes && (("".$boxes[0]) ne $relbox)){
	     push(@lhs_boxes,shift(@boxes)); }}
	 else {
	   push(@lhs_boxes,@boxes); @boxes=(); }

	 # If we didn't find BOTH an appropriate relation node AND box, GIVE UP!!!
	 next unless scalar(@nodes) and scalar(@boxes);

	 # Otherwise, create an appropriate fork, add the whole equation,
	 # and add the lhs and rhs(s) into separate tr/td's
	 my $fork = addNewChildLate($document,$equation,'ltx:MathFork');
	 $equation->insertBefore($fork,$maths[0]);
	 $fork->appendChild($maths[0]); # Move Math into MathFork.
	 # Copy essentials to new node.
	 if(my $font = $maths[0]->getAttribute('_font')){
	   $fork->setAttribute(_font=>$font); }
	 if(my $boxid = $maths[0]->getAttribute('_box')){
	   $fork->setAttribute(_box=>$boxid); }
	 # Add a branch with a tr.
	 my $branch = addNewChildLate($document,$fork,'ltx:MathBranch');

	 do {
	   my(@rhs,@rhs_boxes);
	   push(@rhs,shift(@nodes)) if @nodes;
	   push(@rhs_boxes,shift(@boxes)) if @boxes;
	   while(@nodes && (($nodes[0]->nodeType != XML_ELEMENT_NODE)
			    || (($nodes[0]->getAttribute('role')||'') !~/^(RELOP|ARROW)/))){
	     push(@rhs,shift(@nodes)); }
	   if(@nodes){
	     my $relbox = $nodes[0]->getAttribute('_box');
	     while(@boxes && (("".$boxes[0]) ne $relbox)){
	       push(@rhs_boxes,shift(@boxes)); }}
	   else {
	     push(@rhs_boxes,@boxes); @boxes=(); }

	   my $tr     = addNewChildLate($document,$branch,'ltx:tr');
	   my $ltd = addEquationgroupSplitEquationTD($document,$tr,'right',@lhs);
	   my $rtd = addEquationgroupSplitEquationTD($document,$tr,'left',@rhs);
	   appendTeXfromBox($document,$ltd->firstChild,@lhs_boxes);
	   appendTeXfromBox($document,$rtd->firstChild,@rhs_boxes);
	   @lhs=(); @lhs_boxes=();
	 } while(@nodes);
       }}}
   return; }

# Add a new td to a manually split equation,
# assumes nodes are already appropriately cloned.
sub addEquationgroupSplitEquationTD {
  my($document,$tr,$align,@nodes)=@_;
  my $td    = addNewChildLate($document,$tr,'ltx:td');
  $td->setAttribute(align=>$align);
  if(@nodes){
    my $math  = addNewChildLate($document,$td,'ltx:Math');
    my $xmath = addNewChildLate($document,$math,'ltx:XMath');
    map($xmath->appendChild($_), @nodes); }
  $td; }

DefConstructor('\@constraint OptionalMatch:* {}',
	       "^<ltx:constraint hidden='?#1(true)(false)'>#2</ltx:constraint>",
	       mode=>'text', reversion=>'');

DefMacro('\constraint OptionalMatch:* [Default:,]{}',sub { 
  my($gullet,$starred,$punct,$constraint)=@_;
  if($starred){			# hidden.
    (T_CS('\@constraint'),T_OTHER('*'),T_BEGIN,$constraint->unlist,T_END); }
  else {
    $gullet->skipSpaces();
    my $ppunct = $gullet->readMatch(T_OTHER('.'),T_OTHER(','),T_OTHER(';')) || Tokens();
    ($punct->unlist, T_CS('\@constraint'), T_BEGIN,$constraint->unlist,$ppunct->unlist,T_END); }});

#**********************************************************************
# Redefine to include metadata block.

DefEnvironment('{figure}[]',
	       "<ltx:figure xml:id='#id' refnum='#refnum' ?#1(placement='#1')>"
	       . "<ltx:metadata xml:id='#id.info'/>"
	       . "#body"
	       ."</ltx:figure>",
	       properties=> sub { RefStepCounter('figure') });
DefEnvironment('{figure*}[]',
	       "<ltx:figure xml:id='#id' refnum='#refnum' ?#1(placement='#1')>"
	       . "<ltx:metadata xml:id='#id.info'/>"
	       . "#body"
	       ."</ltx:figure>",
	       properties=> sub { RefStepCounter('figure') });
DefEnvironment('{table}[]',
	       "<ltx:table xml:id='#id' refnum='#refnum' ?#1(placement='#1')>"
	       . "<ltx:metadata xml:id='#id.info'/>"
	       . "#body"
	       ."</ltx:table>",
	       properties=> sub { RefStepCounter('table')} );
DefEnvironment('{table*}[]',
	       "<ltx:table xml:id='#id' refnum='#refnum' ?#1(placement='#1')>"
	       . "<ltx:metadata xml:id='#id.info'/>"
	       . "#body"
	       ."</ltx:table>",
	       properties=> sub { RefStepCounter('table')} );

#**********************************************************************
1;
