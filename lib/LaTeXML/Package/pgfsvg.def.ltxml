# -*- CPERL -*-
# /=======================================================\ #
# |  pgf2svg driver - Implementation for LaTeXML          | #
# |=======================================================| #
# | Part of LaTeXML : http://dlmf.nist.gov/LaTeXML/       | #
# | Copyright (c) 2011 arXMLiv group                      | #
# | Released under the GNU Public License                 | #
# |=======================================================| #
# | Author: Silviu Vlad Oprea                             | #
# | E-mail: s.oprea@jacobs-university.de                  | #
# \=======================================================/ #

package LaTeXML::Package::Pool;
use strict;
use LaTeXML::Package;

#==========================================================================================
# Helpers
#==========================================================================================

# Universal property setter.
DefConstructor('\@svg@add{}{}', sub {
  my ($document, $attr, $value) = @_;
  $document -> setAttribute($document -> getNode, ToString($attr) => ToString($value));
});

# Playing with numbers
DefConstructor('\@svg@ptvalue{Dimension}', sub { $_[1] -> ptValue; });
DefConstructor('\@svg@valueof{Float}', sub { $_[1] -> valueOf; });

# Directly inserting into document
DefConstructor('\@svg@box{}', '#1');

my $pgf_svgpath = '';
my $pgf_buffer = '';
my $pgf_objectcount = 0;
my $pgf_scopecount = 0;
my $pgf_thescopecount = 0;
my $pgf_clipnext = 0;
my $pgf_pgfpicture = 0;
my $pgf_temp = 0;

# Helpers

# Input:  <dimension>
# Output: Numeric equivalent in pt
sub svgNum {
  my $dim = ToString($_[0]);
  my $isnegative = ($dim =~ s/-//);
  $dim = ToString Dimension $dim;
  $dim =~ s/pt//;
  if ($isnegative) { $dim = '-'.$dim; }
  return $dim; }

# Adds string to local buffer
# Input: string to add
sub addToSvgPath {
  $pgf_svgpath .= ToString($_[0]).' ';
}

sub addToBuffer {
  $pgf_buffer .= ToString($_[0]).' ';
}

# Adds <g> element to global buffer
# Input: arguments for the <g> element
sub svgGs {
#  if (LookupValue('pgf_pgfpicture')) { only for svg gs@color
    $pgf_buffer .= '<g '.$_[0].'>'."\n";
    $pgf_scopecount++;
    print STDERR "[svgGs] Scope count:$pgf_scopecount\n";
#  }
}

RawTeX('\newif\ifpgf@svg@clipnext\pgf@svg@clipnextfalse');
Let(T_CS('\tikz@textcolor'),T_CS('\relax'));
Let(T_CS('\nullfont'),T_CS('\relax'));
Tag("svg:g", autoClose => 0);
Tag("svg:foreignObject", autoClose => 0);
DefMacro('\pgfsys@typesetpicturebox{}', '\box#1');

DefMacroI('\begin{pgfpicture}', undef, '\begin{svgpicture}\pgfpicture');
DefMacroI('\end{pgfpicture}', undef, '\endpgfpicture\end{svgpicture}');

DefMacroI('\begin{tikzpicture}', undef, '\begin{svgpicture}\tikzpicture');
DefMacroI('\end{tikzpicture}', undef, '\endtikzpicture\end{svgpicture}');

DefConstructor('\@tikz@lower Dimension MoveableBox', "#2");
DefConstructor('\@tikz@raise Dimension MoveableBox', "#2");

DefConstructor('\myhboxa BoxSpecification HBoxContents',
               #"<ltx:text width='&REF(#1,to)' pad-width='&REF(#1,spread)' _noautoclose='1'>#2</ltx:text>",
               '#2',
               mode=>'text', bounded=>1,
               # Workaround for $ in alignment; an explicit \hbox gives us a normal $.
               # And also things like \centerline that will end up bumping up to block level!
               beforeDigest=>sub { reenterTextMode(); });

 DefConstructor('\myhbox BoxSpecification HBoxContents',
                '#2',
                 mode=>'text', bounded=>1,
                 # Workaround for $ in alignment; an explicit \hbox gives us a normal $.
                 # And also things like \centerline that will end up bumping up to block level!
                 beforeDigest=>sub { reenterTextMode(); });

DefEnvironment('{svgpicture}','<ltx:picture>'.
                                '<svg:svg version="1.1" width="#width" height="#height" '.
                                   'viewBox="#left #right #width_num #height_num">'.
                                  '<svg:g transform="translate(0,#maxy) '.
                                    'scale(1,-1) translate(0,#_miny)">'.
                                  '#body'.
                                  '</svg:g>'.
                                '</svg:svg>'.
                              '</ltx:picture>',
               afterDigest => sub {
                                    my ($stomach, $whatsit) = @_;
                                    my $maxy = LookupValue('\pgf@picmaxy') -> ptValue;
                                    my $miny = LookupValue('\pgf@picminy') -> ptValue;
                                    my $maxx = LookupValue('\pgf@picmaxx') -> ptValue;
                                    my $minx = LookupValue('\pgf@picminx') -> ptValue;
                                    my $width = $maxx - $minx;
                                    my $height = $maxy - $miny < 1? 1 : $maxy - $miny;
                                    $whatsit -> setProperty(maxy => $maxy);
                                    $whatsit -> setProperty(right => $miny);
                                    $whatsit -> setProperty(_miny => -$miny);
                                    $whatsit -> setProperty(left => $minx);
                                    $whatsit -> setProperty(width =>
                                      ($width < 1? 1 : $width).'pt');
                                    $whatsit -> setProperty(height => $height.'pt');
                                    $whatsit -> setProperty(width_num => $width);
                                    $whatsit -> setProperty(height_num => $height);
#Let(T_CS('\hbox'),T_CS('\myhboxa'));
                                    return;
                                  },
               beforeDigest => sub {

#                                     Let(T_CS('\lower'),T_CS('\@tikz@lower'));
#                                     Let(T_CS('\raise'),T_CS('\@tikz@raise'));
                                     return;
                                   },
               afterDigestBegin => sub {
Let(T_CS('\hbox'),T_CS('\myhbox'));
                                         AssignValue(pgf_pgfpicture => 1);
                                         AssignValue(pgf_SVGath => '');
                                       },
               beforeDigestEnd => sub {
                                        AssignValue(pgf_pgfpicture => 0);
                                      });

DefConstructor('\pgf@svg@hbox{Dimension}{Number}{}',
# '<svg:text
#     style="stroke:none"
#     transform="scale(1,-1) translate(#x,0)">#3</svg:text>',
               '<svg:switch>'.
                 '<svg:foreignObject transform="scale(1,-1) translate(#x,-10)" '.
                   'height="100%" width="100%" font-size="#2">'.
                 '#3'.
                 '</svg:foreignObject>'.
               '</svg:switch>',
               properties => { x => sub { $_[1] -> ptValue; } });

DefMacro('\pgfsys@hbox{}',
         '\pgf@x=.5\wd#1%
          \ifx\tikz@textcolor\relax%
          \else%
            \ifx\tikz@textcolor\pgfutil@empty%
              \pgfsetfillcolor{.}%
            \else%
              \pgfsetfillcolor{\tikz@textcolor}%
            \fi%
          \fi%
          \wd#1=0pt\ht#1=0pt\dp#1=0pt%
          \pgf@svg@hbox{\pgf@x}{10}{\myhbox{\box#1}}');

# DefConstructor('\pgfsys@hboxsynced{}', sub { return; });

# Path construction

sub appendToSVGPath {
  my($op, @pts) = @_;
  my $fragment = join(' ',$op, map($_->ptValue, @pts));
  if (my $prev = LookupValue('pgf_SVGpath')) {
    AssignValue(pgf_SVGpath => $prev.' '.$fragment);
  } else {
    AssignValue(pgf_SVGpath => $fragment);
  }
}

# \pgfsys@moveto{<x>}{<y>}
DefPrimitive('\pgfsys@moveto{Dimension}{Dimension}',
             sub {
                   appendToSVGPath('M', @_[1..$#_]);
                   return;
                 });

# \pgfsys@lineto{<x>}{<y>}
DefPrimitive('\pgfsys@lineto{Dimension}{Dimension}',
             sub {
                   appendToSVGPath('L', @_[1..$#_]);
                   return;
                 });

# \pgfsys@curveto{<x1>}{<y1>}{<x2>}{<y2>}{<x3>}{<y3>}
DefPrimitive('\pgfsys@curveto{Dimension}{Dimension}{Dimension}'.
                            '{Dimension}{Dimension}{Dimension}',
             sub {
                   appendToSVGPath('C', @_[1..$#_]);
                   return;
                 });

# \pgfsys@rect{<x>}{<y>}{<width>}{<height>}
DefMacro('\pgfsys@rect{}{}{}{}',
         '\pgfsys@moveto{#1}{#2}\svg@pgfsys@rect{#3}{#4}\pgfsys@closepath');

DefPrimitive('\svg@pgfsys@rect{Dimension}{Dimension}',
             sub {
                   appendToSVGPath('h', $_[1]);
                   appendToSVGPath('v', $_[2]);
                   appendToSVGPath('h', Dimension('-'.ToString($_[1])));
                   return;
                 }); # FIX -

DefPrimitive('\pgfsys@closepath',
             sub {
                   appendToSVGPath('Z');
                   return;
                 });

DefConstructor('\pgfsys@transformcm{Float}{Float}{Float}{Float}{Dimension}{Dimension}',
               '<svg:g transform="matrix(#c1,#c2,#c3,#c4,#x,#y)">',
               properties => {
                               c1 => sub { $_[1] -> valueOf; },
                               c2 => sub { $_[2] -> valueOf; },
                               c3 => sub { $_[3] -> valueOf; },
                               c4 => sub { $_[4] -> valueOf; },
                               x  => sub { $_[5] -> ptValue; },
                               y  => sub { $_[6] -> ptValue; }
                             },
               beforeDigest => sub {
                                     AssignValue(pgf_scopecount =>
                                       (LookupValue('pgf_scopecount') || 0) + 1, 'global');
                                   });

# Stroking, filling, and clipping

DefMacro('\pgf@svg@dopath{}',
         '\ifpgf@svg@clipnext%
            \pgf@svg@doclippedpath{#1}%
          \else%
            \pgf@svg@dounclippedpath{#1}%
          \fi%');

DefConstructor('\pgf@svg@doclippedpath{}',
               '<svg:clipPath id="pgfcp#objcount">'.
               '<svg:path id="pgfpath#objcount" d="#svgpath " />'.
               '</svg:clipPath>'.
               '<svg:use xlink:href="#pgfpath#objcount" style="#1" />'.
               '<svg:g clip-path="url(#pgfcp#objcount)">',
               properties => {
                               objcount => sub { LookupValue('pgf_objcount'); },
                               svgpath  => sub {
                                                 my $svgpath = (LookupValue('pgf_SVGpath') || '');
                                                 AssignValue(pgf_SVGpath => '');
                                                 return $svgpath;
                                               },
                               pgfcp => sub { '#pgfcp'; },
                               pgfpath => sub { '#pgfpath'; }
                             },
               beforeDigest => sub {
                                     RawTeX('\pgf@svg@clipnextfalse');
                                     AssignValue(pgf_objcount =>
                                       (LookupValue('pgf_objcount') || 0) + 1, 'global');
                                     AssignValue(pgf_scopecount =>
                                       LookupValue('pgf_scopecount') + 1, 'global');
                                   });

DefConstructor('\pgf@svg@dounclippedpath{}',
               '<svg:path d="#svgpath " style="#1" />',
               properties => { svgpath  => sub {
                                                 my $svgpath = (LookupValue('pgf_SVGpath') || '');
                                                 AssignValue(pgf_SVGpath => '');
                                                 return $svgpath;
                                               }
                             });

DefMacro('\pgfsys@stroke', '\pgf@svg@dopath{fill:none}');
DefMacro('\pgfsys@fill', '\pgf@svg@dopath{stroke:none}');
DefMacro('\pgfsys@fillstroke', '\pgf@svg@dopath{}');
DefMacro('\pgfsys@clipnext', '\pgf@svg@clipnexttrue');

DefMacro('\pgfsys@discardpath',
         '\ifpgf@svg@clipnext%
            \pgf@svg@discardpath@clip%
          \else%
            \pgf@svg@discardpath@noclip%
          \fi%');

DefPrimitive('\pgf@svg@discardpath@noclip',
             sub {
                   AssignValue(pgf_SVGpath => '');
                   return;
                 });

DefConstructor('\pgf@svg@discardpath@clip',
               '<svg:clipPath id="pgfcp#objcount">'.
                 '<svg:path d="#svgpath " />'.
               '</svg:clipPath>'.
               '<svg:g clip-path="url(#pgfcp#objcount)">',
               properties => {
                               objcount => sub { LookupValue('pgf_objcount'); },
                               svgpath  => sub {
                                                 my $svgpath = (LookupValue('pgf_SVGpath') || '');
                                                 AssignValue(pgf_SVGpath => '');
                                                 return $svgpath;
                                               },
                               pgfcp => sub { '#pgfcp'; }
                             },
               beforeDigest => sub {
                     RawTeX('\pgf@svg@clipnextfalse');
                     AssignValue(pgf_objcount =>
                       (LookupValue('pgf_objcount') || 0) + 1, 'global');
                     AssignValue(pgf_scopecount =>
                       (LookupValue('pgf_scopecount') || 0) + 1, 'global');
                     return;
                   });

# Graphic State Option System Commands

DefConstructor('\pgf@svg@begingroup',
               '<svg:g>',
               afterDigest => sub {
                                     AssignValue(pgf_scopecount =>
                                       (LookupValue('pgf_scopecount') || 0) + 1, 'global');print STDERR "Started color group ",LookupValue('pgf_scopecount'),"\n";
                                     return;
                                   });

DefConstructor('\pgf@svg@endgroup',
               '</svg:g>',
               afterDigest => sub {
                                     my $scope = LookupValue('pgf_scopecount');
                                     $scope?
                                       AssignValue(pgf_scopecount => $scope - 1, 'global'):
                                       Error("trying to close unopened group...");
                                     return;
                                   });

DefConstructor('\pgf@svg@setgroupattr{}{}',
               sub {
		     my ($document, $attr, $value) = @_;
                     # Add the given attribute to the nearest node that is allowed to have it.
                     # $document -> addAttribute(ToString($attr) => ToString($value));
                     $document -> setAttribute($document -> getNode, ToString($attr) => ToString($value));
                     return;
                   });

DefMacro('\pgfsys@setlinewidth{}',
         '\pgf@svg@begingroup\pgf@svg@setgroupattr{stroke-width}{#1}');
DefMacro('\pgfsys@setmiterlimit{}',
         '\pgf@svg@begingroup\pgf@svg@setgroupattr{stroke-miterlimit}{#1}');
DefMacro('\pgfsys@buttcap',
         '\pgf@svg@begingroup\pgf@svg@setgroupattr{stroke-linecap}{butt}');
DefMacro('\pgfsys@roundcap',
         '\pgf@svg@begingroup\pgf@svg@setgroupattr{stroke-linecap}{round}');
DefMacro('\pgfsys@rectcap',
         '\pgf@svg@begingroup\pgf@svg@setgroupattr{stroke-linecap}{square}');
DefMacro('\pgfsys@miterjoin',
         '\pgf@svg@begingroup\pgf@svg@setgroupattr{stroke-linejoin}{miter}');
DefMacro('\pgfsys@roundjoin',
         '\pgf@svg@begingroup\pgf@svg@setgroupattr{stroke-linejoin}{round}');
DefMacro('\pgfsys@beveljoin',
         '\pgf@svg@begingroup\pgf@svg@setgroupattr{stroke-linejoin}{bevel}');
DefMacro('\pgfsys@eoruletrue',
         '\pgf@svg@begingroup\pgf@svg@setgroupattr{fill-rule}{evenodd}');
DefMacro('\pgfsys@eorulefalse',
         '\pgf@svg@begingroup\pgf@svg@setgroupattr{fill-rule}{nonzero}');
# What if it is a .?
DefMacro('\pgfsys@setdash{}{}',
         '\pgf@svg@begingroup%
          \ifx$#1$%
            \pgf@svg@setgroupattr{stroke-dasharray}{none}%
          \else%
            \pgf@svg@setgroupattr{stroke-dasharray}{#1}%
          \fi%
          \pgf@svg@setgroupattr{stroke-dashoffset}{#2}%');

# Color System Commands

# Input: r red, g green, b blue, sf 'stroke'/'fill'
sub svgColorRgb {
  my ($r, $g, $b, $sf) = map(ToString($_), @_);
  return 'rgb('.($r*100).'%,'.($g*100).'%,'.($b*100).'%)';
}

# Input: c cyan, m magenta, y something, k something else, sf 'stroke'/'fill'
sub svgColorCmyk {
  my ($c, $m, $y, $k) = map(ToString($_), @_);
  return 'rgb('.((1 - $k)*$c + $k - 1)*(-100).'%'.
                ((1 - $k)*$m + $k - 1)*(-100).'%'.
                ((1 - $k)*$y + $k - 1)*(-100).'%'.')';
}

# Input: c cyan, m magenta, y something, sf 'stroke'/'fill'
sub svgColorCmy {
  my ($c, $m, $y) = map(ToString($_), @_);
  return 'rgb('.((1 - $c)*100).'%'.
                ((1 - $m)*100).'%'.
                ((1 - $y)*100).'%'.')';
}

# Input: g gray, sf 'stroke'/'fill'
sub svgColorGray {
  my ($g) = map(ToString($_), @_);
  print STDERR "I am HERE!\n\n";
  return 'rgb('.($g*100).'%'.
                ($g*100).'%'.
                ($g*100).'%'.')';
}

DefMacro('\XC@mcolor', '\ifpgfpicture\pgfsetcolor{.}\fi');

DefMacro('\pgf@svg@color@rgb{}{}{}',
         sub { T_OTHER(svgColorRgb($_[1], $_[2], $_[3])); });

DefMacro('\pgf@svg@color@cmyk{}{}{}{}',
         sub { T_OTHER(svgColorCmyk($_[1], $_[2], $_[3], $_[4])); });

DefMacro('\pgf@svg@color@cmy{}{}{}',
         sub { T_OTHER(svgColorCmy($_[1], $_[2], $_[3])); });

DefMacro('\pgf@svg@color@gray{}',
         sub { T_OTHER(svgColorGray($_[1])); });

DefMacro('\pgfsys@color@rgb@stroke{}{}{}',
         '\ifpgfpicture'.
           '\pgf@svg@begingroup\pgf@svg@setgroupattr{stroke}{\pgf@svg@color@rgb{#1}{#2}{#3}}'.
         '\fi');

DefMacro('\pgfsys@color@rgb@fill{}{}{}',
         '\ifpgfpicture'.
           '\pgf@svg@begingroup\pgf@svg@setgroupattr{fill}{\pgf@svg@color@rgb{#1}{#2}{#3}}'.
         '\fi');

DefMacro('\pgfsys@color@cmyk@stroke{}{}{}{}',
         '\ifpgfpicture'.
           '\pgf@svg@begingroup\pgf@svg@setgroupattr{stroke}{\pgf@svg@color@cmyk{#1}{#2}{#3}}'.
         '\fi');

DefMacro('\pgfsys@color@cmyk@fill{}{}{}{}',
         '\ifpgfpicture'.
           '\pgf@svg@begingroup\pgf@svg@setgroupattr{fill}{\pgf@svg@color@cmyk{#1}{#2}{#3}}'.
         '\fi');

DefMacro('\pgfsys@color@cmy@stroke{}{}{}',
         '\ifpgfpicture'.
           '\pgf@svg@begingroup\pgf@svg@setgroupattr{stroke}{\pgf@svg@color@cmy{#1}{#2}{#3}}'.
         '\fi');

DefMacro('\pgfsys@color@cmy@fill{}{}{}',
         '\ifpgfpicture'.
           '\pgf@svg@begingroup\pgf@svg@setgroupattr{fill}{\pgf@svg@color@cmy{#1}{#2}{#3}}'.
         '\fi');

DefMacro('\pgfsys@color@gray@stroke{}',
         '\ifpgfpicture'.
           '\pgf@svg@begingroup\pgf@svg@setgroupattr{stroke}{\pgf@svg@color@gray{#1}}'.
         '\fi');

DefMacro('\pgfsys@color@gray@fill{}',
         '\ifpgfpicture'.
           '\pgf@svg@begingroup\pgf@svg@setgroupattr{fill}{\pgf@svg@color@gray{#1}}'.
         '\fi');

#=========================================================================================
# Patterns
#=========================================================================================
# Specifying relevant tags
Tag("svg:pattern", autoOpen => 0, autoClose => 0);
Tag("svg:symbol", autoOpen => 0, autoClose => 0);
# Defining constructors

# \pgfsys@declarepattern{<name>}{<x1>}{<y1>}{<x2>}{<y2>}
#                       {<x step>}{<y step>}{<code>}{<flag>}
DefMacro('\@svg@aux@uncoloredpattern{}{}{}{}',
         '\@svg@start@pattern'
           .'\@svg@add{id}{pgfpat#1}'
           .'\@svg@add{patternUnits}{userSpaceOnUse}'
           .'\@svg@add{width}{\@svg@ptvalue{#3}}'
           .'\@svg@add{height}{\@svg@ptvalue{4}}'
           .'\@svg@start@symbol'
             .'\@svg@add{id}{pgfsym#1}'
             .'\@svg@box{#2}'
           .'\@svg@end@symbol');

DefConstructor('\@svg@aux@coloredpattern{}{}{Dimension}{Dimension}',
               '<svg:pattern '.
                 'id ="pgfpat#1" '.
                 'patternUnits="userSpaceOnUse" '.
                 'width="#xc" height="#yc" '.
                 '#2'.
               '</svg:pattern>',
               properties => {
                               xc => sub { $_[3] -> ptValue; },
                               xc => sub { $_[4] -> ptValue; }
                             });

DefMacro('\pgfsys@declarepattern{}{}{}{}{}{}{}{}{}',
         '\pgf@xa=#2\relax\pgf@ya=#3\relax%'.
         '\pgf@xb=#4\relax\pgf@yb=#5\relax%'.
         '\pgf@xc=#6\relax\pgf@yc=#7\relax%'.
         '\ifnum#9=1\relax%'.
           '\pgf@svg@coloredpattern{#1}{#8}{#6}{#7}%'.
         '\else%'.
           '\pgf@svg@uncoloredpattern{#1}{#8}{#6}{#7}%');

# \pgfsys@setpatternuncolored{<name>}{<red>}{<green>}{<blue>}
# DefConstructor('\pgfsys@setpatternuncolored{}{}{}{}',
#                '<svg:pattern id="pgfupat#objcount" xlink:href="#pgfpat#1">',
#                '<svg:g stroke="#rgbpattern" fill="#rgbpattern">'.
#                  '<use xlink:href="#pgfsym#1"/>'.
#                '</svg:g>'.
#                '</pattern>',
#                beforeDigest => sub {
#                                      AssignValue(pgf_objcount =>
#                                        (LookupValue('pgf_objcount') || 0) + 1, 'global');
#                                      return;
#                                    });


# \pgfsys@setpatterncolored{<name>}{<red>}{<green>}{<blue>}
DefMacro('\pgfsys@setpatterncolored{}',
         '\ifpgfpicture\pgf@svg@begingroup\pgf@svg@setgroupattr{fill}{url(\#pgfpat#1)}\fi');

# Scoping system commands
DefConstructor('\pgfsys@beginscope', '<svg:g>',
               beforeDigest => sub {
                                     my ($stomach) = @_;
                                     AssignValue(pgf_savescopecount =>
                                       (LookupValue('pgf_scopecount') || 0));
                                     $stomach -> bgroup;
                                     AssignValue(pgf_scopecount => 1, 'global');
                                     return;
                                   } );

DefConstructor('\pgfsys@endscope',
               sub {
                     my ($document, %props) = @_;
                     $document -> closeElement('svg:g') foreach (1..$props{scopecount});print "Closing ",$props{scopecount},"GROOOOOOOOUPS\n";
                     return;
                   },
               afterDigest => sub {
                     my ($document, $whatsit) = @_;
                     $whatsit -> setProperty(scopecount => LookupValue('pgf_scopecount'));
                     AssignValue(pgf_scopecount =>
                       (LookupValue('pgf_savescopecount') || 0), 'global');
print STDERR "Restored scope count to ",LookupValue('pgf_savescopecount');
                     return;
                   },
               beforeDigest => sub {
                                     my ($stomach) = $_[0];
                                     $stomach -> egroup;
                                     return;
                                   });

# Shading system commands
# DefConstructor('\do@vert@shading',
#   "<linearGradient id='#id' gradientTransform='rotate(90)>#specs</linearGradient>",
#   properties => { id    => LookupValue('current_shading_def{id}'),
#                   specs => LookupValue('currrent_shading_def{specs}'),
#                   x     => LookupValue('current_shading_def{x}'),
#                   y     => LookupValue('current_shading_def{y}')} );

#                '<rect '.
#                  'width="'.LookupValue('pgf_shading_y').'" '.
#                  'height="'.LookupValue('pgf_shading_x').'" '.
#                  'style="fill:url(#pgfsh'.$pgf_objectcount.');stroke:none"'.
#                '/>');

sub parseFunc {
  my $stops = ''; # result buffer
  my $specs = ToString $_[0];
  my $pct =  qr/([+-]*\d*\.\d*|[+-]*\d+\.?\d*|[+-]*\d*\.?\d+)/;
  my $color = qr/rgb\((?<poz>$pct(..)?)\)=\((?<r>$pct),(?<g>$pct),(?<b>$pct)\)/;
  my $space = qr/ */;
  my $endpos = 0;
  $specs =~ m/$color$/?
    $endpos = svgNum Dimension $+{poz}:
    Error('incomplete <color expression>');
  while ($specs =~ s/$color//) {
    $stops .= '<stop offset="'.(svgNum(Dimension $+{poz})/$endpos).'" '.
                 'stop-color="'.svgColorRgb($+{r}, $+{g}, $+{b}).'"/>'."\n";
  }
  AssignValue('pgf_shading_end', $endpos);
  return $stops; }

DefMacro('\pgfsys@shadinginsidepgfpicture{}', '#1');
DefMacro('\pgfsys@shadingoutsidepgfpicture{}','#1');

DefConstructor('\do@vert@shading{}', sub {
  my $name = 'pgf_shading_'.ToString($_[1]);
  addToBuffer('<linearGradient id="'.LookupValue($name)->{id}.'" '.
                 'gradientTransform="rotate(90)">'."\n".
                 LookupValue($name)->{specs}.
               '</linearGradient>'."\n");
  addToBuffer('<g transform="translate('.
                 -0.5*LookupValue($name)->{x}.','.
                 -0.5*LookupValue($name)->{y}.')">'."\n".
                 '<rect '.
                   'width="'.LookupValue($name)->{x}.'" '.
                   'height="'.LookupValue($name)->{y}.'" '.
                   'style="fill:url(#'.LookupValue($name)->{id}.');stroke:none"'.
                 '/>'."\n".
              '</g>'."\n") });

# \pgfsys@vertshading{<name>}{<height>}{<specification>}
DefPrimitive('\pgfsys@vertshading{}{}{}', sub {
  my ($stomach, $name, $height, $specs) = @_;
  $name = ToString($name);
  $pgf_objectcount++;
  AssignValue("pgf_shading_$name" =>
              { id    => 'pgfsh'.$pgf_objectcount,
                specs => parseFunc($specs),
                x     => svgNum(ToString Dimension ToString $height),
                y     => LookupValue('pgf_shading_end')
              },
              'global');
  DefMacroI('\@pgfshading'.$name.'!', undef, '\do@vert@shading{'.$name.'}');
  return; });

DefConstructor('\do@hori@shading{}', sub {
  my $name = 'pgf_shading_'.ToString($_[1]);
  addToBuffer('<linearGradient id="'.LookupValue($name)->{id}.'">'."\n".
                 LookupValue($name)->{specs}.
               '</linearGradient>'."\n");
  addToBuffer('<g transform="translate('.
                 -0.5*LookupValue($name)->{x}.','.
                 -0.5*LookupValue($name)->{y}.')">'."\n".
                 '<rect '.
                   'width="'.LookupValue($name)->{x}.'" '.
                   'height="'.LookupValue($name)->{y}.'" '.
                   'style="fill:url(#'.LookupValue($name)->{id}.');stroke:none"'.
                 '/>'."\n".
              '</g>'."\n") });

# \pgfsys@horishading{<name>}{<height>}{<specification>}
DefPrimitive('\pgfsys@horishading{}{}{}', sub {
  my ($stomach, $name, $height, $specs) = @_;
  $name = ToString($name);
  $pgf_objectcount++;
  AssignValue("pgf_shading_$name" =>
              { id    => 'pgfsh'.$pgf_objectcount,
                specs => parseFunc($specs),
                x     => LookupValue('pgf_shading_end'),
                y     => svgNum(ToString Dimension ToString $height)
              },
              'global');
  DefMacroI('\@pgfshading'.$name.'!', undef, '\do@hori@shading{'.$name.'}');
  return; });

DefConstructor('\do@radial@shading{}', sub {
  my $name = 'pgf_shading_'.ToString($_[1]);
  my $end_coord = LookupValue($name)->{end_coord}/16;
  addToBuffer('<radialGradient '.
                  'id="'.LookupValue($name)->{id}.'" '.
                  'fx="'.LookupValue($name)->{x}.'" '.
                  'fy="'.LookupValue($name)->{y}.'">'."\n".
                  LookupValue($name)->{specs}.
                 '</radialGradient>'."\n");

  addToBuffer('<g transform="translate('.-$end_coord.','.-$end_coord.')">'."\n".
                '<circle '.
                  'cx="'.$end_coord.'" '.
                  'cy="'.$end_coord.'" '.
                  'r="'.$end_coord.'" '.
                  'style="fill:url(#'.LookupValue($name)->{id}.');stroke:none"'.
                  '/>'."\n".
               '</g>'."\n"); });

# \pgfsys@radialshading{<name>}{<starting point>}{<specification>}
# TODO $endpos *= 16; # i.e. pt*65536 = sp; endpos = sp/4096;
DefPrimitive('\pgfsys@radialshading{}{}{}', sub {
  my ($stomach, $name, $starting, $specs) = @_;
  Digest($starting); # WRONG
  my $x = svgNum ToString Expand TokenizeInternal '\the\pgf@x';
  my $y = svgNum ToString Expand TokenizeInternal '\the\pgf@y';
  $name = ToString($name);
  $specs = parseFunc($specs);
  my $shading_end = LookupValue('pgf_shading_end')*16;
  $pgf_objectcount++;
  AssignValue("pgf_shading_$name" =>
              { id    => 'pgfsh'.$pgf_objectcount,
                specs => $specs,
                x     => $x*8/$shading_end + 0.5,
                y     => $y*8/$shading_end + 0.5,
                end_coord => $shading_end
              },
              'global');
  DefMacroI('\@pgfshading'.$name.'!', undef, '\do@radial@shading{'.$name.'}');
  return; });

# \pgfsys@functionalshading{<name>}{<lower_left_corner>}<upper_right_corner>
# {<type_4_function>}
DefConstructor('\pgfsys@functionalshading{}{}{}', sub {
  DefConstructor('\@pgfshading'.ToString($_[1]).'!', sub{
    AssignValue('pgf_shading_defs', '');
    AssignValue('pgf_shading_shape', '');
    RawTeX('\pgfpointorigin');
    AssignValue('pgf_shading_x', 0);
    AssignValue('pgf_shading_y', 0);
    return });
  return; });

# Transparency system commands

# \pgfsys@stroke@opacity{<value>}
DefConstructor('\pgfsys@stroke@opacity{}', sub {
  svgGs('stroke-opacity="'.ToString($_[1]).'"');
  return });

# \pgfsys@fill@opacity{<value>}
DefConstructor('\pgfsys@stroke@opacity{}', sub {
  svgGs('fill-opacity="'.ToString($_[1]).'"');
  return });

# \pgfsys@transparencygroupfrombox{<box>}
# \pgfsys@fadingfrombox{<name>}{<box>}
# \pgfsys@usefading<name>{<a>}{<b>}{<c>}{<d>}{<e>}{<f>}
# \pgfsys@definemask

# Reusable objects system commands

# \pgfsys@defobject{<name>}{<lower_left>}{<upper_right>}{<code>}
DefMacro('\pgfsys@defobject{}{}{}{}','\expandafter\def\csname #1\endcsname{#4}');

# \pgfsys@useobject{<name>}{<extra_code>}
DefMacro('\pgfsys@useobject{}{}','#2\csname #1\endcsname');

# Position tracking commands - irrelvant
# \pgfsys@markposition{<name>}
# \pgfsys@getposition{<name>}{<macro>}

# Invisibility system commands
# \pgfsys@(begin|end)invisible - they call \pgfsys@transformcm according to
# implementation form pgfsys.code.tex

# Internal conversion commands - does not need to be reimplemnted, see pgfsys.code.tex
# \pgf@sys@bp{<dimension>}


DefConstructor('\pgf@sys@svgpath',sub {
  open (SVG, '>picture.svg');
  print SVG '<svg xmlns="http://www.w3.org/2000/svg" xmlns:xlink="http://www.w3.org/1999/xlink" version="1.2" baseProfile="tiny">', "\n";
  print SVG '<g transform="translate(0, 0.0 ) scale(1,-1) translate(0,0.0 )">';
  print SVG '<g stroke="rgb(0.0%,0.0%,0.0%)">', "\n";
  print SVG '<g fill="rgb(0.0%,0.0%,0.0%)">', "\n";
  while($pgf_scopecount) {$pgf_buffer.="</g>\n"; $pgf_scopecount--;}; # REMOVE
  print SVG $pgf_buffer;
  print SVG "</g>\n</g>\n</g>\n";
  print SVG '</svg>';
  close (SVG);
  print "path: -->$pgf_svgpath<--\nbuffer: -->$pgf_buffer<--"; return Tokenize $pgf_svgpath; });
1;
