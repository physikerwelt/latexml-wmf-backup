# -*- CPERL -*-
# /=====================================================================\ #
# |  TeX                                                                | #
# | Core TeX Implementation for LaTeXML                                 | #
# |=====================================================================| #
# | Part of LaTeXML:                                                    | #
# |  Public domain software, produced as part of work done by the       | #
# |  United States Government & not subject to copyright in the US.     | #
# |---------------------------------------------------------------------| #
# | Bruce Miller <bruce.miller@nist.gov>                        #_#     | #
# | http://dlmf.nist.gov/LaTeXML/                              (o o)    | #
# \=========================================================ooo==U==ooo=/ #
package LaTeXML::Package::Pool;
use strict;
use LaTeXML::Package;
use Unicode::Normalize;
use XML::LibXML;
use LaTeXML::Util::Alignment;
use LaTeXML::Util::KeyVal;
no warnings 'redefine';

RegisterNamespace(ltx=>"http://dlmf.nist.gov/LaTeXML");

# Base ID prefixes everything.
DefMacro("\\\@empty",Tokens());

if(my $docid = LookupValue('DOCUMENTID')){
  DefMacro('\thedocument@ID',$docid); }
else {
  Let('\thedocument@ID','\@empty'); }
NewCounter('@XMARG','document',idprefix=>'XM');

#**********************************************************************
# CORE TeX; Built-in commands.
#**********************************************************************

#======================================================================
# Define parsers for standard parameter types.
DefParameterType('SkipSpaces', sub{$_[0]->skipSpaces; }, novalue=>1);
DefParameterType('Token',      sub{$_[0]->readToken; });
DefParameterType('XToken',     sub{$_[0]->readXToken; });
DefParameterType('Number',     sub{$_[0]->readNumber; });
DefParameterType('Dimension',  sub{$_[0]->readDimension; });
DefParameterType('Glue',       sub{$_[0]->readGlue; });
DefParameterType('MuDimension',sub{$_[0]->readMuDimension; });
DefParameterType('MuGlue',     sub{$_[0]->readMuGlue; });
DefParameterType('UntilBrace', sub{ 
  my($gullet)=@_;
  my $value=$gullet->readUntil(T_BEGIN);
  $gullet->unread(T_BEGIN);
  $value; });
DefParameterType('Match',      sub{shift->readMatch(@_); });
DefParameterType('Keyword',    sub{shift->readKeyword(@_); });
DefParameterType('Balanced',   sub{$_[0]->readBalanced; });
DefParameterType('Semiverbatim',sub{ $_[0]->readArg; }, semiverbatim=>1,
		 reversion=>sub { (T_BEGIN,$_[0]->revert,T_END); });
DefParameterType('OptionalSemiverbatim',sub{ $_[0]->readOptional; },
		 semiverbatim=>1, optional=>1,
		 reversion=>sub { ($_[0] ? (T_OTHER('['),$_[0]->revert,T_OTHER(']')) : ()); });

DefParameterType('Undigested',  sub { $_[0]->readArg; }, undigested=>1,
		reversion=>sub {  (T_BEGIN,$_[0]->revert,T_END); });
DefParameterType('UndigestedKey',  sub { $_[0]->readArg; }, undigested=>1);

DefParameterType('Variable', sub {
  my($gullet)=@_;
  my $token = $gullet->readXToken;
  my $defn = $token && LookupDefinition($token);
  if((defined $defn) && $defn->isRegister && !$defn->isReadonly){
    [$defn,$defn->readArguments($gullet)]; }
  else {
    Error("Attempt to use ".($token||'')." as a variable");
    undef; }});

DefParameterType('XUntilSpace', sub {
  my($gullet)=@_;
  my($token,@tokens)=();
  while(($token = $gullet->readXToken()) && ($token->getCatcode != CC_SPACE)){
    push(@tokens,$token); }
  Tokens(@tokens); });

# This reads a Box as needed by \raise, \lower, \moveleft, \moveright.
# Hopefully there are no issues with the box being digested
# as part of the reader???
DefParameterType('MoveableBox', sub{
  my($gullet)=@_;
  $gullet->skipSpaces;
  my ($box,@stuff) = $STATE->getStomach->invokeToken($gullet->readXToken);
  Fatal("A <box> was supposed to be here.".Stringify($box))
    unless $box && $box->isa('LaTeXML::Whatsit')
      && ($box->getDefinition->getCSName =~ /^(\\hbox|\\vbox||\\vtop)$/);
  $box; });

DefParameterType('BalancedParen', sub {
  my ($gullet) = @_;
  my $tok = $gullet->readXToken;
  if (ref $tok && $tok->toString eq '(') {
    $gullet->readUntil(T_OTHER(')'));
  } else {
    $gullet->unread($tok) if ref $tok;
    undef; }},
   reversion=> sub {
     (T_OTHER('('), $_[0]->revert, T_OTHER(')')); });

# In addition to the standard TeX Dimension, there are various LaTeX constructs
# (particularly, the LaTeX picture environment, and the various pstricks packages)
# that take a different sort of length.  They differ in two ways.
#   (1) They do not accept a comma as decimal separator 
#      (they generally use it to separate coordinates), and
#   (2) They accept a plain float which is scaled against a Dimension register.
#      Actually, there are two subcases:
#     (a) picture accepts a float, which is scaled against \unitlength
#     (b) pstricks accepts a float, and optionally a unit,
#        If the unit is omitted, it is relative to \psxunit or \psyunit.
# How to capture these ?
## DefParameterType('Length', sub {
##   my($gullet,$unit)=@_;

#**********************************************************************
# Expandable Primitives
# See The TeXBook, Ch. 20, Definitions (also called Macros) pp. 212--215
#**********************************************************************

#======================================================================
# Conditionals
#   Expand enough to determine true/false, then maybe skip
#   record a flag somewhere so that \else or \fi is recognized
#   (otherwise, they should signal an error)

# Skipping for conditionals
#   0 : skip to \fi
#  -1 : skip to \else, if any, or \fi
#   n : skip to n-th \or, if any, or \else, if any, or \fi.
sub skipConditionalBody {
  my($gullet,$nskips)=@_;
  my $fi_def   = LookupDefinition(T_CS('\fi'));
  my $or_def   = LookupDefinition(T_CS('\or'));
  my $else_def = LookupDefinition(T_CS('\else'));
  my $level=1;
  my $n_ors = 0;
  while(my $t= $gullet->readToken){
    if(defined(my $defn = LookupDefinition($t))){
      if($defn->isExpandable && $defn->isConditional){
	$level++; }
      elsif(($defn eq $fi_def) && (!--$level)){
	fiHandler($gullet); return; }
      elsif($level > 1){	# Ignore nested \else,\or
      }
      elsif(($defn eq $or_def) && (++$n_ors == $nskips)){
	return; }
      elsif(($defn eq $else_def) && $nskips){
	return; }}}
  Fatal("Conditional fell off end"); }

# NOTE: See Definition setting current_if_level before conditionals!

sub ifHandler   { 
  my($gullet,$boolean)=@_;
  AssignValue(if_level=>LookupValue('current_if_level'), 'global');
  skipConditionalBody($gullet,-1) unless $boolean; return; }

sub elseHandler { 
  my($gullet)=@_;
  my ($curr,$level) = (LookupValue('current_if_level'),LookupValue('if_level'));
  if(!$curr){
    Error("Stray \\else [$curr,$level]"); return; }
  elsif($curr > $level){
    (T_CS('\relax'),T_CS('\else')); }
  else {
    skipConditionalBody($gullet,0); return; }}

sub fiHandler {
  my($gullet)=@_;
  my ($curr,$level) = (LookupValue('current_if_level'),LookupValue('if_level'));
  if(!$curr){
    Error("Stray \\fi [$curr,$level]"); return; }
  elsif($curr > $level){
    (T_CS('\relax'),T_CS('\fi')); }
  else {
    AssignValue(current_if_level=>$curr-1, 'global'); 
    AssignValue(if_level=>$curr-1, 'global'); 
    return; }}

#======================================================================
# Should complain if we aren't actually evaluating an \if
DefExpandable('\else', \&elseHandler);
DefExpandable('\or',   \&elseHandler);
DefExpandable('\fi',   \&fiHandler);

sub compare {
  my($a,$rel,$b)=@_;
  if   ($rel->equals(T_OTHER('<'))){ $a < $b; }
  elsif($rel->equals(T_OTHER('='))){ $a == $b; }
  elsif($rel->equals(T_OTHER('>'))){ $a > $b; }
  else { Fatal("Non-relation token: ".Stringify($rel)." in comparison conditional"); }}

DefExpandable('\ifnum Number Token Number', 
	      sub { ifHandler($_[0],compare($_[1]->valueOf,$_[2],$_[3]->valueOf)); },
	      isConditional=>1);
DefExpandable('\ifdim Dimension Token Dimension',
	      sub { ifHandler($_[0],compare($_[1]->valueOf,$_[2],$_[3]->valueOf)); },
	      isConditional=>1);
DefExpandable('\ifodd Number',
	      sub { ifHandler($_[0],$_[1]->valueOf % 2); },
	     isConditional=>1);

# \ifvmode
# \ifhmode
DefExpandable('\ifmmode',sub { ifHandler($_[0],LookupValue('IN_MATH')); }, isConditional=>1);

# \ifinner
DefExpandable('\if XToken XToken',
	      sub { ifHandler($_[0],$_[1]->getCharcode == $_[2]->getCharcode); },
	      isConditional=>1);
DefExpandable('\ifcat XToken XToken', 
	      sub { ifHandler($_[0],$_[1]->getCatcode  == $_[2]->getCatcode); },
	      isConditional=>1);

# !! ????
DefExpandable('\ifx Token Token', sub {
  my($gullet,$token1,$token2)=@_;
  my $def1=LookupMeaning($token1);
  my $def2=LookupMeaning($token2);
  my $bool=0;
  if(defined $def1 != defined $def2){	       # Don't both have defs or not have defs
    $bool=0; }
  elsif(!defined $def1 && !defined $def2){	# Neither have defs
    $bool = $_[1]->equals($_[2]); }		# compare the tokens themselves.
  elsif($def1->equals($def2)){	# Same defn (hopefully covers same primitives ???)
    $bool = 1; }		# But what about same \chardefs, etc....
  ifHandler($gullet,$bool); },
	      isConditional=>1);

# Kinda rough: We don't really keep track of modes as carefully as TeX does.
# We'll assume that a box is horizontal if there's anything at all,
# but it's not a vbox (!?!?)
sub classify_box {
  my($boxnum)=@_;
  my $box = LookupValue('box'.$boxnum->valueOf);
  if(!$box){ undef; }
  elsif($box->isa('LaTeXML::Whatsit') && ($box->getDefinition eq LookupDefinition(T_CS('\vbox')))){
    'vbox'; }
  else {
    'hbox'; }}

DefExpandable('\ifvoid Number', sub { ifHandler($_[0],!classify_box($_[1]));}, isConditional=>1);
DefExpandable('\ifhbox Number', sub { ifHandler($_[0],classify_box($_[1]) eq 'hbox');}, isConditional=>1);
DefExpandable('\ifvbox Number', sub { ifHandler($_[0],classify_box($_[1]) eq 'vbox');}, isConditional=>1);

# Implementing this assumes we've got some notion of file numbers!!!
# \ifeof Number

DefExpandable('\iftrue', sub { ifHandler($_[0],1); }, isConditional=>1);
DefExpandable('\iffalse',sub { ifHandler($_[0],0); }, isConditional=>1);

DefExpandable('\ifcase Number', sub {
  my($gullet,$num)=@_;
  AssignValue(if_level=>LookupValue('current_if_level'), 'global');
  $num = $num->valueOf;
  if($num > 0){ 
    skipConditionalBody($gullet,$num); }
  return; },
  isConditional=>1);

#======================================================================

DefPrimitive('\relax',undef);
DefExpandable('\number Number',       sub { Explode($_[1]->valueOf); });

#======================================================================

DefExpandable('\romannumeral Number', sub { roman($_[1]->valueOf); });
DefExpandable('\string Token ',        sub { Explode($_[1]->getString); });
DefExpandable('\jobname',Tokens()); # Set to the filename by initialization

DefExpandable('\fontname', sub { Explode("fontname not implemented"); });

DefExpandable('\meaning Token',sub {
  my($gullet,$tok)=@_;
  my $meaning = LookupMeaning($tok);
  Explode(defined $meaning ? $meaning : 'undefined'); });

DefExpandable('\csname',sub {
  my($gullet)=@_;
  my($token,@toks)=();
  while(($token = $gullet->readXToken()) && ($token->getString ne '\endcsname')){
    push(@toks,$token); }
  $token = T_CS("\\".Tokens(@toks)->toString);
  Let($token, T_CS('\relax')) unless defined LookupMeaning($token);
  $token;  });

DefPrimitive('\endcsname', sub { Fatal("Extra \csname"); });

DefExpandable('\expandafter Token Token',sub {
  my($gullet,$tok,$xtok)=@_;
  my $defn;
  if(defined($defn=LookupDefinition($xtok)) && $defn->isExpandable){
    ($tok,$defn->invoke($gullet)); } # Expand $xtok ONCE ONLY!
  else {
    ($tok,$xtok); }});

# Insert magic token that Gullet knows not to expand the next one.
DefExpandable('\noexpand',sub { Token('',CC_NOTEXPANDED); });

DefExpandable('\topmark',        sub { return; });
DefExpandable('\firstmark',      sub { return; });
DefExpandable('\botmark',        sub { return; });
DefExpandable('\splitfirstmark', sub { return; });
DefExpandable('\splitbotmark',   sub { return; });

DefExpandable('\input XUntilSpace',sub {
  my($gullet,$path)=@_;
  $path = $path->toString;
  $path = $1 if $path =~ /^\{(.*)\}$/; # just in case
  if(my $file = FindFile($path)){
    $gullet->input($file); }
  else {
    $STATE->noteStatus(missing=>$path);
    Error("Cannot find file $path "
	  ." in paths ".join(', ',@{$STATE->lookupValue('SEARCHPATHS')})); }
  return; });

DefExpandable('\endinput',sub { $_[0]->closeMouth(1); return; });

# \the<internal quantity>
DefExpandable('\the Variable',sub {
  my($gullet,$variable)=@_;
  return () unless $variable;
  my($defn,@args) = @$variable;
  my $type = $defn->isRegister;
  if(!$type){ 
    Error("You can't use ".ToString($defn->getCS)." after \\the"); return (); }
  my $value = $defn->valueOf(@args);
  my @tokens = ($type eq 'any' ? $value->unlist : Explode($value->toString));
  if($LaTeXML::NOEXPAND_THE){	# See \the for the sense in this.
    $gullet->neutralizeTokens(@tokens); }
  else {
    @tokens; }});

#**********************************************************************
# Primitives
# See The TeXBook, Chapter 24, Summary of Vertical Mode
#  and Chapter 25, Summary of Horizontal Mode.
# Parsing of basic types (pp.268--271) is (mostly) handled in Gullet.pm
#**********************************************************************

#======================================================================
# Registers & Parameters
# See Chapter 24, Summary of Vertical Mode
# Define a whole mess of useless registers here ...
# Values are from Appendix B, pp. 348-349 (for whatever its worth)
#======================================================================

#======================================================================
# Integer registers; TeXBook p. 272-273
our %iparms= (pretolerance=>100, tolerance=>200, hbadness=>1000, vbadness=>1000,
	      linepenalty=>10, hyphenpenalty=>50, exhyphenpenalty=>50,
	      binoppenalty=>700, relpenalty=>500,
	      clubpenalty=>150, widowpenalty=>150, displaywidowpenalty=>50,
	      brokenpenalty=>100, predisplaypenalty=>10000,
	      postdisplaypenalty=>0, interlinepenalty=>0, 
	      floatingpenalty=>0, outputpenalty=>0, 
	      doublehyphendemerits=>10000, finalhyphendemerits=>5000, adjdemerits=>10000,
	      looseness=>0, pausing=>0, 
	      holdinginserts=>0, tracingonline=>0, tracingmacros=>0, tracingstats=>0, 
	      tracingparagraphs=>0, tracingpages=>0, tracingoutput=>0, tracinglostchars=>1,
	      tracingcommands=>0, tracingrestores=>0, language=>0, uchyph=>1, lefthyphenmin=>0,
	      righthyphenmin=>0, globaldefs=>0, defaulthyphenchar=>ord('-'), defaultskewchar=>-1,
	      escapechar=>0, endlinechar=>0, newlinechar=>-1, maxdeadcycles=>0, hangafter=>0, 
	      fam=>-1, mag=>1000, magnification=>1000, delimiterfactor=>0,
	      time=>0, day=>0, month=>0, year=>0,
	      showboxbreadth=>5, showboxdepth=>3, errorcontextlines=>5);
foreach my $p (keys %iparms){
  DefRegister("\\$p",Number($iparms{$p})); }

{  my ($sec,$min,$hour,$mday,$mon,$year)=localtime();
   AssignValue('\day'  =>Number($mday), 'global');
   AssignValue('\month'=>Number($mon+1), 'global');
   AssignValue('\year' =>Number(1900+$year), 'global'); 
   AssignValue('\time' =>Number(60*$hour+$min),'global'); }

our @MonthNames=(qw( January February March April May June
		     July August September October November December));

# Return a string for today's date.
sub today {
  $MonthNames[LookupValue('\month')->valueOf-1]
    ." ".LookupValue('\day')->valueOf
      .', '.LookupValue('\year')->valueOf; }

# Read-only Integer registers
our %ro_iparms=(lastpenalty=>0, inputlineno=>0, badness=>0);
foreach my $p (keys %ro_iparms){
  DefRegister("\\$p",Number($ro_iparms{$p}),readonly=>1); }

# Special integer registers (?)
# <special integer> = \spacefactor | \prevgraf | \deadcycles | \insertpenalties
our %sp_iparms=(spacefactor=>0, prevgraf=>0, deadcycles=>0, insertpenalties=>0);
foreach my $p (keys %sp_iparms){
  DefRegister("\\$p",Number($sp_iparms{$p})); }

#======================================================================
# Dimen registers; TeXBook p. 274
our %dparms=(hfuzz=>'0.1pt', vfuzz=>'0.1pt', overfullrule=>'5pt',
	     emergencystretch=>0,
	     hsize=>'6.5in', vsize=>'8.9in',
	     maxdepth=>'4pt', splitmaxdepth=>'16383.99999pt', boxmaxdepth=>'16383.99999pt',
	     lineskiplimit=>0, 
	     delimitershortfall=>'5pt', nulldelimiterspace=>'1.2pt', scriptspace=>'0.5pt',
	     mathsurround=>0, 
	     predisplaysize=>0, displaywidth=>0, displayindent=>0, parindent=>'20pt',
	     hangindent=>0, hoffset=>0, voffset=>0,);
foreach my $p (keys %dparms){
  DefRegister("\\$p",Dimension($dparms{$p})); }

# Read-only dimension registers.
our %ro_dparms=(lastkern=>0);
foreach my $p (keys %ro_dparms){
  DefRegister("\\$p",Dimension($ro_dparms{$p}), readonly=>1); }


# Special dimension registers (?)
# <special dimen> = \prevdepth | \pagegoal | \pagetotal | \pagestretch | \pagefilstretch
#    | \pagefillstretch | \pagefilllstretch | pageshrink | \pagedepth
our %sp_dparms=(prevdepth=>0, pagegoal=>0, pagetotal=>0, pagestretch=>0, pagefilstretch=>0,
		pagefillstretch=>0, pagefilllstretch=>0, pageshrink=>0, pagedepth=>0);
foreach my $p (keys %sp_dparms){
  DefRegister("\\$p",Dimension($sp_dparms{$p})); }

#======================================================================
# Glue registers; TeXBook p.274
our %gparms=(baselineskip=>0, lineskip=>0, 
	     parskip=>'0pt plus 1pt', 
	     abovedisplayskip=>'12pt plus 3pt minus 9pt',
	     abovedisplayshortskip=>'0pt plus 3pt',
	     belowdisplayskip=>'12pt plus 3pt minus 9pt',
	     belowdisplayshortskip=>'0pt plus 3pt',
	     leftskip=>0, rightskip=>0, topskip=>'10pt', splittopskip=>'10pt',
	     tabskip=>0, spaceskip=>0, xspaceskip=>0, parfillskip=>'0pt plus 1fil');
foreach my $p (keys %gparms){
  DefRegister("\\$p",Glue($gparms{$p})); }

#======================================================================
# MuGlue registers; TeXBook p.274
our %mparms=(thinmuskip=>'3mu', medmuskip=>'4mu plus 2mu minus 4mu', thickmuskip=>'5mu plus 5mu');
foreach my $p (keys %mparms){
  DefRegister("\\$p",Glue($mparms{$p})); }

#======================================================================
# Token registers; TeXBook p.275
our @tparms= qw(output everypar everymath everydisplay everyhbox everyvbox
		everyjob everycr everyhelp);

#======================================================================
# Assignment, TeXBook Ch.24, p.275
#======================================================================
# <assignment> = <non-macro assignment> | <macro assignment>

#======================================================================
# Macros
# See Chapter 24, p.275-276
# <macro assignment> = <definition> | <prefix><macro assignment>
# <definition> = <def><control sequence><definition text>
# <def> = \def | \gdef | \edef | \xdef
# <definition text> = <register text><left brace><balanced text><right brace>

sub parseDefParameters {
  my($cs, $params)=@_;
  my @tokens = $params->unlist;
  # Now, recognize parameters and delimiters.
  my @params=();
  my $n=0;
  while(@tokens){
    my $t=shift(@tokens);
    if($t->getCatcode == CC_PARAM){
      $n++; $t=shift(@tokens); 
	Fatal("Parameters for \"".ToString($cs)."\" not in order in ".ToSting($params))
	  unless $n == (ord($t->getString)-ord('0'));
      # Check for delimiting text following the parameter #n
      my @delim=();
      my($pc,$cc)=(-1,0);
      while(@tokens && (($cc=$tokens[0]->getCatcode) != CC_PARAM)){
	my $d = shift(@tokens);
	push(@delim,$d) unless $cc == $pc && $cc==CC_SPACE; # BUT collapse whitespace!
	$pc = $cc;}
      # Found text that marks the end of the parameter
      if(@delim){ 
	my $expected=Tokens(@delim);
	push(@params, LaTeXML::Parameters::newParameter('Until',
							'Until:'.$expected->toString,
							extra=>[$expected])); }
      
      # Special case: trailing sole # => delimited by next opening brace.
      elsif((scalar(@tokens)==1) && ($tokens[0]->getCatcode == CC_PARAM)){
	shift(@tokens);
	push(@params, LaTeXML::Parameters::newParameter('UntilBrace','UntilBrace')); }
      # Nothing? Just a plain parameter.
      else {
	push(@params, LaTeXML::Parameters::newParameter('Plain','{}')); }}
    else {
      # Initial delimiting text is required.
      my @lit=($t);
      while(@tokens && ($tokens[0]->getCatcode != CC_PARAM)){
	push(@lit,shift(@tokens)); }
      my $expected = Tokens(@lit);
      push(@params,LaTeXML::Parameters::newParameter('Match',
						     'Match:'.$expected->toString,
						     extra=>[$expected],
						     novalue=>1)); }
  }
  LaTeXML::Parameters->new(@params); }

sub do_def {
  my($globally, $expanded, $gullet,$cs,$params,$body)=@_;
##print STDERR "Defining ".Stringify($cs)."\n";
  $params = parseDefParameters($cs,$params);
  if($expanded){
    local $LaTeXML::NOEXPAND_THE = 1;
    $body = Expand($body); }
  InstallDefinition(LaTeXML::Expandable->new($cs,$params,$body),($globally ? 'global':undef));
  return; }

DefPrimitive('\def  SkipSpaces Token UntilBrace {}', sub { do_def(0,0,@_); });
DefPrimitive('\gdef SkipSpaces Token UntilBrace {}', sub { do_def(1,0,@_); });
DefPrimitive('\edef SkipSpaces Token UntilBrace {}', sub { do_def(0,1,@_); });
DefPrimitive('\xdef SkipSpaces Token UntilBrace {}', sub { do_def(1,1,@_); });

# <prefix> = \global | \long | \outer
# See Stomach.pm & Stomach.pm
DefPrimitive('\global',sub { $STATE->setPrefix('global'); return; }, isPrefix=>1);
DefPrimitive('\long',  sub { $STATE->setPrefix('long');   return; }, isPrefix=>1);
DefPrimitive('\outer', sub { $STATE->setPrefix('outer');  return; }, isPrefix=>1);

#======================================================================
# Non-Macro assignments; TeXBook Ch.24, pp 276--277
# <non-macro assignment> = <simple assignment> | \global <non-macro assignment>

# <filler> = <optional spaces> | <filler>\relax<optional spaces>
# <general text> = <filler>{<balanced text><right brace>

# <simple assignment> = <variable assignment> | <arithmetic>
#    | <code assignment> | <let assignment> | <shorthand definition>
#    | <fontdef token> | <family assignment> | <shape assignment>
#    | \read <number> to <optional spaces><control sequence>
#    | \setbox<8bit><equals><filler><box>
#    | \font <control sequence><equals><file name><at clause>
#    | <global assignment>
# <variable assignment> = <integer variable><equals><number>
#    | <dimen variable><equals><dimen>
#    | <glue variable><equals><dimen>
#    | <muglue variable><equals><muglue>
#    | <token variable><equals><general text>
#    | <token variable><equals><token variable>
# <at clause> = at <dimen> | scaled <number> | <optional spaces>
# <code assignment> = <codename><8bit><equals><number>

DefExpandable('\read Number SkipKeyword:to Token',sub {
  my($gullet,$fh,$token)=@_;
  DefMacro(ToString($token),Tokens()); });


##our %font_family=(r=>'serif',''=>'serif',ss=>'sansserif',tt=>'typewriter',
##		  vtt=>'typewriter',fib=>'fibonacci',fr=>'funnyroman',
##		  dh=>'dunhill',m=>'math',sy=>'symbol');

# Given a font, we'd like to map it to the "logical" names derived from LaTeX,
# (w/ loss of fine grained control).
# I'd like to use Karl Berry's font naming scheme
# (See http://www.tug.org/fontname/html/)
# but it seems to be a one-way mapping, and moreover, doesn't even fit CM fonts!
# We'll assume a sloppier version:
#   family + series + variant + size

our %font_family=(cmr=>{family=>'serif'},      cmss=>{family=>'sansserif'},
		  cmtt=>{family=>'typewriter'},cmvtt=>{family=>'typewriter'},
		  cmti=>{family=>'typewriter', shape=>'italic'},
		  cmfib=>{family=>'serif'},    cmfr=>{family=>'serif'},
		  cmdh=>{family=>'serif'},     cm=>{family=>'serif'},
		  ptm=>{family=>'serif'},      ppl=>{family=>'serif'},
		  pnc=>{family=>'serif'},      pbk=>{family=>'serif'},
		  phv=>{family=>'sansserif'},  pag=>{family=>'serif'},
		  pcr=>{family=>'typewriter'}, pzc=>{family=>'script'},
		  put=>{family=>'serif'},      bch=>{family=>'serif'},
		  psy=>{family=>'symbol'},     pzd=>{family=>'dingbats'},
		  ccr=>{family=>'serif'},      ccy=>{family=>'symbol'},
		  cmbr=>{family=>'sansserif'}, cmtl=>{family=>'typewriter'},
		  cmbrs=>{family=>'symbol'},   ul9=>{family=>'typewriter'},
		  txr=>{family=>'serif'},      txss=>{family=>'sansserif'},
		  txtt=>{family=>'typewriter'},txms=>{family=>'symbol'},
		  txsya=>{family=>'symbol'},   txsyb=>{family=>'symbol'},
		  pxr=>{family=>'serif'},      pxms=>{family=>'symbol'},
		  pxsya=>{family=>'symbol'},   pxsyb=>{family=>'symbol'},
		  futs=>{family=>'serif'},
		  uaq=>{family=>'serif'},      ugq=>{family=>'sansserif'},
		  eur=>{family=>'serif'},      eus=>{family=>'script'},
		  euf=>{family=>'fraktur'},    euex=>{family=>'symbol'},
		  # The following are actually math fonts.
		  ccm=>{family=>'serif', shape=>'italic'},
		  cmex=>{family=>'symbol'}, # Not really symbol, but...
		  cmsy=>{family=>'symbol'},
		  ccitt=>{family=>'typewriter', shape=>'italic'},
		  cmbrm=>{family=>'sansserif', shape=>'italic'},
		  futm=>{family=>'serif', shape=>'italic'},
		  futmi=>{family=>'serif', shape=>'italic'},
		  txmi=>{family=>'serif', shape=>'italic'},
		  pxmi=>{family=>'serif', shape=>'italic'},
		  );

our %font_series=(''=>'medium',m=>'medium', mc=>'medium', 
		  b=>'bold',bc=>'bold', bx=>'bold', sb=>'bold', sbc=>'bold');
our %font_shape =(''=>'upright',n=>'upright', i=>'italic',it=>'italic',
		  sl=>'slanted', sc=>'smallcaps', csc=>'smallcaps');

our $FONTREGEXP
  = '('.join('|',sort { -($a cmp $b) } keys %font_family).')'
  . '('.join('|',sort { -($a cmp $b) } keys %font_series).')'
  . '('.join('|',sort { -($a cmp $b) } keys %font_shape).')'
  . '(\d+)';
  
# Decode a font size in points into a "logical" size.
our @font_size_map=(0.60=>'tiny',   0.75=>'script', 0.85=>'footnote',0.95=>'small',
		    1.10=>'normal', 1.30=>'large',  1.55=>'Large',   1.85=>'LARGE',
		    2.25=>'huge',   1000.0=>'Huge');
sub abstract_font_size {
  my($size)=@_;
  if(defined $size){
    my $scaled = $size/10.0;	# ASSUMED nominal font 10pt!!! Set from doc!!!
    my @map = @font_size_map;
    while(@map){
      return shift(@map) if($scaled <= shift(@map));
      shift(@map); }
    'Huge'; }
  else {
    'normal'; }}

# Need to handle "at" too!!!
DefPrimitive('\font Token SkipMatch:=', sub {
  my($stomach,$cs)=@_;
  $cs = $cs->toString;
  my $gullet = $stomach->getGullet;
  my($token,@tokens)=();
  while(($token = $gullet->readXToken()) && ($token->getCatcode != CC_SPACE)){
    push(@tokens,$token); }

  my $name = Tokens(@tokens)->toString;
  my %props=();
  my $size;
  if($name =~ /^$FONTREGEXP$/o){
    my($fm,$sr,$sh)=($1,$2,$3);
    $size = $4;
    %props = %{$font_family{$fm}||{}};
    $props{series}= $font_series{$sr} unless $props{series};
    $props{shape} = $font_shape{$sh}  unless $props{shape}; }
  else {
    Warn("Unrecognized font \"$name\"; $cs will have no effect"); }

  if($gullet->readKeyword('at')){
    $size = $gullet->readDimension->ptValue; }
  if($gullet->readKeyword('scaled')){
    $size *= ($gullet->readNumber->valueOf/1000); }
  $props{size}  = abstract_font_size($size);
  $gullet->skipSpaces;
##  print STDERR "Font $name == ".join(', ',map("$_=>$props{$_}",sort keys %props))."\n";
  DefConstructor($cs,'',font=>{%props});

});

DefRegister('\count Number' => Number(0));
DefRegister('\dimen Number' => Dimension(0));
DefRegister('\skip Number'  => Glue(0));
DefRegister('\muskip Number'=> MuGlue(0));
DefRegister('\toks Number'  => Tokens());

# <integer variable> = <integer parameter> | <countdef token> | \count<8bit>
# <dimen var> = <dimen parameter> | <dimendef token> | \dimen<8bit>
# <glue variable> = <glue parameter> | <skipdef token> | \skip<8bit>
# <muglue variable> = <muglue parameter> | <muskipdef token> | \muskip<8bit>

# <arithmetic> = \advance <integer variable><optional by><number>
#    | \advance <dimen variable><optional by><dimen>
#    | \advance <glue variable><optional by><glue>
#    | \advance <muglue variable><optional by><muglue>
#    | \multiply <numeric variable><optional by><number>
#    | \divide <numeric variable><optional by><number>

DefPrimitive('\advance Variable SkipKeyword:by',sub {
  my($stomach,$var)=@_;
  return () unless $var;
  my($defn,@args)=@$var;
  $defn->setValue($defn->valueOf(@args)->add($stomach->getGullet->readValue($defn->isRegister)),@args); });

DefPrimitive('\multiply Variable SkipKeyword:by Number',sub {
  my($stomach,$var,$scale)=@_;
  return () unless $var;
  my($defn,@args)=@$var;
  $defn->setValue($defn->valueOf(@args)->multiply($scale->valueOf),@args); });

DefPrimitive('\divide Variable SkipKeyword:by Number',sub {
  my($stomach,$var,$scale)=@_;
  return () unless $var;
  my($defn,@args)=@$var;
  $defn->setValue($defn->valueOf(@args)->multiply(1/$scale->valueOf),@args); });

# <let assignment> = \futurelet <control sequence><token><token> 
#   | \let<control sequence><equals><one optional space><token>
DefPrimitive('\let Token SkipMatch:= Token', sub {
  my($stomach,$token1,$token2)=@_;
  Let($token1, $token2);
  return;  });

DefExpandable('\futurelet Token Token Token',sub{
  my($stomach,$cs,$token1,$token2)=@_;
  Let($cs, $token2);
  ($token1,$token2); });

# <shorthand definition> = \chardef<control sequence><equals><8bit>
#    | \mathchardef <control sequence><equals><15bit>
#    | <registerdef><control sequence><equals><8bit>
# <registerdef> = \countdef | \dimendef | \skipdef | \muskipdef | toksdef

# Almost like a register, but different...
DefPrimitive('\chardef Token SkipMatch:= Number', sub {
  my($stomach,$newcs,$value)=@_;
  InstallDefinition(LaTeXML::CharDef->new($newcs,$value));
  return; });

# \mathchardef ?

DefPrimitive('\countdef Token SkipMatch:= Number',sub {
  my($stomach,$cs,$num)=@_;
  my $count = '\count'.$num->valueOf;
  DefRegister($cs->getString, Number(0),
	       getter=>sub { LookupValue($count); },
	       setter=>sub { AssignValue($count=>$_[0]); }); });

DefPrimitive('\dimendef Token SkipMatch:= Number',sub {
  my($stomach,$cs,$num)=@_;
  my $dimen = '\dimen'.$num->valueOf;
  DefRegister($cs->getString, Dimension(0),
	       getter=>sub { LookupValue($dimen); },
	       setter=>sub { AssignValue($dimen=>$_[0]); }); });

DefPrimitive('\skipdef Token SkipMatch:= Number',sub {
  my($stomach,$cs,$num)=@_;
  my $glue = '\skip'.$num->valueOf;
  DefRegister($cs->getString, Glue(0),
	       getter=>sub { LookupValue($glue); },
	       setter=>sub { AssignValue($glue=>$_[0]); }); });

DefPrimitive('\muskipdef Token SkipMatch:= Number',sub {
  my($stomach,$cs,$num)=@_;
  my $muglue = '\muskip'.$num->valueOf;
  DefRegister($cs->getString, MuGlue(0),
	       getter=>sub { LookupValue($muglue); },
	       setter=>sub { AssignValue($muglue=>$_[0]); }); });

DefPrimitive('\toksdef Token SkipMatch:= Number',sub {
  my($stomach,$cs,$num)=@_;
  my $toks = '\toks'.$num->valueOf;
  DefRegister($cs->getString, Tokens(),
	       getter=>sub { LookupValue($toks); },
	       setter=>sub { AssignValue($toks=>$_[0]); }); });


# NOTE: Get all these handled as registers
# <internal integer> = <integer parameter> | <special integer> | \lastpenalty
#   | <countdef token> | \count<8bit> | <codename><8bit>
#   | <chardef token> | <mathchardef token> | \parshape | \inputlineno
#   | \hyphenchar<font> | \skewchar<font> | \badness

# <codename> = \catcode | \mathcode | \lccode | \uccode | \sfcode | \delcode

DefRegister('\catcode Number',Number(0),
	     getter=>sub { my $cc = LookupCatcode(chr($_[0]->valueOf));
			   $cc = CC_OTHER unless defined $cc;
			   Number($cc); },
	     setter=>sub { AssignCatcode(chr($_[1]->valueOf) => $_[0]->valueOf); });
# \mathcode
# \lccode
# \uccode
# \sfcode
# \delcode
DefRegister('\hyphenchar{}',Number(ord('-')));
DefRegister('\skewchar{}',Number(0)); # no idea what the default is here

# \parshape !?!??
#DefRegister('\inputlineno',Number(0),
#            readonly=>1,
#	     getter=>{ Number($stomach->getGullet->getMouth????? ->lineno); });
# \skewchar

DefMacro('\hyphenation{}',''); # Well, what ?


# <font> = <fontdef token> | \font | <family member>
# <family member> | <font range><4bit>
# <font range> = \textfont | \scriptfont | \scriptscriptfont

# Doubtful that we can do anything useful with these.
DefMacro('\textfont Number SkipMatch:= Token', sub { return; });
DefMacro('\scriptfont Number SkipMatch:= Token', sub { return; });
DefMacro('\scriptscriptfont Number SkipMatch:= Token', sub { return; });

# <internal dimen> = <dimen parameter> | <special dimen> | \lastkern
#    | <dimendef token> | \dimen<8bit> | <box dimension><8bit> | \fontdimen<number><font>
# <box dimension> = \ht | \wd | \dp

# Need some clever getter & setters!
DefRegister('\ht Number',Dimension(0));
DefRegister('\wd Number',Dimension(0));
DefRegister('\dp Number',Dimension(0));

#   Could be handled by setting dimensions whenever the box itself is set?

# <internal glue> = <glue parameter> | \lastskip | <skipdef token> | \skip<8bit>

# <internal muglue> = <muglue parameter> | \lastskip | <muskipdef token> | \muskip<8bit>

# <family assignment> = <family member><equals><font>
# <shape assignment> = \parshape<equals><number><shape dimensions>
#  <shape dimensions> is 2n <dimen>

# <global assignment> = <font assignment> | <hyphenation assignment>
#   | <box size assignment> | <interaction mode assignment>
#   | <intimate assignment>
# <font assignment> = \fontdimen <number><font><equals><dimen>
#   | \hyphenchar<font><equals><number> | \skewchar<font><equals><number>
# <hyphenation assignment> = \hyphenation<general text>
#   | \patterns<general text>
# <box size assignment> = <box dimension><8bit><equals><dimen>
# <interaction mode assignment> = \errorstopmode | \scrollmode | \nonstopmode | \batchmode
# These are no-ops; Basically, LaTeXML runs in scrollmode
DefPrimitive('\errorstopmode',undef);
DefPrimitive('\scrollmode',undef);
DefPrimitive('\nonstopmode',undef);
DefPrimitive('\batchmode',undef);

# <intimate assignment> = <special integer><equals><number>
#   | <special dimension><equals><dimen>

DefPrimitive('\char Number', sub { $_[0]->invokeToken(T_OTHER(chr($_[1]->valueOf))); });
# <box> = \box <8bit> | \copy <8bit> | \lastbox | \vsplit <8bit> to <dimen>
#   | \hbox <box specification>{<horizontal mode material>}
#   | \vbox <box specification>{<vertical mode material>}
#   | \vtop <box specification>{<vertical mode material>}
# <box specification> = to <dimen><filler> | spread <dimen><filler> | <filler>

# \setbox<number>=\hbox to <dimen>{<horizontal mode material>}

DefPrimitive('\setbox Number SkipMatch:=', sub { 
  my($stomach)=@_;
  my @stuff = $stomach->invokeToken($stomach->getGullet->readXToken);
  AssignValue('box'.$_[1]->valueOf => shift(@stuff));
  @stuff;});
# Is this the same ??
DefPrimitive('\sbox Number SkipMatch:= {}', sub { 
  my($stomach)=@_;
  my @stuff = $stomach->invokeToken($stomach->getGullet->readXToken);
  AssignValue('box'.$_[1]->valueOf => shift(@stuff));
  @stuff;});

DefPrimitive('\box Number', sub { LookupValue('box'.$_[1]->valueOf); });

# Read to Dimension and return the dimension as string,
#  Or spread Dimension and return +dimension as string.
# sub read_box_spec {
#   my($stomach,$whatsit)=@_;
#   my $gullet = $stomach->getGullet;
#   if(my $key = $gullet->readKeyword('to','spread')){
#     $whatsit->setProperty($key=>$gullet->readDimension); }}

# # Read a box's material, 
# sub read_box_contents {
#   my($stomach,$whatsit)=@_;
#   $stomach->getGullet->readUntil(T_BEGIN);
#   $stomach->bgroup;
#   $whatsit->setBody($stomach->digestNextBody,LaTeXML::Box->new("}",undef,undef,T_END)); }

sub revert_spec {
  my($whatsit,$keyword)=@_;
  my $value = $whatsit->getProperty($keyword);
  ($value ? (Explode($keyword),$value->revert): ()); }

DefParameterType('BoxSpecification',sub {
  my($gullet)=@_;
  if(my $key = $gullet->readKeyword('to','spread')){
    LaTeXML::BoxDimensions->new($key=>$gullet->readDimension); }},
		 optional=>1, undigested=>1);

# Risky: I think this needs to be digested as a body to work like TeX (?)
# but parameter think's it's just parsing from gullet...
DefParameterType('BoxContents',sub {
  my($gullet)=@_;
#  $gullet->readUntil(T_BEGIN);
#  my $stomach = $STATE->getStomach;
#  $stomach->bgroup;
#  LaTeXML::List->new($stomach->digestNextBody);},
  $gullet->readUntil(T_BEGIN);
  my($contents,@stuff) = $STATE->getStomach->invokeToken(T_BEGIN);
  $contents; },
		 undigested=>1); # Cause it already is digested!

# DefConstructor('\XXXhbox', "<ltx:text width='#to' pad-width='#spread'>#body</ltx:text>",
# 	       afterDigest=>sub { read_box_spec(@_); read_box_contents(@_); },
# 	       mode=>'text',
# 	       reversion=>sub { (T_CS('\hbox'),revert_spec($_[0],'to'),revert_spec($_[0],'spread'),
# 				 T_BEGIN,$_[0]->getProperty('body')->revert); }); # body has }

# DefConstructor('\XXXvbox', "<ltx:vbox valign='bottom' height='#to' pad-height='#spread'>#body</ltx:vbox>",
# 	       afterDigest=>sub { read_box_spec(@_); read_box_contents(@_); },
# 	       mode=>'text',
# 	       reversion=>sub { (T_CS('\vbox'),revert_spec($_[0],'to'),revert_spec($_[0],'spread'),
# 				 T_BEGIN,$_[0]->getProperty('body')->revert); }); # body has }

# DefConstructor('\XXXvtop', "<ltx:vbox valign='top' height='#to' pad-height='#spread'>#body</ltx:vbox>",
# 	       afterDigest=>sub { read_box_spec(@_); read_box_contents(@_); },
# 	       mode=>'text',
# 	       reversion=>sub { (T_CS('\vtop'),revert_spec($_[0],'to'),revert_spec($_[0],'spread'),
# 				 T_BEGIN,$_[0]->getProperty('body')->revert); }); # body has }

sub REF { $_[0] && $_[0]->{$_[1]}; }

DefConstructor('\hbox BoxSpecification BoxContents',
	       "<ltx:text width='&REF(#1,to)' pad-width='&REF(#1,spread)'>#2</ltx:text>",
	       mode=>'text');

DefConstructor('\vbox BoxSpecification BoxContents',
	       "<ltx:vbox valign='bottom' height='&REF(#1,to)' pad-height='&REF(#1,spread)'>#2</ltx:vbox>",
	       mode=>'text');

DefConstructor('\vtop BoxSpecification BoxContents',
	       "<ltx:vbox valign='top' height='&REF(#1,to)' pad-height='&REF(#1,spread)'>#2</ltx:vbox>",
	       mode=>'text');

sub read_rule_spec {
  my($stomach,$whatsit)=@_;
  my $gullet = $stomach->getGullet;
  while(my $key = $gullet->readKeyword('height','depth','width')){
    $whatsit->setProperty($key=>$gullet->readDimension); }
  return; }

DefConstructor('\vrule', "<ltx:rule height='#height' depth='#depth' width='#width'/>",
	       afterDigest=>sub { read_rule_spec(@_); },
	       properties=>{isVerticalRule=>1},
	       reversion=>sub { (T_CS('\vbox'),revert_spec($_[0],'height'),
				 revert_spec($_[0],'depth'),revert_spec($_[0],'width'));});

DefConstructor('\hrule', "<ltx:rule height='#height' depth='#depth' width='#width'/>",
	       afterDigest=>sub { read_rule_spec(@_); },
	       properties=>{isHorizontalRule=>1},
	       reversion=>sub { (T_CS('\hbox'),revert_spec($_[0],'height'),
                                revert_spec($_[0],'depth'),revert_spec($_[0],'width'));});

#======================================================================
# Remaining Mode independent primitives in Ch.24, pp.279-280
# \relax was done as expandable (isn't that right?)
# }
# Note, we don't bother making sure begingroup is ended by endgroup.

# These define the handler for { } (or anything of catcode BEGIN, END)

# These are actually TeX primitives, but we treat them as a Whatsit so they
# remain in the constructed tree.
DefConstructor('{','#body', beforeDigest=>sub{$_[0]->bgroup;}, captureBody=>1);
DefConstructor('}',  '',    beforeDigest=>sub{$_[0]->egroup;});

DefPrimitive('\begingroup',sub { $_[0]->begingroup; });
DefPrimitive('\endgroup',  sub { $_[0]->endgroup; });

# Debugging aids; Ignored!
DefPrimitive('\show Token',undef);
DefPrimitive('\showbox Number',undef);
DefPrimitive('\showlists',undef);
DefPrimitive('\showthe Token',undef);

# DefPrimitive('\shipout ??
DefPrimitive('\ignorespaces SkipSpaces',undef);

# \afterassignment<token>   ??
DefPrimitive('\aftergroup Token', sub { UnshiftValue(afterGroup=>$_[1]); });

# \uppercase<general text>, \lowercase<general text>
DefExpandable('\uppercase {}',sub {
  my($gullet,$arg)=@_;
  map( ($_->getCharcode == CC_LETTER ? T_LETTER(uc($_->getString)):$_),
       $arg->unlist); });
DefExpandable('\lowercase {}',sub {
  my($gullet,$arg)=@_;
  map( ($_->getCharcode == CC_LETTER ? T_LETTER(lc($_->getString)):$_),
       $arg->unlist); });

DefPrimitive('\message{}',sub {
  my($stomach,$stuff)=@_;
  print STDERR ToString(Expand($stuff));
  return; });

## I'm thinking we want to mostly ignore the I/O stuff.
## Generally, it's used to move info around for multiple passes
## of aux, index, etc.
DefPrimitive('\openin Number SkipMatch:= XUntilSpace', undef);
DefPrimitive('\openout Number SkipMatch:= XUntilSpace', undef);
DefPrimitive('\closein Number',undef);
DefPrimitive('\closeout Number',undef);
DefPrimitive('\immediate',undef);
# \immediate\write<number><general text>
DefPrimitive('\write Number {}', undef);

#======================================================================
# Remaining semi- Vertical Mode primitives in Ch.24, pp.280--281

DefPrimitive('\special {}', undef);
DefPrimitive('\penalty Number',undef);
DefPrimitive('\kern Dimension',undef);
DefPrimitive('\mkern MuGlue',undef);
DefPrimitive('\unpenalty',undef);
DefPrimitive('\unkern',undef);
DefPrimitive('\unskip',undef);
DefPrimitive('\mark{}',undef);
# \insert<8bit><filler>{<vertical mode material>}
DefPrimitive('\insert Number',undef); # Just let the insertion get processed(?)
# \vadjust<filler>{<vertical mode material>}
DefPrimitive('\vadjust {}',undef); # Ignorable?

#======================================================================
# Remaining Vertical Mode primitives in Ch.24, pp.281--283
# \vskip<glue>, \vfil, \vfill, \vss, \vfilneg
# <leaders> = \leaders | \cleaders | \xleaders
# <box or rule> = <box> | <vertical rule> | <horizontal rule>
# <vertical rule> = \vrule<rule specification>
# <horizontal rule> = \hrule<rule specification>
# <rule specification> = <optional spaces> | <rule dimension><rule specification>
# <rule dimension> = width <dimen> | height <dimen> | depth <dimen>

# Stuff to ignore for now...
foreach my $op ('\vskip Glue', '\vfil', '\vfill', '\vss', '\vfilneg',
		'\leaders', '\cleaders', '\xleaders'){
  DefPrimitive($op,undef); }

# \moveleft<dimen><box>, \moveright<dimen><box>
DefConstructor('\moveleft Dimension MoveableBox',
	       "<ltx:text shift='#y'>#2</ltx:text>",
	       afterDigest=>sub{
		 $_[1]->setProperty(y=>$_[1]->getArg(1)->multiply(-1)); });
DefConstructor('\moveright Dimension MoveableBox',
	       "<ltx:text shift='#y'>#2</ltx:text>",
	       afterDigest=>sub{
		 $_[1]->setProperty(y=>$_[1]->getArg(1)); });

# \unvbox<8bit>, \unvcopy<8bit>
DefExpandable('\unvbox Number',sub {
  my $box = 'box'.$_[1]->valueOf;
  my $stuff = LookupValue($box); 
  AssignValue($box,undef);
  $stuff; });
DefExpandable('\unvcopy Number',sub {
  LookupValue('box'.$_[1]->valueOf); });

#======================================================================
# Basic alignment support needed by most environments & commands.
#======================================================================

Tag('ltx:td',        afterClose=>\&trimNodeWhitespace);
Tag('ltx:td-between',afterClose=>\&trimNodeWhitespace);

#----------------------------------------------------------------------
# Primitive column types;
# This is really LaTeX, but the mechanisms are used behind-the-scenes here, too.
DefColumnType('|',sub {
  $LaTeXML::BUILD_TEMPLATE->addBetween(T_CS('\vrule')); return; });
DefColumnType('l',sub {
  $LaTeXML::BUILD_TEMPLATE->addColumn(after=>Tokens(T_CS('\hfil'))); return; });
DefColumnType('c',sub {
  $LaTeXML::BUILD_TEMPLATE->addColumn(before=>Tokens(T_CS('\hfil')),
						after=>Tokens(T_CS('\hfil'))); return; });
DefColumnType('r',sub {
  $LaTeXML::BUILD_TEMPLATE->addColumn(before=>Tokens(T_CS('\hfil'))); return; });

DefColumnType('p{Dimension}',sub {
  $LaTeXML::BUILD_TEMPLATE->addColumn(before=>Tokens(T_CS('\hbox'),T_BEGIN),#Tokens(T_BEGIN),
				      after=>Tokens(T_END),
				      align=>'justify', width=>$_[1]); return; });
DefColumnType('*{Number}{}', sub {
		my($gullet,$n,$pattern)=@_;
		map( $pattern->unlist, 1..$n->valueOf); });

DefColumnType('@{}',sub {
  my($gullet,$filler)=@_;
  $LaTeXML::BUILD_TEMPLATE->addBetween($filler->unlist);  return; });

#----------------------------------------------------------------------
DefMacro('\@start@alignment','\@open@alignment\@open@row\@open@column\@open@inner@column');
DefMacro('\@finish@alignment','\@close@inner@column\@close@column\@close@row\@close@alignment');

#----------------------------------------------------------------------
# These are to be bound to &, \span, \cr and \\
# The macro layer expands into appropriate begin & end markers for rows & columns;
# The constructor layer carries out any side effect and records a token for reversion.
DefMacro('\@alignment@align',
	 '\@close@inner@column\@close@column'
	 .'\@alignment@align@marker'
	 .'\@open@column\@open@inner@column');
DefConstructor('\@alignment@align@marker','',reversion=>'&');

DefMacro('\@alignment@span',
	 '\@close@inner@column'
	 .'\@alignment@span@marker'
	 .'\@open@inner@column');
DefConstructor('\@alignment@span@marker','',reversion=>'\span',
	      properties=>{alignmentIgnorable=>1});
DefConstructor('\omit','',properties=>{alignmentIgnorable=>1});

DefMacro('\@alignment@cr',
	 '\@close@inner@column\@close@column\@close@row'
	 .'\@alignment@cr@marker'
	 .'\@open@row\@open@column\@open@inner@column');
DefConstructor('\@alignment@cr@marker','',reversion=>'\cr');
DefConstructor('\cr', "\n"); # Default binding.
DefMacro('\crcr', '\cr');

DefMacro('\@alignment@newline OptionalMatch:* [Dimension]',
	 '\@close@inner@column\@close@column\@close@row'
	 .'\@alignment@newline@marker'
	 .'\@open@row\@open@column\@open@inner@column');
DefConstructor('\@alignment@newline@marker','',reversion=>'\\\\');

DefConstructor('\@alignment@hline','',
	       afterDigest=>sub { LookupValue('Alignment')->addLine('t'); },
	       properties=>{isHorizontalRule=>1},
	       alias=>'\hline');
DefConstructor('\@alignment@hrule','',
	       afterDigest=>sub { LookupValue('Alignment')->addLine('t'); },
	       properties=>{isHorizontalRule=>1},
	       alias=>'\hrule');

# ????
DefPrimitive('\noalign', undef);
DefMacro('\hidewidth','');

DefExpandable('\multispan{Number}', sub {
  my($gullet,$span)=@_;
  $span = $span->valueOf;
  (T_CS('\omit'),map((T_CS('\span'),T_CS('\omit')), 1..$span-1)); });

DefExpandable('\@multicolumn {Number}  AlignmentTemplate {}', sub {
  my($gullet,$span,$template,$tokens)=@_;
  my $column = $template->column(1);
  $span = $span->valueOf;
  # First part, like \multispan
  (T_CS('\omit'),map((T_CS('\span'),T_CS('\omit')), 1..$span-1),
   # Next part, just put the template in-line, since it's only used once.
   ($column ? beforeCellUnlist($$column{before}) : ()),
   $tokens->unlist,
   ($column ? afterCellUnlist($$column{after}) : ()) ); });

sub alignmentBindings {
  my($template)=@_;
  if($template && !ref $template){
    $template = parseAlignmentTemplate($template); }
  my $alignment = LaTeXML::Util::Alignment->new();
  AssignValue(Alignment=>$alignment);
  $alignment->setTemplate($template) if $template;
  Let(T_ALIGN,        T_CS('\@alignment@align'));
  Let(T_CS("\\\\"),   T_CS('\@alignment@newline'));
  Let(T_CS('\tabularnewline'),   T_CS('\@alignment@newline'));
  Let(T_CS('\cr'),    T_CS('\@alignment@cr'));
  Let(T_CS('\hline'), T_CS('\@alignment@hline'));
  Let(T_CS('\hrule'), T_CS('\@alignment@hrule'));
  Let('\span',        T_CS('\@alignment@span'));
  return; }

DefPrimitive('\@alignment@bindings AlignmentTemplate',sub {
  my($stomach,$template)=@_;
  alignmentBindings($template); });

#----------------------------------------------------------------------
# To recognize where rows & columns start and stop, we need to
# recognize things that have expanded into &, \cr, etc.
# Additionally, \span creates a single column out of several.

sub readDigestedUntil {
  my($gullet,$endtoken)=@_;
  $endtoken = $endtoken->[0];
  my $ismath     = $STATE->lookupValue('IN_MATH');
  my @list = $STATE->getStomach->digestNextBody($endtoken); 
  # In most (all?) cases, we're really looking for a single Whatsit here...
  @list = grep(ref $_ ne 'LaTeXML::Comment', @list);
  (scalar(@list) == 1 ? $list[0] 
   : ($ismath ? LaTeXML::MathList->new(@list) : LaTeXML::List->new(@list))); }

DefParameterType('AlignmentBody', \&readDigestedUntil, undigested=>1);
DefParameterType('DeferredAlignmentBody', \&readDigestedUntil, undigested=>1);

#----------------------------------------------------------------------
# Overall Alignment;

Let('\@close@alignment','\relax');
DefConstructor('\@open@alignment DeferredAlignmentBody:\@close@alignment',
	       "#1",
	       bounded=>1, reversion=>'#1',
	       afterDigest=>sub { $_[1]->setProperty(alignment=>LookupValue('Alignment')); });

#----------------------------------------------------------------------
# Row
Let('\@close@row','\relax');
DefConstructor('\@open@row SkipSpaces DeferredAlignmentBody:\@close@row',
	       "",
	       reversion=>'#1',
	       beforeDigest=>sub { LookupValue('Alignment')->newRow; return;});

#----------------------------------------------------------------------
# Column
Let('\@close@column','\relax');

# This will now have to scan the created boxes to recognize borders & hfil items.
DefPrimitive('\@open@column SkipSpaces DeferredAlignmentBody:\@close@column', sub {
  my($stomach,$boxes)=@_;
  my $alignment = LookupValue('Alignment');
  my $n0 = LookupValue('alignmentStartColumn')+1;
  my $n1 = $alignment->currentColumnNumber;
  my $colspec = $alignment->getColumn($n0);
  my $align=  $$colspec{align} || 'left';
  my $border= '';

## print STDERR "\nColumn $n0-$n1:\n   ".Stringify($boxes)."\n";
  # Scan boxes for borders & hfill whatsits, adjusting $align and $border
  my @boxes = $boxes->unlist;
  my @saveleft=();
  my @saveright=();
  while(@boxes){
    if($boxes[0]->getProperty('isFill')){
      $align='right'; shift(@boxes); last; }
    elsif($boxes[0]->getProperty('isVerticalRule')){
      $border .= 'l'; shift(@boxes); }
    elsif($boxes[0]->getProperty('isHorizontalRule')){
      push(@saveleft,shift(@boxes)); }
    elsif($boxes[0]->getProperty('alignmentIgnorable')){
      push(@saveleft,shift(@boxes)); }
    elsif(ref $boxes[0] eq 'LaTeXML::Comment'){
      push(@saveleft,shift(@boxes)); }
    elsif($boxes[0]->getProperty('isSpace')){
      shift(@boxes);}
    else {
      last; }}
  while(@boxes){
    if($boxes[$#boxes]->getProperty('isFill')){
      if($align eq 'right'){ $align='center'; }
      pop(@boxes); last; }
    elsif($boxes[$#boxes]->getProperty('isVerticalRule')){
      $border .= 'r'; pop(@boxes); }
    elsif($boxes[$#boxes]->getProperty('isHorizontalRule')){
      unshift(@saveright,pop(@boxes)); }
    elsif($boxes[$#boxes]->getProperty('alignmentIgnorable')){
      unshift(@saveright,pop(@boxes)); }
    elsif(ref $boxes[$#boxes] eq 'LaTeXML::Comment'){
      unshift(@saveleft,pop(@boxes)); }
    elsif($boxes[$#boxes]->getProperty('isSpace')){
      pop(@boxes);}
    else {
      last; }}
  delete $$colspec{width} unless $align eq 'justify';
  my $empty = scalar(@boxes) == 0;
  $align = undef if $empty;
  @boxes = (@saveleft,@boxes,@saveright);
  $boxes = (scalar(@boxes) == 1 ? $boxes[0] 
	    : ($boxes->isMath ? LaTeXML::MathList->new(@boxes) : LaTeXML::List->new(@boxes)));

  # record relevant info in the Alignment.
  my $span = $n1-$n0+1;
  $$colspec{align} = $align;
  $$colspec{border} = $border = ($$colspec{border}||'').$border;
  $$colspec{boxes} = $boxes;
  $$colspec{span} = $span;
  $$colspec{empty} = 1 if $empty;
  for(my $i = $n0+1; $i <= $n1; $i++){
    $alignment->getColumn($i)->{skipped}=1; }
## print STDERR " => align=$align, border=$border\n  ".Stringify($boxes)."\n";
#
  $stomach->egroup;
  $boxes; },
	     beforeDigest=>sub { $_[0]->bgroup;
				 AssignValue(alignmentStartColumn=>LookupValue('Alignment')->currentColumnNumber); });

Let('\@@close@inner@column','\relax');
DefPrimitive('\@@eat@space',sub {
	       my $box;
	       my @save=();
	       while(($box = $LaTeXML::LIST[$#LaTeXML::LIST]) && ($box->toString=~/^\s*$/)){
		 if($box->getProperty('alignmentIgnorable')){
		   push(@save,pop(@LaTeXML::LIST)); }
		 else {
		   pop(@LaTeXML::LIST); }}
	       push(@LaTeXML::LIST,@save);
	       return; });

DefMacro('\@close@inner@column', sub {
	   my $col = LookupValue('Alignment')->currentColumn;
	   (T_CS('\@@eat@space'),
	    ($$col{after} ? afterCellUnlist($$col{after}) : ()),
	    T_CS('\@@close@inner@column')); });
  
DefPrimitive('\@open@inner@column',sub {
  my($stomach)=@_;
  my $alignment = LookupValue('Alignment');
  my $colspec = $alignment->nextColumn;
##print STDERR "COLUMN: ".$alignment->currentColumnNumber." => ".$colspec."\n ";


  if(!$colspec){
    Error("Extra alignment tab"); }
  $stomach->bgroup;
  my $gullet = $stomach->getGullet;
  # Check for presence of \omit  (& \noalign?)

  my $tok;
  my @save=();
  $$colspec{empty}=0;		#  How do we _KNOW_ ???
  while(1){
    while(($tok=$gullet->readXToken) && $tok->equals(T_SPACE)){ }
    if(!$tok){ last; }
    elsif($tok->equals(T_CS('\omit'))){
      $$colspec{before}=$$colspec{after}=Tokens(); 
      last; }
    elsif($tok->equals(T_CS('\hline')) || $tok->equals(T_CS('\cline'))){
      push(@save,$stomach->invokeToken($tok)); $tok=undef; }
    elsif($tok->equals(T_CS('\@@eat@space'))){ # This is the first token left from & or \\ !!!
      $$colspec{empty}=1; last; } # Backtrack! IS empty after all...
    else { last; }}
  $gullet->unread($tok) if $tok;

  $gullet->unread(beforeCellUnlist($$colspec{before})) if $$colspec{before};

  my $endtoken = T_CS('\@@close@inner@column');
  my @boxes = $STATE->getStomach->digestNextBody($endtoken); 
  $stomach->egroup;
  (@save,@boxes); });

# Yet more special case hacking. Sometimes the order of tokens works for
# TeX, but confuses us... In particular the order of $ and \hfil!
# \@open@column is too late, since the stuff is already digested.
# Could _almost_  handle the extractions here, but there are several
# rule operators that digest into whatsits with certain properties...
sub beforeCellUnlist {
  my($tokens)=@_; 
  my @toks = $tokens->unlist;
  my @new = ();
  while(my $t = shift(@toks)){
    if($t->equals(T_MATH) && @toks && $toks[0]->equals(T_CS('\hfil'))){
      push(@new,shift(@toks)); unshift(@toks,$t); }
    else {
      push(@new, $t); }}
  @new; }

sub afterCellUnlist {
  my($tokens)=@_; 
  my @toks = $tokens->unlist;
  my @new = ();
  while(my $t = pop(@toks)){
    if($t->equals(T_MATH) && @toks && $toks[$#toks]->equals(T_CS('\hfil'))){
      unshift(@new,pop(@toks)); push(@toks,$t); }
    else {
      unshift(@new, $t); }}
  @new; }


#----------------------------------------------------------------------
# \halign, See Chap.22

DefPrimitive('\halign BoxSpecification {}', sub {
  my($stomach,$spec,$contents)=@_;
  my @tokens = $contents->unlist;
  my @template = ();
  my $t;
  while(!($t=shift(@tokens))->equals(T_CS('\cr'))){
    push(@template,$t); }
  my $template = LaTeXML::AlignmentTemplate->new();
  my $b=1;
  my @pre=();
  foreach my $t (@template){
    if($t->equals(T_PARAM)){
      $template->addColumn(before=>Tokens(@pre)); 
      @pre=(); $b=0; }
    elsif($t->equals(T_ALIGN)){
      if($b){ $template->setRepeating; }
      else {  $b=1; }}
    elsif($b){
      push(@pre,$t) unless !@pre && $t->equals(T_SPACE); }
    else {
      $template->addAfter($t); }}
#  print STDERR "Template = ".Stringify(Tokens(@template))."\n => ".$template->show."\n";
  alignmentBindings($template);
  Digest(Invocation(T_CS('\@halign'),
		    $spec,Tokens(@template),
		    Tokens(T_CS('\@start@alignment'),@tokens,T_CS('\@finish@alignment')))); });

DefConstructor('\@halign BoxSpecification Undigested {}', 
	       sub {
		 my($document,$spec,$template,$body,%props)=@_;
		 constructAlignment($document,$body,attributes=>{width=>$$spec{to},
								 'pad-width'=>$$spec{spread}}); },
	       reversion=>'\halign #1{#2\cr#3}',
	       bounded=>1);

# "Initialized" alignment; presets spacing, but since we're ignoring it anyway...
Let('\ialign','\halign');

# Overlapping alignments ???
DefMacro('\oalign{}',
	 '\@@oalign{\@start@alignment#1\@finish@alignment}');
DefConstructor('\@@oalign{}',
	       sub { my($document,$body,%props)=@_;
		     constructAlignment($document,$body); },
	       reversion=>'\oalign{#1}', bounded=>1,
	       beforeDigest=>sub { alignmentBindings('l'); });
# This is actually different; the lines should lie ontop of each other.
# How should this be represented?
DefMacro('\ooalign{}',
	 '\@@ooalign{\@start@alignment#1\@finish@alignment}');
DefConstructor('\@@ooalign{}',
	       sub { my($document,$body,%props)=@_;
		     constructAlignment($document,$body); },
	       reversion=>'\ooalign{#1}', bounded=>1,
	       beforeDigest=>sub { alignmentBindings('l'); });


#----------------------------------------------------------------------
DefConstructor('\indent', "");
DefConstructor('\noindent', "");

# <ltx:para> represents a Logical Paragraph, whereas <ltx:p> is a `physical paragraph'.
# A para can contain both p and displayed equations and such.

# Remember; \par closes, not opens, paragraphs!
# Here, we want to close both an open p and para (if either are open).
DefConstructor('\par', 
	       sub { $_[0]->maybeCloseElement('ltx:p');
		     $_[0]->maybeCloseElement('ltx:para'); },
	       alias=>"\\par\n");
Tag('ltx:para', autoClose=>1, autoOpen=>1);

sub trimNodeWhitespace {
  my($document,$node)=@_;
  trimNodeLeftWhitespace($document,$node);
  trimNodeRightWhitespace($document,$node); }

sub trimNodeLeftWhitespace {
  my($document,$node)=@_;
  if(my(@children)=$node->childNodes){
    my $child = $children[0];
    my $type = $child->nodeType;
    if($type == XML_TEXT_NODE){
      my $string = $child->data;
      if($string =~ s/^\s+//){
	$child->setData($string); }}
    elsif($type == XML_ELEMENT_NODE){
      trimNodeLeftWhitespace($document,$child); }}}

sub trimNodeRightWhitespace {
  my($document,$node)=@_;
  if(my(@children)=$node->childNodes){
    my $child = $children[-1];
    my $type = $child->nodeType;
    if($type == XML_TEXT_NODE){
      my $string = $child->data;
      if($string =~ s/\s+$//){
	$child->setData($string); }}
    elsif($type == XML_ELEMENT_NODE){
      trimNodeRightWhitespace($document,$child); }}}


Tag('ltx:p', autoClose=>1, autoOpen=>1, afterClose=>\&trimNodeWhitespace);

# \dump ???

DefPrimitive('\end',sub { $_[0]->getGullet->flush; return; });

#======================================================================
# Horizontal Mode primitives in Ch.25, pp.285--287

# The following cause tex to start a new paragraph -- they switch to horizontal mode.
# <horizontal command> = <letter> | <other> | \char | <chardef token>
#    | \noboundary | \unhbox | \unhcopy | \valign | \vrule 
#    | \hskip | \hfil | \hfill | \hss | \hfilneg 
#    | \accent | \discretionary | \- | \<space> | $

DefPrimitive('\hskip Glue',undef);
DefPrimitive('\mskip MuGlue', undef);
DefPrimitive('\hss',undef);
DefConstructor('\hfil',"?#isMath(<ltx:XMHint name='hfil'/>)( )",
	      properties=>{isSpace=>1, isFill=>1});
DefConstructor('\hfill',"?#isMath(<ltx:XMHint name='hfill'/>)( )",
	      properties=>{isSpace=>1, isFill=>1});
DefPrimitive('\hfilneg',undef);

# \lower <dimen> <box>
# \raise <dimen> <box>
# But <box> apparently must really explicitly be an \hbox, \vbox or \vtop (?)
# OR something that expands into one!!

DefConstructor('\lower Dimension MoveableBox',
	       "<ltx:text raise='#y'>#2</ltx:text>",
	       afterDigest=>sub{
		 $_[1]->setProperty(y=>$_[1]->getArg(1)->multiply(-1)); });
DefConstructor('\raise Dimension MoveableBox',
	       "<ltx:text raise='#y'>#2</ltx:text>",
	       afterDigest=>sub{
		 $_[1]->setProperty(y=>$_[1]->getArg(1)); });

# \unhbox<8bit>, \unhcopy<8bit>
DefExpandable('\unhbox Number',sub {
  my $box = 'box'.$_[1]->valueOf;
  my $stuff = LookupValue($box); 
  AssignValue($box,undef);
  $stuff; });
DefExpandable('\unhcopy Number',sub {
  LookupValue('box'.$_[1]->valueOf); });

# \vrule
# \valign ???

DefConstructor('\vspace{}',"");

# \indent, \noindent, \par; see above.

# \accent Number ????

DefMacro('\discretionary{}{}{}','#3'); # No hyphenation here!
DefPrimitive('\-',undef);
DefPrimitive('\setlanguage Number',undef);

DefMacro('\newpage','');

#======================================================================
# Math mode stuff
# See TeXBook Ch.26
#======================================================================
# Decide whether we're going into or out of math, inline or display.
Tag('ltx:XMText', autoOpen=>1,autoClose=>1);
DefPrimitive('$', sub {
  my($stomach)=@_;
  my $gullet = $stomach->getGullet;
  my $mode = LookupValue('MODE');
  my $op = '\@@BEGININLINEMATH';
  if($mode eq 'display_math'){
    if($gullet->ifNext(T_MATH)){ $gullet->readToken; }
    else { Fatal("Missing \$"); }
    $op = '\@@ENDDISPLAYMATH'; }
  elsif($mode eq 'inline_math'){
    $op = '\@@ENDINLINEMATH'; }
  elsif($gullet->ifNext(T_MATH)){
    $gullet->readToken;
    $op = '\@@BEGINDISPLAYMATH'; }
  $stomach->invokeToken(T_CS($op)); });


# Effectively these are the math hooks, redefine these to do what you want with math?
DefConstructor('\@@BEGINDISPLAYMATH',
	       "<ltx:equation>"
	       . "<ltx:Math mode='display'>"
	       .  "<ltx:XMath>"
	       .   "#body"
	       .  "</ltx:XMath>"
	       . "</ltx:Math>"
	       ."</ltx:equation>",
	       alias=>'$$',
	       beforeDigest=> sub{ $_[0]->beginMode('display_math'); },
	       captureBody=>1);
DefConstructor('\@@ENDDISPLAYMATH'  , "", alias=>'$$',
	       beforeDigest=> sub{ $_[0]->endMode('display_math'); });

DefConstructor('\@@BEGININLINEMATH', 
	       "<ltx:Math mode='inline'>"
	       . "<ltx:XMath>"
	       .  "#body"
	       . "</ltx:XMath>"
	       ."</ltx:Math>",
	       alias=>'$', beforeDigest=> sub{ $_[0]->beginMode('inline_math'); }, captureBody=>1);
DefConstructor('\@@ENDINLINEMATH'   ,"", alias=>'$',
	       beforeDigest=> sub{ $_[0]->endMode('inline_math');});

# Add the TeX code from the object that created this node,
# unless it has already been recorded on another node.
sub add_TeX {
  my($document,$node,$thing)=@_;
  if($thing && (ref $thing eq 'LaTeXML::Whatsit') && !$thing->getProperty('_added_tex')){
    local $LaTeXML::DUAL_BRANCH = 'presentation';
    my $tex = UnTeX($thing);
    $LaTeXML::DUAL_BRANCH = 'content';
    my $ctex = UnTeX($thing);
    $node->setAttribute('tex',$tex);
    $node->setAttribute('content-tex',$ctex) if $ctex ne $tex;
    $thing->setProperty('_added_tex',1); }}

# Same as add_TeX, but add the code from the body of the object.
sub add_body_TeX {
  my($document,$node,$thing)=@_;
  if($thing && !$thing->getProperty('_added_body_tex')){
    if(defined(my $body = $thing->getProperty('body'))){
      local $LaTeXML::DUAL_BRANCH = 'presentation';
      my $tex = UnTeX($body);
      $LaTeXML::DUAL_BRANCH = 'content';
      my $ctex = UnTeX($body);
      $node->setAttribute('tex',$tex);
      $node->setAttribute('content-tex',$ctex) if $ctex ne $tex;
    }
    $thing->setProperty('_added_body_tex',1); }}

Tag('ltx:Math',   afterOpen=>\&add_body_TeX);
Tag('ltx:Math',  afterClose=>\&cleanup_Math);

sub cleanup_Math {
  my($document,$mathnode)=@_;
  # If the Math contains ONLY XMath that ONLY contain XMText,
  # it apparently isn't math at all!?!  So pull up the contents of the XMText's.
  foreach my $xnode ($mathnode->childNodes){
    return unless $document->getNodeQName($xnode) eq 'ltx:XMath';
    foreach my $mnode ($xnode->childNodes){
      return unless $document->getNodeQName($mnode) eq 'ltx:XMText';
    }}
  # Replace Math/XMath/XMText/* by *
  replace_node($mathnode,
	       map($_->childNodes,map($_->childNodes,$mathnode->childNodes))); }

sub replace_node {
  my($oldnode,@newnodes)=@_;
  my $parent = $oldnode->parentNode;
  if(!@newnodes){
    $parent->removeChild($oldnode); }
  else {
    my $new = shift(@newnodes);
    $parent->replaceChild($new,$oldnode);
    foreach my $n (@newnodes){
      $parent->insertAfter($n,$new);
      $new = $n; }}}

Let('\vcenter', '\vbox');

# May need further work to integrate; probably needs to be displayed,
# and should be added as refnum attribute to some container.
DefConstructor('\eqno BalancedParen',  "^ refnum='#1'");
DefConstructor('\leqno BalancedParen', "^ refnum='#1'");

#======================================================================
# Scripts are a bit of a strange beast, with respect to when the arguments
# are processed, and what kind of object should be created.
#
# While scripts look like they take a normal TeX argument, they really
# take the next BOX (AFTER expansion & digestion)!  Thus, while
#   a^\frac{b}{c} and a^\mathcal{B} 
# DO work in TeX, other things like
#   a^\sqrt{3} or a^\acute{b}
# DO NOT! (Hint: consider the expansions)
# Note that with
#  \def\xyz{xyz}
#   a^\xyz   =>  a^{x}yz
# So, we try to mimic, but note that our boxes don't correspond 100% to TeX's
#
# Normally, sub/super scripts should be turned into a sort of postfix operator:
# The parser will attach the script to the appropriate preceding object.
# However, there are a few special cases involving empty boxes {}.
# If the argument is an empty box $x^{}$, the whole script should just disappear.
# If the PRECEDING box is {} (in ${}^{p}$, a sort of `floating' script should be created.
# This may combine, in the parser, with the following object to generate
# a prescript.

our %scriptstylemap=(display=>'script', text=>'script', 
		     script=>'scriptscript', scriptscript=>'scriptscript');

sub isEmpty {
  my($box)=@_;
my $is=
  (!$box || $box->getProperty('isSpace')
   || ((ref $box eq 'LaTeXML::Whatsit')
       && ($box->getDefinition eq $STATE->lookupMeaning(T_BEGIN))
       && !grep(!isEmpty($_), $box->getBody->unlist))); 

##print STDERR "Box ".Stringify($box)." is empty: ".($is ? "yes":"no")."\n";
  $is;
}
  
sub scriptHandler {
  my($stomach,$op)=@_;
  my $gullet = $stomach->getGullet;
  $gullet->skipSpaces;
  my $style = LookupValue('mathstyle'); # Bump the math style smaller.
  if(defined $style){
    my $cs = '\@@POST'.$op;
    # Check if preceding box, if any, is empty {}
    my $prev = $LaTeXML::LIST[$#LaTeXML::LIST];
    if(! $prev){		# No box at all?
      $cs = '\@@FLOATING'.$op; }
    elsif(isEmpty($prev)){	# Or empty (remove it)
      pop(@LaTeXML::LIST);
      $cs = '\@@FLOATING'.$op; }
    elsif((ref $prev eq 'LaTeXML::Whatsit') # Or previous sub/supscript.
	  && (($prev->getDefinition eq $STATE->lookupMeaning(T_CS('\@@FLOATINGSUPERSCRIPT')))
	      || ($prev->getDefinition eq $STATE->lookupMeaning(T_CS('\@@FLOATINGSUBSCRIPT'))))){
      $cs = '\@@FLOATING'.$op; }


    AssignValue(mathstyle=>$scriptstylemap{$style});
    # Now, get following boxes
    my @stuff = $stomach->invokeToken($gullet->readXToken);
    Fatal("Missing { in sub/super-script argument") unless @stuff;
    my $script = shift(@stuff);	# ONLY this box is the script!
    my $level = $stomach->getBoxingLevel;
    unshift(@stuff,
	    LaTeXML::Whatsit->new(LookupDefinition(T_CS($cs)),[$script],
				  locator=>$gullet->getLocator,
				  font=>$script->getFont,isMath=>1,
				  level=>$level))
      if $script->toString ne '{}';    # ONLY If Script is not empty!!!
    AssignValue(mathstyle=>$style); # revert
    @stuff; }
  else {			# Non math use of _ ??
    my $c = (($op eq 'SUPERSCRIPT') ? '^' : '_');
    Error("Script $c can only appear in math mode");
    LaTeXML::Box->new($c,
		      $STATE->lookupValue('font'),$gullet->getLocator,
		      (($op eq 'SUPERSCRIPT') ? T_SUPER : T_SUB));
  }}

DefPrimitive('^', sub{ scriptHandler($_[0],'SUPERSCRIPT'); });
DefPrimitive('_', sub{ scriptHandler($_[0],'SUBSCRIPT'); });

DefConstructor('\@@POSTSUPERSCRIPT{}',
	       "<ltx:XMApp role='POSTSUPERSCRIPT' scriptpos='#level'>"
	       . "<ltx:XMArg rule='Superscript'>#1</ltx:XMArg>"
	       ."</ltx:XMApp>",
	       alias=>'^');
DefConstructor('\@@POSTSUBSCRIPT{}',
	       "<ltx:XMApp role='POSTSUBSCRIPT' scriptpos='#level'>"
	       . "<ltx:XMArg rule='Subscript'>#1</ltx:XMArg>"
	       ."</ltx:XMApp>",
	       alias=>'_');
DefConstructor('\@@FLOATINGSUPERSCRIPT{}',
	       "<ltx:XMApp role='FLOATSUPERSCRIPT' scriptpos='#level'>"
	       . "<ltx:XMArg rule='Superscript'>#1</ltx:XMArg>"
	       ."</ltx:XMApp>",
	       alias=>'{}^');
DefConstructor('\@@FLOATINGSUBSCRIPT{}',
	       "<ltx:XMApp role='FLOATSUBSCRIPT' scriptpos='#level'>"
	       . "<ltx:XMArg rule='Subscript'>#1</ltx:XMArg>"
	       ."</ltx:XMApp>",
	       alias=>'{}_');

## NOTE: Strictly speaking, these two should examine the scriptpos
# attribute of the base (it may have \limits,\nolimits)
## OR, alternatively, there could be separate \@OVERSCRIPT/\@UNDERSCRIPT macros ?
DefConstructor('\@SUPERSCRIPT{}{}', 
	       "?#2(<ltx:XMApp>"
	       .     "<ltx:XMTok role='SUPERSCRIPTOP' scriptpos='#scriptpos'/>"
	       .     "<ltx:XMArg>#1</ltx:XMArg>"
	       .     "<ltx:XMArg rule='Superscript'>#2</ltx:XMArg>"
	       .   "</ltx:XMApp>)"
	       .   "(#1)",
	       reversion=> sub {
		 my($whatsit,$base,$sup)=@_;
		 ($sup && $sup->unlist 
		  ? (T_BEGIN,$base->revert,T_END,
		     T_SUPER,T_BEGIN,$sup->revert,T_END)
		  : $base->revert); },
	       properties=>{scriptpos=>sub{ "post".$_[0]->getBoxingLevel; }});
DefConstructor('\@SUBSCRIPT{}{}', 
	       "?#2(<ltx:XMApp>"
	       .     "<ltx:XMTok role='SUBSCRIPTOP' scriptpos='#scriptpos'/>"
	       .     "<ltx:XMArg>#1</ltx:XMArg>"
	       .     "<ltx:XMArg rule='Subscript'>#2</ltx:XMArg>"
	       .   "</ltx:XMApp>)"
	       .   "(#1)",
	       reversion=>sub {
		 my($whatsit,$base,$sub)=@_;
		 ($sub && $sub->unlist 
		  ? (T_BEGIN,$base->revert,T_END,
		     T_SUB,T_BEGIN,$sub->revert,T_END)
		  : $base->revert); },
	       properties=>{scriptpos=>sub{ "post".$_[0]->getBoxingLevel; }});

# This only becomes active in math mode.
AssignCatcode('math:\''=>1, 'global');
DefMacro('\'',sub{
  my($gullet)=@_;
  my $n = 1;
  while($gullet->ifNext(T_OTHER('\''))){ $gullet->readToken; $n++; };
  (T_SUPER,T_BEGIN,map(T_CS('\prime'), 1..$n),T_END); });

#======================================================================
# \choose & friends, also need special argument handling

# After digesting the \choose (or whatever), grab the previous and following material
# and store as args in the whatsit.
our %fracstylemap=(display=>'text', text=>'script',
		   script=>'scriptscript', scriptscript=>'scriptscript');
sub chooseArgHandler {
  my($stomach,$whatsit)=@_;
  my $style = LookupValue('mathstyle');
  AssignValue(mathstyle=>$fracstylemap{$style}); # Bump the style smaller.
  # Unfortunately, the way we've done it, it's too late for the numerator!!!
  my @top = $stomach->regurgitate;
  my @bot = $stomach->digestNextBody;
  my $closing = pop(@bot);	# We'll leave whatever closed the list (endmath, endgroup...)
#  $whatsit->setArgs(LaTeXML::MathList->new(@top),LaTeXML::MathList->new(@bot));
  $whatsit->setProperty(top=>LaTeXML::MathList->new(@top));
  $whatsit->setProperty(bottom=>LaTeXML::MathList->new(@bot));
  $whatsit->setProperty(style=>LookupValue('mathstyle'));

  AssignValue(mathstyle=>$style);
  $closing; }			# leave the closing bit

# WHY did I change to top/bottom instead of #1,#2 ????
# This will inhibit comparisons!!!!
# Is it because of the delims forms already having args???
# No, because constructor doesn't know there are 2 extra args!!
DefConstructor('\choose',
	       "<ltx:XMApp open='(' close=')'>"
	       . "<ltx:XMTok meaning='binomial' role='STACKED' style='#style'/>"
	       . "<ltx:XMArg>#top</ltx:XMArg>"
	       . "<ltx:XMArg>#bottom</ltx:XMArg>"
	       ."</ltx:XMApp>",
	       afterDigest=>\&chooseArgHandler,
	       reversion=>sub {
		 my($whatsit)=@_;
		 ($whatsit->getProperty('top')->revert,
		  T_CS('\choose'),
		  $whatsit->getProperty('bottom')->revert); });
DefConstructor('\over',
	       "<ltx:XMApp>"
	       . "<ltx:XMTok meaning='div' style='#style' role='MULOP'/>"
	       . "<ltx:XMArg>#top</ltx:XMArg>"
	       . "<ltx:XMArg>#bottom</ltx:XMArg>"
	       ."</ltx:XMApp>",
	       afterDigest=>\&chooseArgHandler,
	       reversion=>sub {
		 my($whatsit)=@_;
		 ($whatsit->getProperty('top')->revert,
		  T_CS('\over'),
		  $whatsit->getProperty('bottom')->revert); });
DefConstructor('\atop',
	       "<ltx:XMApp>"
	       . "<ltx:XMTok role='STACKED' style='#style'/>"
	       . "<ltx:XMArg>#top</ltx:XMArg>"
	       . "<ltx:XMArg>#bottom</ltx:XMArg>"
	       ."</ltx:XMApp>",
	       afterDigest=>\&chooseArgHandler,
	       reversion=>sub {
		 my($whatsit)=@_;
		 ($whatsit->getProperty('top')->revert,
		  T_CS('\atop'),
		  $whatsit->getProperty('bottom')->revert); });
DefConstructor('\overwithdelims Token Token',
	       "<ltx:XMApp open='#1' close='#2'>"
	       . "<ltx:XMTok meaning='div' style='#style' role='MULOP'/>"
	       . "<ltx:XMArg>#top</ltx:XMArg>"
	       . "<ltx:XMArg>#bottom</ltx:XMArg>"
	       ."</ltx:XMApp>",
	       afterDigest=>\&chooseArgHandler,
	       reversion=> sub {
		 my($whatsit,@args)=@_;
		 ($whatsit->getProperty('top')->revert,
		  $whatsit->getDefinition->invocation(@args),
		  $whatsit->getProperty('bottom')->revert); });
# But, wonder what the _meaning_ is!
DefConstructor('\atopwithdelims Token Token',
	       "<ltx:XMApp open='#1' close='#2'>"
	       . "<ltx:XMTok role='STACKED'  style='#style'/>"
	       . "<ltx:XMArg>#top</ltx:XMArg>"
	       . "<ltx:XMArg>#bottom</ltx:XMArg>"
	       ."</ltx:XMApp>",
	       afterDigest=>\&chooseArgHandler,
	       reversion=>sub {
		 my($whatsit,@args)=@_;
		 ($whatsit->getProperty('top')->revert,
		  $whatsit->getDefinition->invocation(@args),
		  $whatsit->getProperty('bottom')->revert); });

sub IsZero {
  my($dim)=@_;
  (!defined $dim) || ($dim->valueOf == 0); }

DefConstructor('\abovewithdelims Token Token Dimension',
	       "<ltx:XMApp open='#1' close='#2'>"
	       . "<ltx:XMTok ?&IsZero(#3)(role='STACKED')(role='MULOP' meaning='div')"
	       .           " style='#style' thickness='#3'/>"
	       . "<ltx:XMArg>#top</ltx:XMArg>"
	       . "<ltx:XMArg>#bottom</ltx:XMArg>"
	       ."</ltx:XMApp>",
	       afterDigest=>\&chooseArgHandler,
	       reversion=> sub {
		 my($whatsit,@args)=@_;
		 ($whatsit->getProperty('top')->revert,
		  $whatsit->getDefinition->invocation(@args),
		  $whatsit->getProperty('bottom')->revert); });

#======================================================================
DefConstructor('\cal', '', requireMath=>1, font=>{family=>'caligraphic'});

DefConstructor('\@end@emph','</ltx:emph>');
DefConstructor('\em',"<ltx:emph>", 
	       afterDigest=>sub { UnshiftValue(beforeAfterGroup=>T_CS('\@end@emph')); });

# Change math font while still in text!
DefPrimitive('\boldmath',  sub { AssignValue(mathfont=>LookupValue('mathfont')->merge(forcebold=>1), 'local'); },
	     forbidMath=>1);
DefPrimitive('\unboldmath',sub { AssignValue(mathfont=>LookupValue('mathfont')->merge(forcebold=>0), 'local'); },
	     forbidMath=>1);

#======================================================================
# Alignments

# & gives an error except within the right context 
# (which should redefine it!)
DefConstructor('&',sub { Error("Stray \"&\""); });

#**********************************************************************
# Plain;  Extracted from Appendix B.
#**********************************************************************

#======================================================================
# TeX Book, Appendix B, p. 344
#======================================================================
# \dospecials ??

# Set up the mathcode table

#======================================================================
# Properties for plain characters.
# These are allowed in plain text, but need to act a bit special in math.
DefMath('=','=', role=>'RELOP', meaning=>'eq');
DefMath('>','>', role=>'RELOP', meaning=>'greater');
DefMath('<','<', role=>'RELOP', meaning=>'less');
DefMath('+','+', role=>'ADDOP', meaning=>'plus');
DefMath('-','-', role=>'ADDOP', meaning=>'minus');
DefMath('*','*', role=>'MULOP', meaning=>'times');
DefMath('/','/', role=>'MULOP', meaning=>'div', style=>'inline');
DefMath('!','!', role=>'POSTFIX', meaning=>'factorial');
DefMath(',',',', role=>'PUNCT');
DefMath('.','.', role=>'PERIOD');
DefMath(';',';', role=>'PUNCT');
DefMath(':',';', role=>'METARELOP', name=>'colon'); # Seems like good default role
DefMath('(','(', role=>'OPEN'); DefMath(')',')', role=>'CLOSE');
DefMath('[','[', role=>'OPEN'); DefMath(']',']', role=>'CLOSE');
DefMath('|','|', role=>'VERTBAR');

#======================================================================
# Combine letters, when the fonts are right. (sorta related to mathcode)

DefMathLigature(sub { my($document,@nodes)=@_;
		      my @chars = ();
		      my $font = $document->getNodeFont($nodes[$#nodes]);
		      if($font->isSticky){
			my $node;
			my $n=0;
			my $string='';
			my $s='';
			while(($node = pop(@nodes))
			      && ($document->getNodeQName($node) eq 'ltx:XMTok')
			      && ($document->getNodeFont($node)->equals($font))
			      && (!$node->hasAttribute('name'))
			      && (($node->getAttribute('role')||'UNKNOWN') eq 'UNKNOWN')
			      && (($s=$node->textContent.$s) =~ /^[a-zA-Z]+$/)){
			  $n++; $string = $s; }
			($n > 1 ? ($n, $string, role=>'UNKNOWN') : undef); }});

#======================================================================
# Combine digits in math.

foreach my $digit (qw(0 1 2 3 4 5 6 7 8 9)){
  DefMath($digit,$digit, role=>'NUMBER',meaning=>$digit); }

our %space_chars = (negthinspace=>'', thinspace=>"\x{2009}",
		    medspace=>"\x{2005}", thickspace=>"\x{2004}");

DefMathLigature(sub { my($document,@nodes)=@_;
		      my @chars = ();
		      my $font = $document->getNodeFont($nodes[$#nodes]);
		      my ($node,$best,$nbest,$s)=(undef,'',0,'');
		      my $n=0;
		      my $string='';
		      while(($node = pop(@nodes))
			    && ( ( ($document->getNodeQName($node) eq 'ltx:XMTok')
				   && ((($node->getAttribute('role')||'') eq 'NUMBER')
				       || ($node->textContent eq '.'))
				   && defined($s=$node->textContent))
				 || (($document->getNodeQName($node) eq 'ltx:XMHint')
				     && ($s = $space_chars{$node->getAttribute('name')||''})))){
			$n++; 
			if((($string=$s.$string)
			    =~ /^(\d|\x{2009}|\x{2005}|\x{2004})*\.?(\d|\x{2009}|\x{2005}|\x{2004})*$/)
			   && ($string =~/\d/)){ # MUST have at least one digit!
			  $best = $string, $nbest = $n; }}
		      if($nbest > 1){
			my $number = $best; $number =~ s/[^.\d]//g;
			($nbest, $best, meaning=>$number, role=>'NUMBER'); }});


#======================================================================
# TeX Book, Appendix B, p. 345

RawTeX('
  \chardef\@ne=1
  \chardef\tw@=2
  \chardef\thr@@=3
  \chardef\sixt@@n=16
  \chardef\@cclv=255
  \chardef\@cclvi=256
  \chardef\@m=1000
  \chardef\@M=10000
  \chardef\@MM=20000');

#======================================================================
# TeX Book, Appendix B, p. 346

RawTeX('
  \countdef\count@=255
  \toksdef\toks@=0
  \skipdef\skip@=0
  \dimendef\dimen@i=1
  \dimendef\dimen@ii=2');
# Various \count's are set; should we?

#======================================================================
# TeX Book, Appendix B, p. 347
# \wlog ??
# From plain.tex
DefPrimitive('\newcount  Token',sub { DefRegister($_[1]->toString=>Number(0)); });
DefPrimitive('\newdimen  Token',sub { DefRegister($_[1]->toString=>Dimension(0)); });
DefPrimitive('\newskip   Token',sub { DefRegister($_[1]->toString=>Glue(0)); });
DefPrimitive('\newmuskip Token',sub { DefRegister($_[1]->toString=>MuGlue(0)); });
DefPrimitive('\newbox    Token',sub { DefRegister($_[1]->toString=>Tokens()); });
DefPrimitive('\newhelp Token {}',sub { AssignValue($_[1]->toString=>$_[2]); });
DefPrimitive('\newtoks   Token',sub { DefRegister($_[1]->toString=>Tokens(0)); });
DefPrimitive('\newread Token',  sub { DefRegister($_[1]->toString=>Number(0)); });
DefPrimitive('\newwrite Token', sub { DefRegister($_[1]->toString=>Number(0)); });
DefPrimitive('\newfam Token',   sub { DefRegister($_[1]->toString=>Number(0)); });
DefPrimitive('\newlanguage Token',sub { DefRegister($_[1]->toString=>Number(0)); });
DefPrimitive('\newinsert Token', sub { DefRegister($_[1]->toString=>Number(0)); });
# \alloc@, \ch@ck

# TeX plain uses \newdimen, etc. for these.
# Is there any advantage to that?
DefRegister('\maxdimen',Dimension(16383.99999*65536));
DefRegister('\hideskip',Glue(-1000*65536,'1fill'));
DefRegister('\centering',Glue('0pt plus 1000pt minus 1000pt'));
DefRegister('\p@',Dimension(65536));
DefRegister('\z@',Dimension(0));
DefRegister('\z@skip',Glue(0,0,0));

# First approximation. till I figure out \newbox
#  \newbox\voidb@x
DefMacro('\voidb@x','');

#======================================================================
# TeX Book, Appendix B, p. 348

DefExpandable('\newif Token',sub {
  my($ignore,$cs)=@_;
  my $name = $cs->toString; $name =~ s/^\\if//;
  DefExpandable($cs->toString, sub { ifHandler($_[0],LookupValue('Boolean:'.$name)); }, isConditional=>1);
  DefPrimitive('\\'.$name.'true', sub { AssignValue('Boolean:'.$name => 1); });
  DefPrimitive('\\'.$name.'false', sub { AssignValue('Boolean:'.$name => 0); });  });

# See the section Registers & Parameters, above for setting default values.
#======================================================================
# TeX Book, Appendix B, p. 349
# See the section Registers & Parameters, above for setting default values.

# These are originally defined with \newskip, etc
DefRegister('\smallskipamount' => Glue('3pt plus1pt minus1pt'));
DefRegister('\medskipamount'   => Glue('6pt plus2pt minus2pt'));
DefRegister('\bigskipamount'   => Glue('12pt plus4pt minus4pt'));
DefRegister('\normalbaselineskip' => Glue('12pt'));
DefRegister('\normallineskip'  => Glue('1pt'));
DefRegister('\normallineskiplimit'=> Dimension('0pt'));
DefRegister('\jot'  => Dimension('3pt'));
DefRegister('\interdisplaylinepenalty' => Number(100));
DefRegister('\interfootnotelinepenalty' => Number(100));

DefMacro('\magstephalf','1095');
our @mags=(1000,1200,1440,1728,2074,2488);
DefExpandable('\magstep{}', sub { Explode($mags[$_[1]->toString]);});

#======================================================================
# TeX Book, Appendix B, p. 350

# Font stuff ...
RawTeX('
 \font\tenrm=cmr10
 \font\sevenrm=cmr7
 \font\fiverm=cmr5
 \font\teni=cmmi10
 \font\seveni=cmmi7
 \font\fivei=cmmi7
 \font\tensy=cmsy10
 \font\sevensy=cmsy7
 \font\fivesy=cmsy5
 \font\tenex=cmex10
 \font\tenbf=cmbx10
 \font\sevenbf=cmbx7
 \font\fivebf=cmbx5
 \font\tensl=cmsl10
 \font\tentt=cmtt10
 \font\tenit=cmti10
 \newfam\itfam
 \newfam\slfam
 \newfam\bffam
 \newfam\ttfam
 ');
# Note: \newfam in math should be font switching(?)

#======================================================================
# TeX Book, Appendix B, p. 351

# Old style font styles.
# The trick is to create an empty Whatsit preserved till assimilation (for reversion'ing)
# but to change the current font used in boxes.
# (some of these were defined on different pages? or even latex...)
Tag('ltx:text',autoOpen=>1,autoClose=>1);

DefConstructor('\rm', '',  font=>{family=>'serif'});
DefConstructor('\sf', '',  font=>{family=>'sansserif'});
DefConstructor('\bf',  '', font=>{series=>'bold'});
DefConstructor('\it',  '', font=>{shape=>'italic'});
DefConstructor('\tt',  '', font=>{family=>'typewriter'});
DefConstructor('\sl',  '', font=>{shape=>'slanted'});# No effect in math ?
DefConstructor('\sc',  '', font=>{shape=>'smallcaps'});# No effect in math ?
DefConstructor('\tiny',          '', font=>{size=>'tiny'});
DefConstructor('\scriptsize',    '', font=>{size=>'script'});
DefConstructor('\footnotesize',  '', font=>{size=>'footnote'});
DefConstructor('\small',         '', font=>{size=>'small'});
DefConstructor('\normalsize',    '', font=>{size=>'normal'});
DefConstructor('\large',         '', font=>{size=>'large'});
DefConstructor('\Large',         '', font=>{size=>'Large'});
DefConstructor('\LARGE',         '', font=>{size=>'LARGE'});
DefConstructor('\huge',          '', font=>{size=>'huge'});
DefConstructor('\Huge',          '', font=>{size=>'Huge'});

DefConstructor('\mit',       '',   requireMath=>1, font=>{family=>'italic'});

DefPrimitive('\frenchspacing', undef);
DefPrimitive('\nonfrenchspacing',undef);
DefMacro('\normalbaselines',
	 '\lineskip=\normallineskip\baselineskip=\normalbaselineskip\lineskiplimit=\normallineskiplimit');
DefMacro('\space',Tokens(T_SPACE));
DefMacro('\lq',"`");
DefMacro('\rq',"'");
Let('\empty',T_CS('\@empty'));
DefMacro('\null','\hbox{}');
Let('\bgroup',T_BEGIN);
Let('\egroup',T_END);

DefPrimitive('\endline', undef);

#======================================================================
# TeX Book, Appendix B, p. 352

DefPrimitive('\obeyspaces',undef);
DefPrimitive('\obeylines',undef);

RawTeX(' \def\loop#1\repeat{\def\body{#1}\iterate}
         \def\iterate{\body \let\next=\iterate \else\let\next=\relax\fi \next}
         \let\repeat=\fi ');

DefConstructor('\enskip',  "?#isMath(<ltx:XMHint name='enskip'/>)(\x{2000})",
	       properties=>{isSpace=>1}); # EN QUAD
DefConstructor('\enspace', "?#isMath(<ltx:XMHint name='enskip'/>)(\x{2000})",
	      properties=>{isSpace=>1}); # EN QUAD
DefConstructor('\quad', "?#isMath(<ltx:XMHint name='quad'/>)(\x{2001})",
	      properties=>{isSpace=>1}); # EM QUAD
DefConstructor('\qquad',"?#isMath(<ltx:XMHint name='qquad'/>)(\x{2001}\x{2001})",
	      properties=>{isSpace=>1}); # EM QUAD

DefConstructor('\thinspace',   "?#isMath(<ltx:XMHint name='thinspace'/>)( )",
	      properties=>{isSpace=>1});
DefConstructor('\negthinspace',"?#isMath(<ltx:XMHint name='negthinspace'/>)()",
	      properties=>{isSpace=>1});
DefConstructor('\thickspace',  "?#isMath(<ltx:XMHint name='thickspace'/>)( )",
	      properties=>{isSpace=>1});

DefConstructor('\hglue Glue', "?#isMath(<ltx:XMHint name='#1'/>)(\x{2001})",
	      properties=>{isSpace=>1}); # EM QUAD
DefPrimitive('\vglue Glue', undef);
DefPrimitive('\topglue', undef);
DefPrimitive('\nointerlineskip',undef);
DefPrimitive('\offinterlineskip',undef);

DefConstructor('\smallskip',"");
DefConstructor('\medskip',"");
DefConstructor('\bigskip',"");

#======================================================================
# TeX Book, Appendix B, p. 353

DefPrimitive('\break',undef);
DefPrimitive('\nobreak',undef);
DefPrimitive('\allowbreak',undef);
DefConstructor("~","?#isMath(<ltx:XMHint name='nobreakspace'/>)(".UTF(0xA0).")",
	      properties=>{isSpace=>1}); # NO-BREAK SPACE

DefMacro('\slash','/');
DefPrimitive('\filbreak',undef);
DefMacro('\goodbreak','\par');
DefMacro('\eject','\par');
DefMacro('\supereject','\par');
DefPrimitive('\removelastskip',undef);
DefMacro('\smallbreak','\par');
DefMacro('\medbreak','\par');
DefMacro('\bigbreak','\par');

DefMacro('\line','\hbox to \hsize');
DefMacro('\leftline{}','\line{#1\hss}');
DefMacro('\rightline{}','\line{\hss#1}');
DefConstructor('\centerline{}',"<ltx:centering>#1</ltx:centering>");
DefMacro('\llap{}','\hbox{#1}');
DefMacro('\rlap{}','\hbox{#1}');
DefMacro('\m@th','\mathsurround=0pt ');

# \strutbox
DefMacro('\strut','');
DefRegister('\strutbox'=>Tokens());

#======================================================================
# TeX Book, Appendix B. p. 354

# TODO: Not yet done!!
# \ialign, and tabbing stuff!!!

DefMacro('\settabs', undef);
DefPrimitive('\ialign', undef);

#======================================================================
# TeX Book, Appendix B. p. 355

DefPrimitive('\hang',undef);

# TODO: \item, \itemitem not done!
# This could probably be adopted from LaTeX, if the <itemize> could auto-open
# and close!
DefConstructor('\item{}','#1');
DefConstructor('\itemitem{}','#1');

DefMacro('\textindent{}','#1');

# Conceivably this should enclose the next para in a block?
# Or add attribute to it? Or...
DefPrimitive('\narrower',undef);

#----------------------------------------------------------------------
# General support for Front Matter.
# Not (yet) used by TeX (finish plain?)
# But provides support for LaTeX (and other formats?) for handling frontmatter.
#
# The idea is to accumulate any frontmatter material (title, author,...)
# rather than directly drop it into the digested stream.
# When we begin constructing the document, all accumulated material is output.
# See LaTeX.ltxml for usage.

# Note: could be circumstances where you'd want modular frontmatter?
# (ie. frontmatter for each sectional unit)
AssignValue(frontmatter=>{},'global');

push(@{ LookupValue('frontmatter')->{date}},
     ['ltx:date',{role=>'conversion'}, today()])
  if LookupValue('INCLUDE_COMMENTS');

# Add a new frontmatter item that will be enclosed in <$tag %attr>...</$tag>
# The content is the result of digesting $tokens.
# \@add@frontmatter{tag}[attributes]{content}
DefPrimitive('\@add@frontmatter {} OptionalKeyVals {}', sub {
  my($stomach,$tag,$keys,$tokens)=@_;
  $tag = ToString($tag);
  my $attr = ($keys ? {$keys->beDigested($stomach)->getHash} : undef);

  my $frontmatter = LookupValue('frontmatter');
  my $inpreamble = LookupValue('inPreamble');
  AssignValue(inPreamble=>0);
  my $datum = Digest($tokens);
  AssignValue(inPreamble=>$inpreamble);
  push(@{$$frontmatter{$tag}},[$tag,$attr,$datum]);
  return; });

# Append a piece of data to an existing frontmatter item that is contained in <$tag>
# If $label is given, look for an item which has label=>$label,
# otherwise, just append to the last item in $tag.

# \@add@to@frontmatter{tag}[label]{content}
DefPrimitive('\@add@to@frontmatter {} [] {}', sub {
  my($stomach,$tag,$label,$tokens)=@_;
  $tag   = ToString($tag);
  $label = ToString($label) if $label;
  my $frontmatter = LookupValue('frontmatter');

  my $inpreamble = LookupValue('inPreamble');
  AssignValue(inPreamble=>0);
  my $datum = Digest($tokens);
  AssignValue(inPreamble=>$inpreamble);

  if($label){
    my $entry;
    foreach my $item (@{$$frontmatter{$tag} || []}){
      my($itag,$iattr,@stuff)=@$item;
      if($label eq ($$iattr{label}||'')){
	push(@$item,$datum); 
	return; }}}
  elsif(my $list = $$frontmatter{$tag}){
    push(@{$$list[-1]},$datum); 
    return;}
  push(@{$$frontmatter{$tag}},[$tag,($label ? {label=>$label} : undef),$datum]);
  return; });

# This is called by afterOpen (by default on <ltx:document>) to
# output any frontmatter that was accumulated.

sub insertFrontMatter {
  my($document)=@_;
  my $frontmatter = LookupValue('frontmatter');
  foreach my $key ('ltx:title','ltx:toctitle','ltx:subtitle','ltx:creator','ltx:date',
		   grep($_ !~/^(ltx:title|ltx:toctitle|ltx:subtitle|ltx:creator|ltx:date)$/, 
			keys %$frontmatter)){
    if(my $list = $$frontmatter{$key}){
      # Dubious, but assures that frontmatter appears in text mode...
      local $LaTeXML::BOX = LaTeXML::Box->new('', $STATE->lookupValue('font'),'',T_SPACE);
      foreach my $item (@$list){
	my($tag,$attr,@stuff)=@$item;
	$document->openElement($tag,($attr ? %$attr : ()));
	map($document->absorb($_), @stuff);
	$document->closeElement($tag); }}}
  return; }

Tag('ltx:document', afterOpen=>\&insertFrontMatter);

DefConstructor('\beginsection{}',
	       "<ltx:section><ltx:title>#1</ltx:title>");
# \proclaim ?
# TODO: Not yet done; actually is much like LaTeX's theorem env.

#======================================================================
# TeX Book, Appendix B. p. 356

DefPrimitive('\raggedright',undef);
DefPrimitive('\raggedleft',undef);  # this is actually LaTeX
DefPrimitive('\ttraggedright',undef);
DefPrimitive('\leavevmode',undef);

#----------------------------------------------------------------------
# Actually from LaTeX; Table 3.2. Non-English Symbols, p.39

# The following shouldn't appear in math.
DefConstructor('\OE',"\x{0152}");	# LATIN CAPITAL LIGATURE OE
DefConstructor('\oe',"\x{0153}");	# LATIN SMALL LIGATURE OE
DefConstructor('\AE',UTF(0xC6));	# LATIN CAPITAL LETTER AE
DefConstructor('\ae',UTF(0xE6));	# LATIN SMALL LETTER AE
DefConstructor('\AA',UTF(0xC5));	# LATIN CAPITAL LETTER A WITH RING ABOVE
DefConstructor('\aa',UTF(0xE5));	# LATIN SMALL LETTER A WITH RING ABOVE
DefConstructor('\O', UTF(0xD8));	# LATIN CAPITAL LETTER O WITH STROKE
DefConstructor('\o', UTF(0xF8));	# LATIN SMALL LETTER O WITH STROKE
DefConstructor('\L', "\x{0141}");	# LATIN CAPITAL LETTER L WITH STROKE
DefConstructor('\l', "\x{0142}");	# LATIN SMALL LETTER L WITH STROKE
DefConstructor('\ss',UTF(0xDF));	# LATIN SMALL LETTER SHARP S

# apparently the rest can appear in math.
DefConstructor('\dag',   "\x{2020}");	# DAGGER
DefConstructor('\ddag',  "\x{2021}");	# DOUBLE DAGGER
DefConstructor('\S',     UTF(0xA7));	# SECTION SIGN
DefConstructor('\P',     UTF(0xB6));	# PILCROW SIGN
DefConstructor('\copyright',UTF(0xA9)); # COPYRIGHT SIGN
DefConstructor('\pounds',UTF(0xA3));	# POUND SIGN

#----------------------------------------------------------------------
# Accents.  LaTeX Table 3.1, p.38
#----------------------------------------------------------------------
# All of TeX's accents can (sorta) be handled by Unicode's combining accents
# (which follow the character to be accented).
# We'll let unicode normalization do the combination, if needed.
# Also, note that \t is intended to combine multiple chars, but it appears to
# work (via mozilla !?) best when the combining char is after the 1st char.
# Further, the accents \d and \b seem to center the under dot or bar under multiple
# chars --- how should this be handled in Unicode?

# Since people sometimes try to get fancy by using an empty argument,
# for each, I'm providing the combining code and an equivalent(?) spacing one.
our %accents
  = ('\`' => ["\x{0300}",UTF(0x60)], # COMBINING GRAVE ACCENT & GRAVE ACCENT
     "\\'"=> ["\x{0301}",UTF(0xB4)], # COMBINING ACUTE ACCENT & ACUTE ACCENT
     '\^' => ["\x{0302}",UTF(0x5E)], # COMBINING CIRCUMFLEX ACCENT & CIRCUMFLEX ACCENT
     '\"' => ["\x{0308}",UTF(0xA8)], # COMBINING DIAERESIS & DIAERESIS
     '\~' => ["\x{0303}","~"],	      # COMBINING TILDE
     '\=' => ["\x{0304}",UTF(0xAF)], # COMBINING MACRON & MACRON
     '\.' => ["\x{0307}",UTF(0xB7)], # COMBINING DOT ABOVE & MIDDLE DOT (?)
     '\u' => ["\x{0306}","\x{02D8}"], # COMBINING BREVE & BREVE
     '\v' => ["\x{030C}","\x{02C7}"], # COMBINING CARON & CARON
     '\@ringaccent' => ["\x{030A}","o"], # COMBINING RING ABOVE & non-combining
     '\H' => ["\x{030B}","\x{02DD}"], # COMBINING DOUBLE ACUTE ACCENT & non-combining
     '\c' => ["\x{0327}",UTF(0xB8)], # COMBINING CEDILLA & CEDILLA
     '\d' => ["\x{0323}",UTF(0xB7)], # COMBINING DOT BELOW & MIDDLE DOT (?)
     '\b' => ["\x{0331}",UTF(0xAF)], # COMBINING MACRON BELOW  & MACRON
     '\t' => ["\x{0361}","-"],	# COMBINING DOUBLE INVERTED BREVE & ???? What????
     # this one's actually defined in mathscinet.sty, but just stick it here!
     '\lfhook'=>["\x{0326}",","], # COMBINING COMMA BELOW
     # I doubt that latter covers multiple chars...?
     #		'\bar'=>"\x{0304}", # COMBINING MACRON or is this the longer overbar?
		);

# Defines an accent command using a combining char that follows the
# 1st char of the argument.  In cases where there is no argument, $standalonechar is used.
sub DefAccent {
  my ($accent, $combiningchar, $standalonechar) = @_;
  DefConstructor($accent."{}", sub {
    my($document,$letter,%props)=@_;
    if(my @letters = map(($_ eq '\i' ? 'i':$_),map(ToString($_),$letter->unlist))){
      # Put the accent AFTER the first char(?)
      $document->openText(NFC($letters[0].$combiningchar.join('',@letters[1..$#letters])),
			  $letter->getFont);}
    else {			# Empty argument???
       $document->openText($standalonechar,$props{font}); }} ); }

foreach my $accent (keys %accents) {
  DefAccent($accent, @{$accents{$accent}}); }

#======================================================================
# TeX Book, Appendix B. p. 357

foreach my $op ('\hrulefill','\dotfill','\rightarrowfill','\leftarrowfill',
		'\upbracefill','\downbracefill'){
  DefPrimitive($op,undef); }

Let('\bye','\end');

Let('\sp',T_SUPER);
Let('\sb',T_SUB);
DefConstructor('\,',"?#isMath(<ltx:XMHint name='thinspace'/>)(\x{2009})",
	      properties=>{isSpace=>1}); # THIN SPACE
DefConstructor('\!',"?#isMath(<ltx:XMHint name='negthinspace'/>)()",
	       properties=>{isSpace=>1});
DefConstructor('\>',"?#isMath(<ltx:XMHint name='\>'/>)()",
	      properties=>{isSpace=>1});	# ??
DefConstructor('\;',"?#isMath(<ltx:XMHint name='thickspace'/>)(\x{2004})",
	      properties=>{isSpace=>1}); # THREE-PER-EM SPACE
DefConstructor('\:',"?#isMath(<ltx:XMHint name='medspace'/>)(\x{2005})",
	      properties=>{isSpace=>1});  # FOUR-PER-EM SPACE
DefConstructor('\ ',"?#isMath(<ltx:XMHint name='medspace'/>)(\x{2002})",
	      properties=>{isSpace=>1}); # EN SPACE
DefConstructor('\/',"?#isMath(<ltx:XMHint name='italiccorr'/>)()",
	      properties=>{isSpace=>1});

#======================================================================
# TeX Book, Appendix B. p. 358

#----------------------------------------------------------------------
#  Actually from LaTeX; Table 3.3, Greek, p.41
#----------------------------------------------------------------------
DefMath('\alpha',     "\x{03B1}"); # GREEK SMALL LETTER ALPHA
DefMath('\beta',      "\x{03B2}"); # GREEK SMALL LETTER BETA
DefMath('\gamma',     "\x{03B3}"); # GREEK SMALL LETTER GAMMA
DefMath('\delta',     "\x{03B4}"); # GREEK SMALL LETTER DELTA
DefMath('\epsilon'  , "\x{03F5}"); # GREEK LUNATE EPSILON SYMBOL
DefMath('\varepsilon',"\x{03B5}"); # GREEK SMALL LETTER EPSILON
DefMath('\zeta',      "\x{03B6}"); # GREEK SMALL LETTER ZETA
DefMath('\eta',       "\x{03B7}"); # GREEK SMALL LETTER ETA
DefMath('\theta',     "\x{03B8}"); # GREEK SMALL LETTER THETA
DefMath('\vartheta',  "\x{03D1}"); # GREEK THETA SYMBOL
DefMath('\iota',      "\x{03B9}"); # GREEK SMALL LETTER IOTA
DefMath('\kappa',     "\x{03BA}"); # GREEK SMALL LETTER KAPPA
DefMath('\lambda',    "\x{03BB}"); # GREEK SMALL LETTER LAMDA
DefMath('\mu',        "\x{03BC}"); # GREEK SMALL LETTER MU
DefMath('\nu',        "\x{03BD}"); # GREEK SMALL LETTER NU
DefMath('\xi',        "\x{03BE}"); # GREEK SMALL LETTER XI
DefMath('\pi',        "\x{03C0}"); # GREEK SMALL LETTER PI
DefMath('\varpi',     "\x{03D6}"); # GREEK PI SYMBOL
DefMath('\rho',       "\x{03C1}"); # GREEK SMALL LETTER RHO
DefMath('\varrho',    "\x{03F1}"); # GREEK RHO SYMBOL
DefMath('\sigma',     "\x{03C3}"); # GREEK SMALL LETTER SIGMA
DefMath('\varsigma',  "\x{03C2}"); # GREEK SMALL LETTER FINAL SIGMA
DefMath('\tau',       "\x{03C4}"); # GREEK SMALL LETTER TAU
DefMath('\upsilon',   "\x{03C5}"); # GREEK SMALL LETTER UPSILON
DefMath('\phi',       "\x{03D5}"); # GREEK PHI SYMBOL
DefMath('\varphi',    "\x{03C6}"); # GREEK SMALL LETTER PHI
DefMath('\chi',       "\x{03C7}"); # GREEK SMALL LETTER CHI
DefMath('\psi',       "\x{03C8}"); # GREEK SMALL LETTER PSI
DefMath('\omega',     "\x{03C9}"); # GREEK SMALL LETTER OMEGA
DefMath('\Gamma',     "\x{0393}"); # GREEK CAPITAL LETTER GAMMA
DefMath('\Delta',     "\x{0394}"); # GREEK CAPITAL LETTER DELTA
DefMath('\Theta',     "\x{0398}"); # GREEK CAPITAL LETTER THETA
DefMath('\Lambda',    "\x{039B}"); # GREEK CAPITAL LETTER LAMDA
DefMath('\Xi',        "\x{039E}"); # GREEK CAPITAL LETTER XI
DefMath('\Pi',        "\x{03A0}"); # GREEK CAPITAL LETTER PI
DefMath('\Sigma',     "\x{03A3}"); # GREEK CAPITAL LETTER SIGMA
DefMath('\Upsilon',   "\x{03A5}"); # GREEK CAPITAL LETTER UPSILON
DefMath('\Phi',       "\x{03A6}"); # GREEK CAPITAL LETTER PHI
DefMath('\Psi',       "\x{03A8}"); # GREEK CAPITAL LETTER PSI
DefMath('\Omega',     "\x{03A9}"); # GREEK CAPITAL LETTER OMEGA

#----------------------------------------------------------------------
# Actually from LaTeX; Table 3.7. Miscellaneous Symbols, p.43
#----------------------------------------------------------------------
# Some should be differential operators, qualifiers, ...
DefMath('\aleph',    "\x{2135}");   # ALEF SYMBOL
DefMath('\hbar',     "\x{210F}", role=>'ID');	# PLANCK CONSTANT OVER TWO PI
DefMath('\imath',    "\x{0131}");   # LATIN SMALL LETTER DOTLESS I
DefMath('\jmath',    "j");	    # Unicode?
DefMath('\ell',      "\x{2113}");   # SCRIPT SMALL L
DefMath('\wp',       "\x{2118}", meaning=>'Weierstrassp'); # SCRIPT CAPITAL P
DefMath('\Re',       "\x{211C}", role=>'OPFUNCTION', meaning=>'realpart'); # BLACK LETTER CAPITAL R
DefMath('\Im',       "\x{2111}", role=>'OPFUNCTION', meaning=>'imagpart'); # BLACK LETTER CAPITAL I
DefMath('\mho',      "\x{2127}");   # INVERTED OHM SIGN

DefMath('\prime',    "\x{2032}", role=>'SUPOP');    # PRIME
DefMath('\emptyset', "\x{2205}", role=>'ID', meaning=>'emptyset');	    # EMPTY SET
DefMath('\nabla',    "\x{2207}", role=>'OPERATOR'); # NABLA
DefMath('\surd',     "\x{221A}", role=>'OPERATOR');  # SQUARE ROOT
DefMath('\top',      "\x{22A4}");		     # DOWN TACK
DefMath('\bot',      "\x{22A5}");		     # UP TACK
DefMath('\|',        "\x{2225}", role=>'VERTBAR', name=>'||'); # PARALLEL TO
DefMath('\angle',    "\x{2220}");		   # ANGLE

# NOTE: This is probably the wrong role.
# Also, should probably carry info about Binding for OpenMath
DefMath('\forall',   "\x{2200}", role=>'BIGOP', meaning=>'forall'); # FOR ALL
DefMath('\exists',   "\x{2203}", role=>'BIGOP', meaning=>'exists'); # THERE EXISTS
DefMath('\neg',      UTF(0xAC), role=>'FUNCTION', meaning=>'not'); # NOT SIGN
DefMath('\flat',     "\x{266D}"); # MUSIC FLAT SIGN
DefMath('\natural',  "\x{266E}"); # MUSIC NATURAL SIGN
DefMath('\sharp',    "\x{266F}"); # MUSIC SHARP SIGN
DefMath('\backslash',UTF(0x5C), role=>'MULOP');    # REVERSE SOLIDUS
DefMath('\partial',  "\x{2202}", role=>'OPERATOR'); # PARTIAL DIFFERENTIAL

DefMath('\infty',    "\x{221E}", role=>'ID', meaning=>'infinity'); # INFINITY
DefMath('\Box',      "\x{25A1}");  # WHITE SQUARE
DefMath('\Diamond',  "\x{25C6}");  # WHITE DIAMOND
DefMath('\triangle', "\x{25B2}");  # WHITE UP-POINTING TRIANGLE
DefMath('\clubsuit', "\x{2663}");  # BLACK CLUB SUIT
DefMath('\diamondsuit',"\x{2662}");	# WHITE DIAMOND SUIT
DefMath('\heartsuit',"\x{2661}");	# WHITE HEART SUIT
DefMath('\spadesuit',"\x{2660}");	# BLACK SPADE SUIT

#----------------------------------------------------------------------
DefMath('\smallint',"\x{222B}", meaning=>'integral', role=>'INTOP', 
	font=>{size=>'small'}, scriptpos=>\&doScriptpos); # INTEGRAL

#----------------------------------------------------------------------
# Actually LaTeX; Table 3.8. Variable-sized Symbols, p.44.
#----------------------------------------------------------------------
sub doScriptpos { (LookupValue('mathstyle') eq 'display' ? 'mid' : 'post'); }

DefMath('\sum',      "\x{2211}", role=>'SUMOP', meaning=>'sum',
	scriptpos=>\&doScriptpos); # N-ARY SUMMATION
DefMath('\prod',     "\x{220F}", role=>'SUMOP', meaning=>'product',
	scriptpos=>\&doScriptpos); # N-ARY PRODUCT
DefMath('\coprod',   "\x{2210}", role=>'SUMOP', meaning=>'coproduct',
	scriptpos=>\&doScriptpos); # N-ARY COPRODUCT
DefMath('\int',      "\x{222B}", role=>'INTOP', meaning=>'integral'); # INTEGRAL
DefMath('\oint',     "\x{222E}", role=>'INTOP', meaning=>'contour-integral'); # CONTOUR INTEGRAL
DefMath('\bigcap',   "\x{22C2}", role=>'SUMOP', meaning=>'intersection',
	scriptpos=>\&doScriptpos); # N-ARY INTERSECTION
DefMath('\bigcup',   "\x{22C3}", role=>'SUMOP', meaning=>'union',
	scriptpos=>\&doScriptpos); # N-ARY UNION
DefMath('\bigsqcup', "\x{2294}", role=>'SUMOP', scriptpos=>\&doScriptpos); # SQUARE CUP (N-ARY ???)
DefMath('\bigvee',   "\x{22C1}", role=>'SUMOP', meaning=>'or',
	scriptpos=>\&doScriptpos); # N-ARY LOGICAL OR
DefMath('\bigwedge', "\x{22C0}", role=>'SUMOP', meaning=>'and',
	scriptpos=>\&doScriptpos); # N-ARY LOGICAL AND
DefMath('\bigodot',  "\x{22A1}", role=>'SUMOP',
	scriptpos=>\&doScriptpos); # CIRCLED DOT OPERATOR (N-ARY ???)
DefMath('\bigotimes',"\x{2297}", role=>'SUMOP',
	scriptpos=>\&doScriptpos); # CIRCLED TIMES (N-ARY ?)
DefMath('\bigoplus', "\x{2295}", role=>'SUMOP',
	scriptpos=>\&doScriptpos); # CIRCLED PLUS (N-ARY ?)
DefMath('\biguplus', "\x{2296}", role=>'SUMOP',
	scriptpos=>\&doScriptpos); # CIRCLED MINUS (N-ARY ?)


DefConstructor('\limits', sub {
   $_[0]->getNode->lastChild->setAttribute(scriptpos=>'mid'); });
DefConstructor('\nolimits',sub {
   $_[0]->getNode->lastChild->setAttribute(scriptpos=>'post'); });

#----------------------------------------------------------------------
# Actually from LaTeX; Table 3.4. Binary Operation Symbols, p.42
#----------------------------------------------------------------------
DefMath('\pm',        UTF(0xB1), role=>'ADDOP', meaning=>'plus-minus'); # PLUS-MINUS SIGN
DefMath('\mp',        "\x{2213}", role=>'ADDOP', meaning=>'minus-plus'); # MINUS-OR-PLUS SIGN
DefMath('\times',     UTF(0xD7), role=>'MULOP', meaning=>'times'); # MULTIPLICATION SIGN
DefMath('\div',       UTF(0xF7), role=>'MULOP', meaning=>'div'); # DIVISION SIGN
DefMath('\ast',       "\x{2217}", role=>'MULOP'); # ASTERISK OPERATOR
DefMath('\star',      "\x{22C6}", role=>'MULOP'); # STAR OPERATOR
DefMath('\circ',      "\x{2218}", role=>'MULOP'); # RING OPERATOR
DefMath('\bullet',    "\x{2219}", role=>'MULOP'); # BULLET OPERATOR
DefMath('\cdot',      "\x{22C5}", role=>'MULOP'); # DOT OPERATOR

# Need to classify set operations more carefully....
DefMath('\cap',       "\x{2229}", role=>'ADDOP', meaning=>'intersection'); # INTERSECTION
DefMath('\cup',       "\x{222A}", role=>'ADDOP', meaning=>'union'); # UNION
DefMath('\uplus',     "\x{228C}", role=>'ADDOP'); # MULTISET
DefMath('\sqcap',     "\x{2293}", role=>'ADDOP'); # SQUARE CAP
DefMath('\sqcup',     "\x{2294}", role=>'ADDOP'); # SQUARE CUP
DefMath('\vee',       "\x{2228}", role=>'ADDOP', meaning=>'or'); # LOGICAL OR
DefMath('\lor',       "\x{2228}", role=>'ADDOP', meaning=>'or'); # LOGICAL OR
DefMath('\wedge',     "\x{2227}", role=>'ADDOP', meaning=>'and'); # LOGICAL AND
DefMath('\land',      "\x{2227}", role=>'ADDOP', meaning=>'and'); # LOGICAL AND
DefMath('\setminus',  "\x{2216}", role=>'ADDOP', meaning=>'set-minus'); # SET MINUS
DefMath('\wr',        "\x{2240}", role=>'MULOP'); # WREATH PRODUCT

# Should this block be ADDOP or something else?
DefMath('\diamond',        "\x{22C4}", role=>'ADDOP'); # DIAMOND OPERATOR
DefMath('\bigtriangleup',  "\x{25B3}", role=>'ADDOP'); # WHITE UP-POINTING TRIANGLE
DefMath('\bigtriangledown',"\x{25BD}", role=>'ADDOP'); # WHITE DOWN-POINTING TRIANGLE
DefMath('\triangleleft',   "\x{25C1}", role=>'ADDOP'); # WHITE LEFT-POINTING SMALL TRIANGLE
DefMath('\triangleright',  "\x{25B7}", role=>'ADDOP'); # WHITE RIGHT-POINTING SMALL TRIANGLE
DefMath('\lhd',            "\x{22B2}", role=>'ADDOP'); # NORMAL SUBGROUP OF
DefMath('\rhd',            "\x{22B3}", role=>'ADDOP'); # CONTAINS AS NORMAL SUBGROUP
DefMath('\unlhd',          "\x{22B4}", role=>'ADDOP'); # NORMAL SUBGROUP OF OR EQUAL TO
DefMath('\unrhd',          "\x{22B5}", role=>'ADDOP'); # CONTAINS AS NORMAL SUBGROUP OR EQUAL TO

DefMath('\oplus',     "\x{2295}", role=>'ADDOP'); # CIRCLED PLUS
DefMath('\ominus',    "\x{2296}", role=>'ADDOP'); # CIRCLED MINUS
DefMath('\otimes',    "\x{2297}", role=>'MULOP'); # CIRCLED TIMES
DefMath('\oslash',    "\x{2298}", role=>'MULOP'); # CIRCLED DIVISION SLASH
DefMath('\odot',      "\x{2299}", role=>'MULOP'); # CIRCLED DOT OPERATOR
DefMath('\bigcirc',   "\x{25CB}", role=>'MULOP'); # WHITE CIRCLE
DefMath('\dagger',    "\x{2020}", role=>'MULOP'); # DAGGER
DefMath('\ddagger',   "\x{2021}", role=>'MULOP'); # DOUBLE DAGGER
DefMath('\amalg',     "\x{2210}", role=>'MULOP'); # N-ARY COPRODUCT

#----------------------------------------------------------------------
# LaTeX; Table 3.5. Relation Symbols, p.43
#----------------------------------------------------------------------
DefMath('\le',        "\x{2264}", role=>'RELOP', meaning=>'less-eq'); # LESS-THAN OR EQUAL TO
DefMath('\ge',        "\x{2265}", role=>'RELOP', meaning=>'greater-eq'); # GREATER-THAN OR EQUAL TO
DefMath('\ne',        "\x{2260}", role=>'RELOP', meaning=>'not-eq'); # NOT EQUAL TO
 
DefMath('\leq',       "\x{2264}", role=>'RELOP', meaning=>'less-eq'); # LESS-THAN OR EQUAL TO
DefMath('\prec',      "\x{227A}", role=>'RELOP', meaning=>'precedes'); # PRECEDES
DefMath('\preceq',    "\x{2AAF}", role=>'RELOP', meaning=>'precedes-eq'); # PRECEDES ABOVE SINGLE-LINE EQUALS SIGN
DefMath('\ll',        "\x{226A}", role=>'RELOP', meaning=>'much-less'); # MUCH LESS-THAN
DefMath('\subset',    "\x{2282}", role=>'RELOP', meaning=>'subset'); # SUBSET OF
DefMath('\subseteq',  "\x{2286}", role=>'RELOP', meaning=>'subset-eq'); # SUBSET OF OR EQUAL TO
DefMath('\sqsubset',  "\x{228F}", role=>'RELOP'); # SQUARE IMAGE OF (latexsym package only!!)
DefMath('\sqsubseteq',"\x{2291}", role=>'RELOP'); # SQUARE IMAGE OF OR EQUAL TO
DefMath('\in',        "\x{2208}", role=>'RELOP', meaning=>'in'); # ELEMENT OF
DefMath('\vdash',     "\x{22A3}", role=>'RELOP'); # LEFT TACK

DefMath('\geq',       "\x{2265}", role=>'RELOP', meaning=>'greater-eq'); # GREATER-THAN OR EQUAL TO
DefMath('\succ',      "\x{227B}", role=>'RELOP', meaning=>'succeeds'); # SUCCEEDS
DefMath('\succeq',    "\x{2AB0}", role=>'RELOP', meaning=>'succeeds-eq'); # SUCCEEDS ABOVE SINGLE-LINE EQUALS SIGN
DefMath('\gg',        "\x{226B}", role=>'RELOP', meaning=>'much-greater'); # MUCH GREATER-THAN
DefMath('\supset',    "\x{2283}", role=>'RELOP', meaning=>'superset'); # SUPERSET OF
DefMath('\supseteq',  "\x{2287}", role=>'RELOP', meaning=>'superset-eq'); # SUPERSET OF OR EQUAL TO
DefMath('\sqsupset',  "\x{2290}", role=>'RELOP'); # SQUARE ORIGINAL OF (latexsym only!)
DefMath('\sqsupseteq',"\x{2292}", role=>'RELOP'); # SQUARE ORIGINAL OF OR EQUAL TO
DefMath('\ni',        "\x{220B}", role=>'RELOP', meaning=>'contains'); # CONTAINS AS MEMBER
DefMath('\dashv',     "\x{22A2}", role=>'RELOP'); # RIGHT TACK

DefMath('\equiv',     "\x{2261}", role=>'RELOP', meaning=>'equiv'); # IDENTICAL TO
DefMath('\sim',       "\x{223C}", role=>'RELOP', meaning=>'similar'); # TILDE OPERATOR
DefMath('\simeq',     "\x{2243}", role=>'RELOP', meaning=>'similar-eq'); # ASYMPTOTICALLY EQUAL TO
DefMath('\asymp',     "\x{224D}", role=>'RELOP', meaning=>'asymp'); # EQUIVALENT TO
DefMath('\approx',    "\x{2248}", role=>'RELOP', meaning=>'approx'); # ALMOST EQUAL TO
DefMath('\cong',      "\x{2245}", role=>'RELOP'); # APPROXIMATELY EQUAL TO
DefMath('\neq',       "\x{2260}", role=>'RELOP', meaning=>'not-eq'); # NOT EQUAL TO
DefMath('\doteq',     "\x{2250}", role=>'RELOP'); # APPROACHES THE LIMIT
DefMath('\notin',     "\x{2209}", role=>'RELOP', meaning=>'not-in'); # NOT AN ELEMENT OF

DefMath('\models',    "\x{22A7}", role=>'RELOP'); # MODELS
DefMath('\perp',      "\x{22A5}", role=>'RELOP'); # UP TACK
DefMath('\mid',       "\x{2223}", role=>'VERTBAR'); # DIVIDES (RELOP?) ?? well, sometimes...
DefMath('\parallel',  "\x{2225}", role=>'VERTBAR'); # PARALLEL TO
DefMath('\bowtie',    "\x{22C8}", role=>'RELOP');   # BOWTIE
DefMath('\Join',      "\x{2A1D}", role=>'RELOP');   # JOIN
DefMath('\smile',     "\x{2323}", role=>'RELOP');   # SMILE
DefMath('\frown',     "\x{2322}", role=>'RELOP');   # FROWN
DefMath('\propto',    "\x{221D}", role=>'RELOP', meaning=>'proportional'); # PROPORTIONAL TO

DefMath('\not',"not", role=>'PREFIX');

#----------------------------------------------------------------------
# Match negations of many operators

our %NOTS = ('='=>"\x{2260}", '<'=> "\x{226E}", '>'=>"\x{226F}",
	     "\x{2208}"=>"\x{2209}", #\in=>\notin
	     "\x{2264}"=>"\x{2270}", "\x{2265}"=>"\x{2271}", # Less eq, greater eq.
	     "\x{227A}"=>"\x{2280}", "\x{227B}"=>"\x{2281}", # prec, succ
	     "\x{2AAF}"=>"\x{22E0}", "\x{2AB0}"=>"\x{22E1}", # preceq, succeq
	     "\x{2282}"=>"\x{2284}", "\x{2283}"=>"\x{2285}", # subset, supset
	     "\x{2286}"=>"\x{2288}", "\x{2287}"=>"\x{2289}", # subseteq, supseteq
	     "\x{2291}"=>"\x{22E2}", "\x{2290}"=>"\x{22E3}", # sqsubseteq, sqsupseteq
	     "\x{2261}"=>"\x{2262}",			     # equiv
	     "\x{224D}"=>"\x{226D}", "\x{2248}"=>"\x{2249}", # asymp, approx
	     "\x{22B2}"=>"\x{22EA}", "\x{22B3}"=>"\x{22EB}", # lhd, rhd
	     "\x{22B4}"=>"\x{22EC}", "\x{22B5}"=>"\x{22ED}", # unlhd, unrhd
	     "\x{2203}"=>"\x{2204}",			     # Exists
	     );

DefMathLigature(sub { my($document,@nodes)=@_;
		      my ($n1,$n2,$op)=($nodes[$#nodes-1],$nodes[$#nodes]);
		      my $c;
		      if(defined $n1
			 && (($document->getNodeQName($n1) eq 'ltx:XMTok')
			     && ($n1->textContent eq 'not'))
			 && (($document->getNodeQName($n2) eq 'ltx:XMTok')
			     &&  $NOTS{$c=$n2->textContent})){
			my $m = $n2->getAttribute('meaning');
			my $n = $n2->getAttribute('name') || $c;
			(2,  $NOTS{$c}, 
			 ($m ? (meaning=>"not-$m"):(name=>"not-$n"))); }});

#----------------------------------------------------------------------
# \joinrel
DefMath('\relbar',     "-", role=>'RELOP'); # ???
DefMath('\Relbar',     "=", role=>'RELOP'); # ???

#----------------------------------------------------------------------
# LaTeX; Table 3.6. Arrow Symbols, p.43
#----------------------------------------------------------------------
# (treat them as RELOP for now ???)

DefMath('\leftarrow',         "\x{2190}", role=>'ARROW'); # LEFTWARDS ARROW
DefMath('\Leftarrow',         "\x{21D0}", role=>'ARROW'); # LEFTWARDS DOUBLE ARROW
DefMath('\rightarrow',        "\x{2192}", role=>'ARROW'); # RIGHTWARDS ARROW
DefMath('\Rightarrow',        "\x{21D2}", role=>'ARROW'); # RIGHTWARDS DOUBLE ARROW
DefMath('\leftrightarrow',    "\x{2194}", role=>'METARELOP');	# LEFT RIGHT ARROW
DefMath('\Leftrightarrow',    "\x{21D4}", role=>'METARELOP'); # LEFT RIGHT DOUBLE ARROW
DefMath('\iff',               "\x{21D4}", role=>'METARELOP', meaning=>'iff'); # LEFT RIGHT DOUBLE ARROW
DefMath('\mapsto',            "\x{21A6}", role=>'ARROW', meaning=>'mapsto'); # RIGHTWARDS ARROW FROM BAR
DefMath('\hookleftarrow',     "\x{21A9}", role=>'ARROW'); # LEFTWARDS ARROW WITH HOOK
DefMath('\leftharpoonup',     "\x{21BC}", role=>'ARROW'); # LEFTWARDS HARPOON WITH BARB UPWARDS
DefMath('\leftharpoondown',   "\x{21BD}", role=>'ARROW'); # LEFTWARDS HARPOON WITH BARB DOWNWARDS
DefMath('\rightleftharpoons', "\x{21CC}", role=>'METARELOP');	# RIGHTWARDS HARPOON OVER LEFTWARDS HARPOON

DefMath('\longleftarrow',     "\x{27F5}", role=>'ARROW'); # LONG LEFTWARDS ARROW
DefMath('\Longleftarrow',     "\x{27F8}", role=>'ARROW'); # LONG LEFTWARDS DOUBLE ARROW
DefMath('\longrightarrow',    "\x{27F6}", role=>'ARROW'); # LONG RIGHTWARDS ARROW
DefMath('\Longrightarrow',    "\x{27F9}", role=>'ARROW'); # LONG RIGHTWARDS DOUBLE ARROW
DefMath('\longleftrightarrow',"\x{27F7}", role=>'METARELOP');	# LONG LEFT RIGHT ARROW
DefMath('\Longleftrightarrow',"\x{27FA}", role=>'METARELOP'); # LONG LEFT RIGHT DOUBLE ARROW
DefMath('\longmapsto',        "\x{27FC}", role=>'ARROW'); # LONG RIGHTWARDS ARROW FROM BAR
DefMath('\hookrightarrow',    "\x{21AA}", role=>'ARROW'); # RIGHTWARDS ARROW WITH HOOK
DefMath('\rightharpoonup',    "\x{21C0}", role=>'ARROW'); # RIGHTWARDS HARPOON WITH BARB UPWARDS
DefMath('\rightharpoondown',  "\x{21C1}", role=>'ARROW'); # RIGHTWARDS HARPOON WITH BARB DOWNWARDS
DefMath('\leadsto',           "\x{219D}", role=>'ARROW', meaning=>'leadsto'); # RIGHTWARDS WAVE ARROW

DefMath('\uparrow',           "\x{2191}", role=>'ARROW'); # UPWARDS ARROW
DefMath('\Uparrow',           "\x{21D1}", role=>'ARROW'); # UPWARDS DOUBLE ARROW
DefMath('\downarrow',         "\x{2193}", role=>'ARROW'); # DOWNWARDS ARROW
DefMath('\Downarrow',         "\x{21D3}", role=>'ARROW'); # DOWNWARDS DOUBLE ARROW
DefMath('\updownarrow',       "\x{2195}", role=>'ARROW'); # UP DOWN ARROW
DefMath('\Updownarrow',       "\x{21D5}", role=>'ARROW'); # UP DOWN DOUBLE ARROW
DefMath('\nearrow',           "\x{2197}", role=>'ARROW'); # NORTH EAST ARROW
DefMath('\searrow',           "\x{2198}", role=>'ARROW'); # SOUTH EAST ARROW
DefMath('\swarrow',           "\x{2199}", role=>'ARROW'); # SOUTH WEST ARROW
DefMath('\nwarrow',           "\x{2196}", role=>'ARROW'); # NORTH WEST ARROW

#======================================================================
# TeX Book, Appendix B. p. 359

#DefMath('\ldots',"\x{2026}", role=>'ID'); # HORIZONTAL ELLIPSIS
# Ah, since \ldots can appear in text....
DefConstructor('\ldots',
	       "?#isMath(<ltx:XMTok name='ldots' font='#font' role='ID'>\x{2026}</ltx:XMTok>)(\x{2026})",
	       properties=>{font=>sub{ LookupValue('font')->merge(family=>'serif');}} ); # Since not DefMath!
DefMath('\cdots',"\x{22EF}", role=>'ID'); # MIDLINE HORIZONTAL ELLIPSIS
DefMath('\vdots',"\x{22EE}", role=>'ID'); # VERTICAL ELLIPSIS
DefMath('\ddots',"\x{22F1}", role=>'ID'); # DOWN RIGHT DIAGONAL ELLIPSIS
DefMath('\colon',':',        role=>'METARELOP'); # Seems like good default role
# Note that amsmath redefines \dots to be `smart'.
# Aha, also can be in text...
DefConstructor('\dots',
	       "?#isMath(<ltx:XMTok name='dots' font='#font' role='ID'>\x{2026}</ltx:XMTok>)(\x{2026})",
	       properties=>{font=>sub{ LookupValue('font')->merge(family=>'serif');}} ); # Since not DefMath!
# And while we're at it...

# Pretest for XMath to keep from interpreting math that the DOM may not allow!!
##DefMathRewrite(xpath=>'descendant-or-self::ltx:XMath',match=>'\cdot\cdot\cdot',replace=>'\cdots');

DefMathLigature(sub { my($document,@nodes)=@_;
		      if((scalar(@nodes) > 3)
			 && ! grep( ($document->getNodeQName($_) ne 'ltx:XMTok')|| ($_->textContent ne "\x{22C5}"),
				    @nodes[$#nodes-2 .. $#nodes])){
			(3, "\x{22EF}", name=>'cdots', role=>'ID'); }});
##DefRewrite(regexp=>"/\\.\\.\\./\x{2026}/"); # ldots
DefLigature("/\\.\\.\\./\x{2026}/", fontTest=>sub { $_[0]->getFamily ne 'typewriter'; }); # ldots

#DefMathRewrite(xpath=>'descendant-or-self::ltx:XMath',match=>'...',replace=>'\ldots');

DefMathLigature(sub { my($document,@nodes)=@_;
		      if((scalar(@nodes) >= 3)
			 && ! grep( ($document->getNodeQName($_) ne 'ltx:XMTok')||($_->textContent ne "."),
				    @nodes[$#nodes-2 .. $#nodes])){
			(3, "\x{2026}", name=>'ldots', role=>'ID'); }});

#----------------------------------------------------------------------
# Math Accents.
#----------------------------------------------------------------------
# LaTeX; Table 3.11. Math Mode Accents, p.50.
# Are these all TeX (or LaTeX)?

DefMath('\hat{}',       UTF(0x5E), operator_role=>'OVERACCENT'); # CIRCUMFLEX ACCENT
DefMath('\check{}',     "\x{2713}", operator_role=>'OVERACCENT'); # CHECK MARK
DefMath('\breve{}',     "\x{02D8}", operator_role=>'OVERACCENT'); # BREVE
DefMath('\acute{}',     UTF(0xB4), operator_role=>'OVERACCENT'); # ACUTE ACCENT
DefMath('\grave{}',     UTF(0x60), operator_role=>'OVERACCENT'); # GRAVE ACCENT
DefMath('\tilde{}',     UTF(0x7E), operator_role=>'OVERACCENT'); # TILDE
DefMath('\bar{}',       UTF(0xAF), operator_role=>'OVERACCENT'); # MACRON
DefMath('\vec{}',       "\x{2192}", operator_role=>'OVERACCENT'); # RIGHTWARDS ARROW
DefMath('\dot{}',       "\x{02D9}", operator_role=>'OVERACCENT'); # DOT ABOVE
DefMath('\ddot{}',      UTF(0xA8), operator_role=>'OVERACCENT'); # DIAERESIS
DefMath('\overline{}',  UTF(0xAF), operator_role=>'OVERACCENT'); # MACRON
DefMath('\overbrace{}', "\x{FE37}", operator_role=>'OVERACCENT',  # PRESENTATION FORM FOR VERTICAL LEFT CURLY BRACKET
	scriptpos=>'mid');
DefMath('\widehat{}',   UTF(0x5E), operator_role=>'OVERACCENT'); # CIRCUMFLEX ACCENT [plain? also amsfonts]
DefMath('\widetilde{}', UTF(0x7E), operator_role=>'OVERACCENT');  # TILDE [plain? also amsfonts]
DefMath('\underbrace{}',"\x{FE38}", operator_role=>'UNDERACCENT', # PRESENTATION FORM FOR VERTICAL RIGHT CURLY BRACKET
	scriptpos=>'mid');

# NOTE that all the above accents REQUIRE math mode
# EXCEPT underline, overrightarrow and overleftarrow!

DefMath('\math@underline{}', UTF(0xAF), operator_role=>'UNDERACCENT', 
	name=>'underline', alias=>'\underline');
DefConstructor('\text@underline{}', "<ltx:text framed='underline'>#1</ltx:text>");
DefMath('\math@overrightarrow{}', "\x{2192}", operator_role=>'OVERACCENT', 
	name=>'overrightarrow', alias=>'\overrightarrow');
DefMath('\math@overleftarrow{}', "\x{2190}", operator_role=>'OVERACCENT', 
	name=>'overleftarrow', alias=>'\overleftarrow');

DefMacro('\underline{}',      '\ifmmode\math@underline{#1}\else\text@underline{#1}\fi');
Let('\underbar','\underline');	# Will anyone notice?

DefMacro('\overrightarrow{}', '\ifmmode\math@overrightarrow{#1}\else$\math@overrightarrow{#1}$\fi');
DefMacro('\overleftarrow{}',  '\ifmmode\math@overleftarrow{#1}\else$\math@overleftarrow{#1}$\fi');

#----------------------------------------------------------------------
# LaTeX; Table 3.10. Delimiters, p.47
#----------------------------------------------------------------------

##DefMath('\{',        '{',        role=>'OPEN');
DefConstructor('\{',
	       "?#isMath(<ltx:XMTok font='#font' role='OPEN'>{</ltx:XMTok>)({)");

## DefMath('\lbrace',   "{",        role=>'OPEN');
Let('\lbrace','\{');
## DefMath('\lbrack',   "[",        role=>'OPEN');
Let('\lbrack','[');
DefMath('\lfloor',   "\x{230A}", role=>'OPEN'); # LEFT FLOOR
DefMath('\lceil',    "\x{2308}", role=>'OPEN'); # LEFT CEILING
DefMath('\langle',   "\x{2329}", role=>'OPEN');   # LEFT-POINTING ANGLE BRACKET
#DefMath('\}',        '}',        role=>'CLOSE');
DefConstructor('\}',
	       "?#isMath(<ltx:XMTok font='#font' role='CLOSE'>}</ltx:XMTok>)(})");

## DefMath('\rbrace',   "}",        role=>'CLOSE');
Let('\rbrace','\}');
## DefMath('\rbrack',   "]",        role=>'CLOSE');
Let('\rbrack',']');
DefMath('\rfloor',   "\x{230B}", role=>'CLOSE'); # RIGHT FLOOR
DefMath('\rceil',    "\x{2309}", role=>'CLOSE'); # RIGHT CEILING
DefMath('\rangle',   "\x{232A}", role=>'CLOSE');	# RIGHT-POINTING ANGLE BRACKET

# TeX marks some symbols as delimiters which can be used with \left,\right,
# but many of which have different grammatical roles otherwise, eg. arrows, <, >.
# Short of setting up TeX's complicated encoding machinery, I need an explicit
# mapping.  Unfortunately, this doesn't (yet) support people declaring thier own delimiters!

# This duplicates in slightly different way what DefMath has put together.
our %DELIMITER_MAP =
  ('('           =>{char=>"(",        lrole=>'OPEN',    rrole=>'CLOSE'},
   ')'           =>{char=>")",        lrole=>'OPEN',    rrole=>'CLOSE'},
   '['           =>{char=>"[",        lrole=>'OPEN',    rrole=>'CLOSE'},
   ']'           =>{char=>"]",        lrole=>'OPEN',    rrole=>'CLOSE'},
   '\{'          =>{char=>"{",        lrole=>'OPEN',    rrole=>'CLOSE'},
   '\}'          =>{char=>"}",        lrole=>'OPEN',    rrole=>'CLOSE'},
   '\lfloor'     =>{char=>"\x{230A}", lrole=>'OPEN',    rrole=>'CLOSE', name=>'lfloor'},
   '\rfloor'     =>{char=>"\x{230B}", lrole=>'OPEN',    rrole=>'CLOSE', name=>'rfloor'},
   '\lceil'      =>{char=>"\x{2308}", lrole=>'OPEN',    rrole=>'CLOSE', name=>'lceil'},
   '\rceil'      =>{char=>"\x{2309}", lrole=>'OPEN',    rrole=>'CLOSE', name=>'rceil'},
   '\langle'     =>{char=>"\x{2329}", lrole=>'OPEN',    rrole=>'CLOSE', name=>'langle'},
   '\rangle'     =>{char=>"\x{232A}", lrole=>'OPEN',    rrole=>'CLOSE', name=>'rangle'},
   '<'           =>{char=>"\x{2329}", lrole=>'OPEN',    rrole=>'CLOSE', name=>'langle'},
   '>'           =>{char=>"\x{232A}", lrole=>'OPEN',    rrole=>'CLOSE', name=>'rangle'},
   '/'           =>{char=>"/",        lrole=>'MULOP',   rrole=>'MULOP'},
   '\backslash'  =>{char=>UTF(0x5C), lrole=>'MULOP',   rrole=>'MULOP', name=>'backslash'},
   '|'           =>{char=>"|",        lrole=>'VERTBAR', rrole=>'VERTBAR'},
   '\|'          =>{char=>"\x{2225}", lrole=>'VERTBAR', rrole=>'VERTBAR'},
   '\uparrow'    =>{char=>"\x{2191}", lrole=>'OPEN',    rrole=>'CLOSE', name=>'uparrow'}, # ??
   '\Uparrow'    =>{char=>"\x{21D1}", lrole=>'OPEN',    rrole=>'CLOSE', name=>'Uparrow'}, # ??
   '\downarrow'  =>{char=>"\x{2193}", lrole=>'OPEN',    rrole=>'CLOSE', name=>'downarrow'}, # ??
   '\Downarrow'  =>{char=>"\x{21D3}", lrole=>'OPEN',    rrole=>'CLOSE', name=>'Downarrow'}, # ??
   '\updownarrow'=>{char=>"\x{2195}", lrole=>'OPEN',    rrole=>'CLOSE', name=>'updownarrow'}, # ??
   '\Updownarrow'=>{char=>"\x{21D5}", lrole=>'OPEN',    rrole=>'CLOSE', name=>'Updownarrow'}, # ??
   );

sub lookup_delimiter {
  $DELIMITER_MAP{$_[0]}; }

# However, it isn't clear that these should get roles of OPEN|CLOSE (?)
DefConstructor('\left Token',"?#char(<ltx:XMTok role='#role' name='#name'>#char</ltx:XMTok>)#body#trailer",
	       afterDigest=>sub { my($stomach,$whatsit)=@_;
				  my $delim = ToString($whatsit->getArg(1));
				  if($delim eq '.'){}
				  elsif(my $entry = $DELIMITER_MAP{$delim}){
				    $whatsit->setProperties(role=>$$entry{lrole},
							    char=>$$entry{char},
							    name=>$$entry{name});}
				  else {
				    Warn("Missing delimiter $delim (. inserted)"); }
				  $_[0]->bgroup; },
	       captureBody=>1);
DefConstructor('\right Token',"?#char(<ltx:XMTok role='#role' name='#name'>#char</ltx:XMTok>)",
	       afterDigest=>sub { my($stomach,$whatsit)=@_;
				  my $delim = ToString($whatsit->getArg(1));
				  if($delim eq '.'){}
				  elsif(my $entry = $DELIMITER_MAP{$delim}){
				    $whatsit->setProperties(role=>$$entry{rrole},
							    char=>$$entry{char},
							    name=>$$entry{name}); }
				  else {
				    Warn("Missing delimiter $delim (. inserted)"); }
				  $_[0]->egroup; });

sub addDelimiterRole {
  my($document,$role)=@_;
  my $node=$document->getNode->lastChild; # This should be the wrapper just added.
  my $delim_role = ($node->firstChild && $node->firstChild->getAttribute('role') || '');
  my $wrapper_role = ($delim_role =~ /^(OPEN|MIDDLE|CLOSE|VERTBAR)$/ ? $role : $delim_role);
  $node->setAttribute(role=>$wrapper_role) if $wrapper_role; }

# Defined in e-Tex and other places.
DefConstructor('\middle Token ',"<ltx:XMWrap style='stretchy'>#1</ltx:XMWrap>",
	       afterConstruct=>sub { addDelimiterRole($_[0],'MIDDLE'); });
DefConstructor('\bigl Token',"<ltx:XMWrap style='big'>#1</ltx:XMWrap>",
	       afterConstruct=>sub { addDelimiterRole($_[0],'OPEN'); });
DefConstructor('\bigm Token',"<ltx:XMWrap style='big'>#1</ltx:XMWrap>",
	       afterConstruct=>sub { addDelimiterRole($_[0],'MIDDLE'); });
DefConstructor('\bigr Token',"<ltx:XMWrap style='big'>#1</ltx:XMWrap>",
	       afterConstruct=>sub { addDelimiterRole($_[0],'CLOSE'); });
DefConstructor('\Bigl Token',"<ltx:XMWrap style='Big'>#1</ltx:XMWrap>",
	       afterConstruct=>sub { addDelimiterRole($_[0],'OPEN'); });
DefConstructor('\Bigm Token',"<ltx:XMWrap style='Big'>#1</ltx:XMWrap>",
	       afterConstruct=>sub { addDelimiterRole($_[0],'MIDDLE'); });
DefConstructor('\Bigr Token',"<ltx:XMWrap style='Big'>#1</ltx:XMWrap>",
	       afterConstruct=>sub { addDelimiterRole($_[0],'CLOSE'); });
DefConstructor('\biggl Token',"<ltx:XMWrap style='bigg'>#1</ltx:XMWrap>",
	       afterConstruct=>sub { addDelimiterRole($_[0],'OPEN'); });
DefConstructor('\biggm Token',"<ltx:XMWrap style='bigg'>#1</ltx:XMWrap>",
	       afterConstruct=>sub { addDelimiterRole($_[0],'MIDDLE'); });
DefConstructor('\biggr Token',"<ltx:XMWrap style='bigg'>#1</ltx:XMWrap>",
	       afterConstruct=>sub { addDelimiterRole($_[0],'CLOSE'); });
DefConstructor('\Biggl Token',"<ltx:XMWrap style='Bigg'>#1</ltx:XMWrap>",
	       afterConstruct=>sub { addDelimiterRole($_[0],'OPEN'); });
DefConstructor('\Biggm Token',"<ltx:XMWrap style='Bigg'>#1</ltx:XMWrap>",
	       afterConstruct=>sub { addDelimiterRole($_[0],'MIDDLE'); });
DefConstructor('\Biggr Token',"<ltx:XMWrap style='Bigg'>#1</ltx:XMWrap>",
	       afterConstruct=>sub { addDelimiterRole($_[0],'CLOSE'); });

# ?
DefConstructor('\big Token',"<ltx:XMWrap style='big'>#1</ltx:XMWrap>",
	       afterConstruct=>sub { addDelimiterRole($_[0]); });
DefConstructor('\Big Token',"<ltx:XMWrap style='Big'>#1</ltx:XMWrap>",
	       afterConstruct=>sub { addDelimiterRole($_[0]); });
DefConstructor('\bigg Token',"<ltx:XMWrap style='bigg'>#1</ltx:XMWrap>",
	       afterConstruct=>sub { addDelimiterRole($_[0]); });
DefConstructor('\Bigg Token',"<ltx:XMWrap style='Bigg'>#1</ltx:XMWrap>",
	       afterConstruct=>sub { addDelimiterRole($_[0]); });

#DefMath('\vert','|', role=>'VERTBAR');
Let('\vert','|');
##DefMath('\Vert',"\x{2225}", role=>'VERTBAR'); # PARALLEL TO
Let('\Vert','\|');
#======================================================================
# TeX Book, Appendix B. p. 360

# \choose, et al, already handle above.


DefExpandable('\mathchoice{}{}{}{}',sub {
  my($gullet,$d,$t,$s,$ss)=@_;
  my $style = LookupValue('mathstyle');
  if   ($style eq 'display'){ $d->unlist; }
  elsif($style eq 'text'   ){ $t->unlist; }
  elsif($style eq 'script' ){ $s->unlist; }
  else                      { $ss->unlist; }});
DefMacro('\mathpalette{}{}',
	 '\mathchoice{#1\displaystyle{#2}}{#1\textstyle{#2}}'
	 .'{#1\scriptstyle{#2}}{#1\scriptscriptstyle{#2}}');
  
DefConstructor('\phantom{}',"?#isMath(<ltx:XMHint name='phantom'/>)()",
	      properties=>{isSpace=>1});
DefConstructor('\hphantom{}',"?#isMath(<ltx:XMHint name='hphantom'/>)()",
	      properties=>{isSpace=>1});
DefConstructor('\vphantom{}',"?#isMath(<ltx:XMHint name='vphantom'/>)()",
	      properties=>{isSpace=>1});
DefConstructor('\mathstrut{}',"?#isMath(<ltx:XMHint name='mathstrut'/>)()",
	      properties=>{isSpace=>1});
DefConstructor('\smash{}',"#1"); # well, what?

#======================================================================
# TeX Book, Appendix B. p. 361

# This is actually LaTeX's definition, but let's just do it this way.
DefConstructor('\sqrt[]{}',
	       "?#1(<ltx:XMApp><ltx:XMTok meaning='root'/>"
	       .     "<ltx:XMArg>#1</ltx:XMArg><ltx:XMArg>#2</ltx:XMArg>"
	       .   "</ltx:XMApp>)"
	       .  "(<ltx:XMApp><ltx:XMTok meaning='sqrt'/>"
	       .    "<ltx:XMArg>#2</ltx:XMArg></ltx:XMApp>)");

DefConstructor('\root Until:\of {}',
	       "<ltx:XMApp><ltx:XMTok meaning='root'/>"
	       .     "<ltx:XMArg>#1</ltx:XMArg><ltx:XMArg>#2</ltx:XMArg>"
	       ."</ltx:XMApp>");

#----------------------------------------------------------------------
# LaTeX; Table 3.9. Log-like Functions, p.44.
#----------------------------------------------------------------------
# NOTE: Classifying some as TRIGFUNCTION might clarify 'pi' ambiguities ?
DefMath('\arccos', "arccos", role=>'OPFUNCTION', meaning=>'arccos');
DefMath('\arcsin', "arcsin", role=>'OPFUNCTION', meaning=>'arcsin');
DefMath('\arctan', "arctan", role=>'OPFUNCTION', meaning=>'arctan');
DefMath('\arg',    "arg", role=>'OPFUNCTION',    meaning=>'arg');

DefMath('\cos',    "cos",  role=>'TRIGFUNCTION', meaning=>'cos');
DefMath('\cosh',   "cosh", role=>'TRIGFUNCTION', meaning=>'cosh');
DefMath('\cot',    "cot",  role=>'TRIGFUNCTION', meaning=>'cot');
DefMath('\coth',   "coth", role=>'TRIGFUNCTION', meaning=>'coth');

DefMath('\csc',    "csc", role=>'TRIGFUNCTION',  meaning=>'cosec');
DefMath('\deg',    "deg", role=>'OPFUNCTION',    meaning=>'degree');
DefMath('\det',    "det", role=>'LIMITOP',       meaning=>'det',
	scriptpos=>\&doScriptpos);
DefMath('\dim',    "dim", role=>'LIMITOP',       meaning=>'dim');

DefMath('\exp',    "exp", role=>'OPFUNCTION',    meaning=>'exp');
DefMath('\gcd',    "gcd", role=>'OPFUNCTION',    meaning=>'gcd',
	scriptpos=>\&doScriptpos);
DefMath('\hom',    "hom", role=>'OPFUNCTION');
DefMath('\inf',    "inf", role=>'LIMITOP',       meaning=>'infimum',
	scriptpos=>\&doScriptpos);

DefMath('\ker',    "ker", role=>'OPFUNCTION',    meaning=>'kernel');
DefMath('\lg',     "lg",  role=>'OPFUNCTION');
DefMath('\lim',    "lim", role=>'LIMITOP',       meaning=>'limit',
	scriptpos=>\&doScriptpos);
DefMath('\liminf', "lim inf", role=>'LIMITOP',   meaning=>'limit-infimum',
	scriptpos=>\&doScriptpos);

DefMath('\limsup', "lim sup", role=>'LIMITOP',   meaning=>'limit-supremum',
	scriptpos=>\&doScriptpos);
DefMath('\ln',     "ln",  role=>'OPFUNCTION',    meaning=>'ln');
DefMath('\log',    "log", role=>'OPFUNCTION',    meaning=>'log');
DefMath('\max',    "max", role=>'LIMITOP',       meaning=>'max',
	scriptpos=>\&doScriptpos);

DefMath('\min',    "min", role=>'LIMITOP',       meaning=>'min',
	scriptpos=>\&doScriptpos);
DefMath('\Pr',     "Pr",  role=>'OPFUNCTION', scriptpos=>\&doScriptpos);
DefMath('\sec',    "sec", role=>'TRIGFUNCTION',  meaning=>'sec');
DefMath('\sin',    "sin", role=>'TRIGFUNCTION',  meaning=>'sin');

DefMath('\sinh',   "sinh", role=>'TRIGFUNCTION', meaning=>'sinh');
DefMath('\sup',    "sup",  role=>'LIMITOP',      meaning=>'supremum',
	scriptpos=>\&doScriptpos);
DefMath('\tan',    "tan",  role=>'TRIGFUNCTION', meaning=>'tan');
DefMath('\tanh',   "tanh", role=>'TRIGFUNCTION', meaning=>'tanh');

#----------------------------------------------------------------------
# Modulo

DefMath('\pmod{}', '(\textrm{mod} #1)', role=>'MODIFIER');
DefMath('\bmod',   'mod', role=>'MODIFIEROP');

#======================================================================
# TeX Book, Appendix B. p. 362
DefMacro('\matrix{}',
	 '\@@matrix{\@start@alignment#1\@finish@alignment}');
DefConstructor('\@@matrix{}',
	       sub { my($document,$body,%props)=@_;
		     constructAlignment($document,$body,attributes=>{name=>'Matrix'}); },
	       reversion=>'\matrix{#1}', bounded=>1,
	       beforeDigest=>sub { alignmentBindings(MatrixTemplate()); });

# TODO: This is wrong; I'm not even clear how this differs from \matrix
DefMacro('\bordermatrix{}',
	 '\@@bordermatrix{\@start@alignment#1\@finish@alignment}');
DefConstructor('\@@bordermatrix{}',
	       sub { my($document,$body,%props)=@_;
		     constructAlignment($document,$body,attributes=>{name=>'Matrix'}); },
	       reversion=>'\bordermatrix{#1}', bounded=>1,
	       beforeDigest=>sub { alignmentBindings(MatrixTemplate()); });

DefMacro('\pmatrix{}',
	 '\@@pmatrix{\@start@alignment#1\@finish@alignment}');
DefConstructor('\@@pmatrix{}',
	       sub { my($document,$body,%props)=@_;
		     constructAlignment($document,$body,attributes=>{name=>'Matrix',
								     open=>'(',close=>')'}); },
	       reversion=>'\pmatrix{#1}', bounded=>1,
	       beforeDigest=>sub { alignmentBindings(MatrixTemplate()); });


# Note that 2nd column in \cases is in text mode!
DefMacro('\cases{}',
	 '\@@cases{\@start@alignment#1\@finish@alignment}');
DefConstructor('\@@cases{}',
	       sub { my($document,$body,%props)=@_;
		     constructAlignment($document,$body,attributes=>{name=>'Cases'}); },
	       reversion=>'\cases{#1}', bounded=>1,
	       beforeDigest=>sub { 
 		 my $col1 = {before=>Tokens(), after=>Tokens(T_CS('\hfil'))};
 		 my $col2 = {before=>Tokens(T_CS('\hbox'),T_BEGIN),
			     after=>Tokens(T_END,T_CS('\hfil'))};
		 alignmentBindings(LaTeXML::AlignmentTemplate->new(columns=>[$col1,$col2])); });

DefPrimitive('\openup Dimension',undef);

# What should this do? (needs to work with alignments..)
DefMacro('\displaylines{}','#1');

DefMacro('\eqalign{}',
	 '\@@eqalign{\@start@alignment#1\@finish@alignment}');
DefConstructor('\@@eqalign{}',
	       sub { my($document,$body,%props)=@_;
		     constructAlignment($document,$body); },
	       reversion=>'\eqalign{#1}', bounded=>1,
	       beforeDigest=>sub { alignmentBindings('rl'); });

DefMacro('\eqalignno{}',
	 '\@@eqalignno{\@start@alignment#1\@finish@alignment}');
DefConstructor('\@@eqalignno{}',
	       sub { my($document,$body,%props)=@_;
		     constructAlignment($document,$body); },
	       reversion=>'\eqalignno{#1}', bounded=>1,
	       beforeDigest=>sub { alignmentBindings('rll'); });

DefMacro('\leqalignno{}',
	 '\@@leqalignno{\@start@alignment#1\@finish@alignment}');
DefConstructor('\@@leqalignno{}',
	       sub { my($document,$body,%props)=@_;
		     constructAlignment($document,$body); },
	       reversion=>'\leqalignno{#1}', bounded=>1,
	       beforeDigest=>sub { alignmentBindings('rll'); });


DefRegister('\pageno'=>Number(0));
DefRegister('\headline'=>Tokens());
DefRegister('\footline'=>Tokens());
DefExpandable('\folio', sub {
  Explode(LookupValue($_[1]->toString)->valueOf); });

DefPrimitive('\nopagenumbers',undef);
DefMacro('\advancepageno','\advance\pageno1\relax');

#======================================================================
# TeX Book, Appendix B. p. 363

DefPrimitive('\raggedbottom',undef);
DefPrimitive('\normalbottom',undef);

# if the mark is not simple, we add it to the content of the note
# otherwise, to the attribute.
DefConstructor('\footnote{}{}',
             "<ltx:note class='foot' ?#mark(mark='#mark')()>?#prenote(#prenote )()#2</ltx:note>",
             afterDigest=>sub {
               my ($stomach, $whatsit) = @_;
               my $mark = $whatsit->getArg(1);
               my $change = 0;
               foreach my $token($mark->revert) {
                 unless ($token->getCatcode == CC_LETTER || $token->getCatcode == CC_SPACE ||
                         $token->getCatcode == CC_OTHER) {
                   $change = 1; last; }}
               $whatsit->setProperty(($change ? 'prenote' : 'mark')=>$mark);
               return; });
DefPrimitive('\footstrut', undef);
DefRegister('\footins'=>Dimension(0));

DefPrimitive('\topinsert',undef);
DefPrimitive('\midinsert',undef);
DefPrimitive('\pageinsert',undef);
DefPrimitive('\endinsert',undef);
# \topins ?

#======================================================================
# TeX Book, Appendix B. p. 364

# Let's hope nobody is messing with the output routine...

DefPrimitive('\footnoterule',undef);
DefPrimitive('\tracingall',undef);

#======================================================================
# End of TeX Book definitions.
#======================================================================


#**********************************************************************
# Stray stuff .... where to ?
#**********************************************************************

# Mostly ignorable, although it could add an attribute to an ancestor
# to record the desired justification.
# Spacing stuff
DefConstructor('\@','');
# Math spacing.


# Math style.
DefConstructor('\displaystyle','',afterDigest=>sub { AssignValue(mathstyle=>'display'); });
DefConstructor('\textstyle',   '',afterDigest=>sub { AssignValue(mathstyle=>'text'); });
DefConstructor('\scriptstyle', '',afterDigest=>sub { AssignValue(mathstyle=>'script'); });
DefConstructor('\scriptscriptstyle','',afterDigest=>sub { AssignValue(mathstyle=>'scriptscript'); });

#======================================================================

# Special Characters.
DefConstructor('\#',   '#');
DefConstructor('\&',   '&');
#DefConstructor('\%',   '%');
DefMacro('\%',Tokens(T_OTHER('%')));
DefConstructor("\\\$", "\$");
DefConstructor('\_',   '_');


### How did this get added ?
#### DefMath('\dot',"\x{22C5}", role=>'MULOP');	# DOT OPERATOR
# Discretionary times; just treat as invisible ?
DefMath('\*',"\x{2062}", role=>'MULOP'); # INVISIBLE TIMES (or MULTIPLICATION SIGN = 00D7)


# These 3 should have some `name' assigned ... but what???

# NOTE that \mathord and \mathbin aren't really right here.
# We need a finer granularity than TeX does: an ORD could be several things,
# a BIN could be a MULOP or ADDOP.
DefConstructor('\mathord{}',"<ltx:XMWrap role='ID'>#1</ltx:XMWrap>");
DefConstructor('\mathop{}', "<ltx:XMWrap role='FUNCTION'>#1</ltx:XMWrap>");
DefConstructor('\mathbin{}', "<ltx:XMWrap role='ADDOP'>#1</ltx:XMWrap>");
DefConstructor('\mathrel{}',"<ltx:XMWrap role='RELOP'>#1</ltx:XMWrap>");
DefConstructor('\mathopen{}', "<ltx:XMWrap role='OPEN'>#1</ltx:XMWrap>");
DefConstructor('\mathclose{}', "<ltx:XMWrap role='CLOSE'>#1</ltx:XMWrap>");
DefConstructor('\mathpunct{}', "<ltx:XMWrap role='PUNCT'>#1</ltx:XMWrap>");


DefMacro('\hiderel{}', "#1"); # Just ignore, for now...

DefMath('\to',"\x{2192}", role=>'ARROW'); # RIGHTWARDS ARROW??? a bit more explicitly relation-like?


# TeX's ligatures handled by rewrite regexps.
##DefRewrite(regexp=>"/---/\x{2014}/"); # EM DASH
##DefRewrite(regexp=>"/--/\x{2013}/"); # EN DASH (NOTE: With digits before & aft => \N{FIGURE DASH})
##DefRewrite(regexp=>"/\`\`/\x{201C}/");
##DefRewrite(regexp=>"/\'\'/\x{201D}/");
DefLigature("/--/\x{2013}/",   fontTest=>sub { $_[0]->getFamily ne 'typewriter'; }); # EN DASH (NOTE: With digits before & aft => \N{FIGURE DASH})
DefLigature("/---/\x{2014}/",  fontTest=>sub { $_[0]->getFamily ne 'typewriter'; }); # EM DASH
DefLigature("/\`\`/\x{201C}/", fontTest=>sub { $_[0]->getFamily ne 'typewriter'; });
DefLigature("/\'\'/\x{201D}/", fontTest=>sub { $_[0]->getFamily ne 'typewriter'; });

DefConstructor('\TeX', 'TeX');
DefConstructor('\i',"\x{0131}");	# LATIN SMALL LETTER DOTLESS I
DefConstructor('\j',"j");	# Apparently, no Unicode equivalent...

DefConstructor('\buildrel Until:\over {}',
	       "<ltx:XMApp role='RELOP'>"
	       .  "<ltx:XMTok role='SUPERSCRIPTOP'/>"
	       .  "<ltx:XMWrap scriptpos='#scriptpos'>#2</ltx:XMWrap>"
	       .  "<ltx:XMWrap>#1</ltx:XMWrap>"
	       ."</ltx:XMApp>",
	       properties=>{scriptpos=>sub{ "mid".$_[0]->getBoxingLevel; }});

#**********************************************************************
# LaTeX Hook
#**********************************************************************
# This is used for plain TeX, but needs to be undone for LaTeX!
DocType("ltx:document","-//NIST LaTeXML//LaTeXML article",'LaTeXML.dtd', 
	'#default'=>"http://dlmf.nist.gov/LaTeXML");
Tag('ltx:section', autoClose=>1, autoOpen=>1);
Tag('ltx:document', autoClose=>1, autoOpen=>1);

# No, \documentclass isn't really a primitive -- It's not even TeX!
# But we define a number of stubs here that will automatically load
# the LaTeX pool (which will presumably redefine them), and then
# stuff the token back to be reexecuted.
sub LaTeXTrigger {
  my($gullet,$cs)=@_;
  if(my $poolfile = FindFile("LaTeX.pool")){
    $gullet->input($poolfile); }
  else {
    Fatal("Installation error: Cannot find LaTeX pool module!"); }
  $gullet->unread(T_CS("\\".$cs));
  (); }

foreach my $trigger (qw(documentclass documentstyle newcommand
			makeatletter makeatother)){
  DefMacro("\\".$trigger, sub { LaTeXTrigger($_[0],$trigger); }); }

#**********************************************************************
# LaTeXML Specific.
# Support for Declarations & Presentation/Semantic Duality
#**********************************************************************
DefConstructor('\DUAL[]{}{}',
	       "<ltx:XMDual ?#1(role='#1')>#2<ltx:XMWrap>#3</ltx:XMWrap></ltx:XMDual>",
	       reversion=>sub {
		 my($whatsit)=@_;
		 my($role,$content,$presentation)=$whatsit->getArgs;
		 if(!$LaTeXML::DUAL_BRANCH) {
		   $whatsit->getDefinition->invocation($role,$content,
						       $presentation); }
		 elsif($LaTeXML::DUAL_BRANCH eq 'content'){
		   $content->revert; }
		 elsif($LaTeXML::DUAL_BRANCH eq 'presentation'){
		   $presentation->revert; }
		 else{
		   Warn("Unknown DUAL_BRANCH: $LaTeXML::DUAL_BRANCH");
		   $whatsit->getDefinition->invocation($role,$content,
						       $presentation); }
	       });

# Normally, the content branch contains the pure structure and meaning of a construct,
# and the presentation is generated from lower level TeX macros that only concern
# themselves with how to display the object.
# Nevertheless, it is sometimes useful to know where the tokens in the presentation branch
# came from;  particularly what their presumed "meaning" is.
# For example, when search-indexing pmml, or providing links to definitions from the pmml.
#
# The following constructor (see how it's used in DefMath), adds meaning attributes
# whereever it seems sensible on the presentation branch, after it has been generated.
DefConstructor('\@ASSERT@MEANING{}{}','#2',reversion=>'#2',
	       afterConstruct=>sub {
		 my($document,$whatsit)=@_;
		 my $node=$document->getNode; # This should be the wrapper just added.
		 my $meaning = ToString($whatsit->getArg(1));
		 addMeaningRec($document,$node,$meaning);
		 $node; });

sub addMeaningRec {
  my($document,$node,$meaning)=@_;
  if($node->nodeType == XML_ELEMENT_NODE){
    if($document->getNodeQName($node) eq 'ltx:XMTok'){
      if((($node->getAttribute('role')||'UNKNOWN') eq 'UNKNOWN')
	 && !$node->getAttribute('meaning')){
	$node->setAttribute(meaning=>$meaning); }}
    else {
      foreach my $c ($node->childNodes){
	addMeaningRec($document,$c,$meaning); }}}}

DefConstructor('\FCN{}',    "<ltx:XMWrap role='FUNCTION'>#1</ltx:XMWrap>", reversion=>'#1', alias=>'');
DefConstructor('\ROLE{}{}', "<ltx:XMWrap role='#1'>#2</ltx:XMWrap>",       reversion=>'#2', alias=>'');

# NOTE: work through this systematically!
DefConstructor('\@SYMBOL{}', "<ltx:XMWrap role='ID'>#1</ltx:XMWrap>", reversion=>'#1');
DefConstructor('\@APPLY{}',  "<ltx:XMApp>#1</ltx:XMApp>", reversion=>'#1');
DefConstructor('\@MAYBEAPPLY{}{}',
	       "?#2(<ltx:XMApp>#1#2</ltx:XMApp>)(#1)",
	       reversion=>'#1#2');
DefConstructor('\@WRAP{}',   "<ltx:XMWrap>#1</ltx:XMWrap>", reversion=>'#1');
DefConstructor('\@TOKEN{}',   "<ltx:XMTok name='#1'/>", reversion=>'');
DefMath('\@APPLYFUNCTION', "\x{2061}", reversion=>'',
	name=>'', role=>'APPLYOP');
DefMath('\@INVISIBLETIMES',"\x{2062}", reversion=>'', 
	name=>'', meaning=>'times', role=>'MULOP');
DefMath('\@INVISIBLECOMMA',"\x{2063}", reversion=>'',
	name=>'', role=>'PUNCT');

# Would be nice to make the ID argument optional, but since these can appear in
# optional arguments to other macros, we'll end up nesting [] !!
DefConstructor('\@XMArg{}{}',"<ltx:XMArg ?#1(id='#1')>#2</ltx:XMArg>", reversion=>'#2',
	       properties=>{id=>'#1'});
DefConstructor('\@XMRef{}',"<ltx:XMRef idref='#1'/>",
	       reversion=>sub{ LookupValue('xref:'.$_[0]->getArg(1)->toString)->revert; });

DefConstructor('\@ERROR{}{}', "<ltx:ERROR type='#1'>#2</ltx:ERROR>");

#**********************************************************************
DefConstructor('\WildCard',"<_WildCard_/>");
DefConstructor('\WildCardA',"<_WildCard_/>");
DefConstructor('\WildCardB',"<_WildCard_/>");
DefConstructor('\WildCardC',"<_WildCard_/>");
#**********************************************************************

# This constructor allows you to stick things in expansions for effect
# but their reversion disappears, so they don't appear in the tex attribute (eg).
DefConstructor('\@hidden{}','',reversion=>'');

#**********************************************************************
# After all other rewrites have acted, a little cleanup 

DefRewrite(xpath=>'descendant-or-self::ltx:XMWrap[count(child::*)=1]',
	  replace=>sub { my($document,$wrap)=@_;
			 my $node = $wrap->firstChild;
			 foreach my $attribute ($wrap->attributes){
			   if($attribute->nodeType == XML_ATTRIBUTE_NODE){
			     my $attr = $attribute->nodeName;
			     $node->setAttribute($attr,$attribute->getValue) unless $attr =~ /^_/; }}
#			 $wrap->parentNode->replaceChild($node,$wrap); });
			 ## WHY THIS????
			 $document->getNode->appendChild($node); });
#**********************************************************************

1;
